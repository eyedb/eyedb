
/*
 * EyeDB Version 2.8.8-nfs-fix-nkg Copyright (c) 1995-2006 SYSRA
 *
 * File 'DBM.cc'
 *
 * Package Name 'DBM'
 *
 * Generated by eyedbodl at Sun Sep 18 18:00:18 2016
 *
 * ---------------------------------------------------
 * -------------- DO NOT EDIT THIS CODE --------------
 * ---------------------------------------------------
 *
 */

#include <eyedb/eyedb.h>

#include <eyedb/internals/ObjectPeer.h>
#include <eyedb/internals/ClassPeer.h>
#include <eyedb/internals/kern_const.h>

#include <eyedb/DBM.h>

#define min(x,y)((x)<(y)?(x):(y))

namespace eyedb {

static eyedb::Bool dynget_error_policy = eyedb::False;
static eyedb::Bool dynset_error_policy = eyedb::True;
static eyedb::Oid nulloid;
static unsigned char nulldata[1];
static eyedb::Bool oid_check = eyedb::True;
static int class_ind;
static eyedb::Database::consapp_t *constructors_x = new eyedb::Database::consapp_t[113];
static eyedb::Object *(*constructors[113])(const eyedb::Object *, eyedb::Bool);
static eyedb::GenHashTable *hash;
#define make_object DBMMakeObject
extern void DBMInit(void);
extern void DBMRelease(void);
extern eyedb::Status DBMSchemaUpdate(eyedb::Database *);
extern eyedb::Status DBMSchemaUpdate(eyedb::Schema *);

static eyedb::Class *index_Class = new eyedb::Class("index");

void DBM::init()
{
  DBMInit();
}

void DBM::release()
{
  DBMRelease();
}

eyedb::Status DBM::updateSchema(eyedb::Database *db)
{
  return DBMSchemaUpdate(db);
}

eyedb::Status DBM::updateSchema(eyedb::Schema *m)
{
  return DBMSchemaUpdate(m);
}

static eyedb::EnumClass *SysAccessMode_Class;
static eyedb::EnumClass *DBAccessMode_Class;
static eyedb::EnumClass *UserType_Class;
static eyedb::StructClass *UserEntry_Class;
static eyedb::StructClass *DBUserAccess_Class;
static eyedb::StructClass *SysUserAccess_Class;
static eyedb::StructClass *DBEntry_Class;
static eyedb::StructClass *DBPropertyValue_Class;
static eyedb::StructClass *DBProperty_Class;

static eyedb::Size SysAccessMode_idr_objsz, SysAccessMode_idr_psize;

static eyedb::EnumClass *SysAccessMode_make(eyedb::EnumClass *SysAccessMode_class = 0, eyedb::Schema *m = 0)
{
  if (!SysAccessMode_class)
    return new eyedb::EnumClass("system_access_mode");
  eyedb::EnumItem *en[7];
  en[0] = new eyedb::EnumItem("NO_SYSACCESS_MODE", "NoSysAccessMode", (unsigned int)0);
  en[1] = new eyedb::EnumItem("DB_CREATE_SYSACCESS_MODE", "DBCreateSysAccessMode", (unsigned int)256);
  en[2] = new eyedb::EnumItem("ADD_USER_SYSACCESS_MODE", "AddUserSysAccessMode", (unsigned int)512);
  en[3] = new eyedb::EnumItem("DELETE_USER_SYSACCESS_MODE", "DeleteUserSysAccessMode", (unsigned int)1024);
  en[4] = new eyedb::EnumItem("SET_USER_PASSWD_SYSACCESS_MODE", "SetUserPasswdSysAccessMode", (unsigned int)2048);
  en[5] = new eyedb::EnumItem("ADMIN_SYSACCESS_MODE", "AdminSysAccessMode", (unsigned int)768);
  en[6] = new eyedb::EnumItem("SUPERUSER_SYSACCESS_MODE", "SuperUserSysAccessMode", (unsigned int)4095);

  SysAccessMode_class->setEnumItems(en, 7);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];
  delete en[4];
  delete en[5];
  delete en[6];


  return SysAccessMode_class;
}

static void SysAccessMode_init_p()
{
  SysAccessMode_Class = SysAccessMode_make();
}

static void SysAccessMode_init()
{
  SysAccessMode_make(SysAccessMode_Class);

  SysAccessMode_idr_objsz = SysAccessMode_Class->getIDRObjectSize(&SysAccessMode_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(SysAccessMode_Class, eyedb::True);
}

static eyedb::Size DBAccessMode_idr_objsz, DBAccessMode_idr_psize;

static eyedb::EnumClass *DBAccessMode_make(eyedb::EnumClass *DBAccessMode_class = 0, eyedb::Schema *m = 0)
{
  if (!DBAccessMode_class)
    return new eyedb::EnumClass("database_access_mode");
  eyedb::EnumItem *en[8];
  en[0] = new eyedb::EnumItem("NO_DBACCESS_MODE", "NoDBAccessMode", (unsigned int)0);
  en[1] = new eyedb::EnumItem("READ_DBACCESS_MODE", "ReadDBAccessMode", (unsigned int)16);
  en[2] = new eyedb::EnumItem("WRITE_DBACCESS_MODE", "WriteDBAccessMode", (unsigned int)32);
  en[3] = new eyedb::EnumItem("EXEC_DBACCESS_MODE", "ExecDBAccessMode", (unsigned int)64);
  en[4] = new eyedb::EnumItem("READ_WRITE_DBACCESS_MODE", "ReadWriteDBAccessMode", (unsigned int)48);
  en[5] = new eyedb::EnumItem("READ_EXEC_DBACCESS_MODE", "ReadExecDBAccessMode", (unsigned int)80);
  en[6] = new eyedb::EnumItem("READ_WRITE_EXEC_DBACCESS_MODE", "ReadWriteExecDBAccessMode", (unsigned int)112);
  en[7] = new eyedb::EnumItem("ADMIN_DBACCESS_MODE", "AdminDBAccessMode", (unsigned int)113);

  DBAccessMode_class->setEnumItems(en, 8);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];
  delete en[4];
  delete en[5];
  delete en[6];
  delete en[7];


  return DBAccessMode_class;
}

static void DBAccessMode_init_p()
{
  DBAccessMode_Class = DBAccessMode_make();
}

static void DBAccessMode_init()
{
  DBAccessMode_make(DBAccessMode_Class);

  DBAccessMode_idr_objsz = DBAccessMode_Class->getIDRObjectSize(&DBAccessMode_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(DBAccessMode_Class, eyedb::True);
}

static eyedb::Size UserType_idr_objsz, UserType_idr_psize;

static eyedb::EnumClass *UserType_make(eyedb::EnumClass *UserType_class = 0, eyedb::Schema *m = 0)
{
  if (!UserType_class)
    return new eyedb::EnumClass("user_type");
  eyedb::EnumItem *en[3];
  en[0] = new eyedb::EnumItem("EYEDB_USER", "EyeDBUser", (unsigned int)1);
  en[1] = new eyedb::EnumItem("UNIX_USER", "UnixUser", (unsigned int)2);
  en[2] = new eyedb::EnumItem("STRICT_UNIX_USER", "StrictUnixUser", (unsigned int)3);

  UserType_class->setEnumItems(en, 3);

  delete en[0];
  delete en[1];
  delete en[2];


  return UserType_class;
}

static void UserType_init_p()
{
  UserType_Class = UserType_make();
}

static void UserType_init()
{
  UserType_make(UserType_Class);

  UserType_idr_objsz = UserType_Class->getIDRObjectSize(&UserType_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(UserType_Class, eyedb::True);
}

static const eyedb::Attribute **UserEntry_agritems;
static eyedb::Size UserEntry_idr_objsz, UserEntry_idr_psize;

static eyedb::StructClass *UserEntry_make(eyedb::StructClass *UserEntry_class = 0, eyedb::Schema *m = 0)
{
  if (!UserEntry_class)
    return new eyedb::StructClass("user_entry", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[6];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "name", eyedb::False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "passwd", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "uid", eyedb::False, 0, dims);

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("user_type") : UserType_Class), "type", eyedb::False, 0, dims);

  UserEntry_class->setAttributes(&attr[2], 4);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];


  return UserEntry_class;
}

eyedb::Object *UserEntry_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new UserEntry(cls, idr);
}

eyedb::Object *UserEntry_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new UserEntry((const eyedb::Struct *)o, share);
}

static void UserEntry_init_p()
{
  UserEntry_Class = UserEntry_make();
  constructors_x[class_ind] = UserEntry_construct_x;
  constructors[class_ind] = UserEntry_construct;
  hash->insert("user_entry", class_ind++);
}

static void UserEntry_init()
{
  UserEntry_make(UserEntry_Class);

  UserEntry_agritems = UserEntry_Class->getAttributes();
  UserEntry_idr_objsz = UserEntry_Class->getIDRObjectSize(&UserEntry_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(UserEntry_Class, eyedb::True);
}

static eyedb::Status UserEntry_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  comp = new eyedb::UniqueConstraint(db, cls, "user_entry.name", eyedb::True);
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "user_entry.name", eyedb::True, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::BTreeIndex(db, cls, "user_entry.uid", eyedb::True, eyedb::False, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

UserEntry::UserEntry(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

UserEntry::UserEntry(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void UserEntry::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("user_entry") : UserEntry_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

UserEntry::UserEntry(const UserEntry& x) : eyedb::Struct(x)
{
  userCopy(x);
}

UserEntry& UserEntry::operator=(const UserEntry& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

UserEntry::UserEntry(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("user_entry") : UserEntry_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

UserEntry::UserEntry(const UserEntry *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("user_entry") : UserEntry_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status UserEntry::name(const std::string &_name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _name.size() + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)_name.c_str(), len, 0);
  return status;

}

eyedb::Status UserEntry::name(unsigned int a0, char _name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_name, 1, from);
  return status;
}

std::string UserEntry::name(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char UserEntry::name(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status UserEntry::passwd(const std::string &_passwd)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _passwd.size() + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)_passwd.c_str(), len, 0);
  return status;

}

eyedb::Status UserEntry::passwd(unsigned int a0, char _passwd)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_passwd, 1, from);
  return status;
}

std::string UserEntry::passwd(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char UserEntry::passwd(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status UserEntry::uid(eyedblib::int32 _uid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_uid, 1, 0);
  return status;
}

eyedblib::int32 UserEntry::uid(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status UserEntry::type(UserType _type, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _type;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

UserType UserEntry::type(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (UserType)0;}
  return (UserType)__tmp;
}

static const eyedb::Attribute **DBUserAccess_agritems;
static eyedb::Size DBUserAccess_idr_objsz, DBUserAccess_idr_psize;

static eyedb::StructClass *DBUserAccess_make(eyedb::StructClass *DBUserAccess_class = 0, eyedb::Schema *m = 0)
{
  if (!DBUserAccess_class)
    return new eyedb::StructClass("database_user_access", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[5];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("database_entry") : DBEntry_Class), "dbentry", eyedb::True, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("user_entry") : UserEntry_Class), "user", eyedb::True, 0, dims);

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("database_access_mode") : DBAccessMode_Class), "mode", eyedb::False, 0, dims);

  DBUserAccess_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];


  return DBUserAccess_class;
}

eyedb::Object *DBUserAccess_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new DBUserAccess(cls, idr);
}

eyedb::Object *DBUserAccess_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new DBUserAccess((const eyedb::Struct *)o, share);
}

static void DBUserAccess_init_p()
{
  DBUserAccess_Class = DBUserAccess_make();
  constructors_x[class_ind] = DBUserAccess_construct_x;
  constructors[class_ind] = DBUserAccess_construct;
  hash->insert("database_user_access", class_ind++);
}

static void DBUserAccess_init()
{
  DBUserAccess_make(DBUserAccess_Class);

  DBUserAccess_agritems = DBUserAccess_Class->getAttributes();
  DBUserAccess_idr_objsz = DBUserAccess_Class->getIDRObjectSize(&DBUserAccess_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(DBUserAccess_Class, eyedb::True);
}

static eyedb::Status DBUserAccess_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "database_user_access.dbentry", eyedb::True, eyedb::False, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "database_user_access.user", eyedb::True, eyedb::False, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

DBUserAccess::DBUserAccess(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

DBUserAccess::DBUserAccess(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void DBUserAccess::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("database_user_access") : DBUserAccess_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

DBUserAccess::DBUserAccess(const DBUserAccess& x) : eyedb::Struct(x)
{
  userCopy(x);
}

DBUserAccess& DBUserAccess::operator=(const DBUserAccess& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

DBUserAccess::DBUserAccess(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_user_access") : DBUserAccess_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

DBUserAccess::DBUserAccess(const DBUserAccess *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_user_access") : DBUserAccess_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status DBUserAccess::dbentry(DBEntry*_dbentry)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_odbentry = _dbentry;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_odbentry, 1, 0);
  return status;
}

const DBEntry*DBUserAccess::dbentry(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (DBEntry *)__o;
     }
     __go = (DBEntry *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (DBEntry*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (DBEntry *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (DBEntry*)__o;
}

DBEntry*DBUserAccess::dbentry(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (DBEntry *)__o;
     }
     __go = (DBEntry *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (DBEntry*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (DBEntry *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (DBEntry*)__o;
}

eyedb::Status DBUserAccess::dbentry_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid DBUserAccess::dbentry_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status DBUserAccess::user(UserEntry*_user)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ouser = _user;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_ouser, 1, 0);
  return status;
}

const UserEntry*DBUserAccess::user(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (UserEntry *)__o;
     }
     __go = (UserEntry *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (UserEntry*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (UserEntry *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (UserEntry*)__o;
}

UserEntry*DBUserAccess::user(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (UserEntry *)__o;
     }
     __go = (UserEntry *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (UserEntry*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (UserEntry *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (UserEntry*)__o;
}

eyedb::Status DBUserAccess::user_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid DBUserAccess::user_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status DBUserAccess::mode(DBAccessMode _mode, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _mode;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

DBAccessMode DBUserAccess::mode(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (DBAccessMode)0;}
  return (DBAccessMode)__tmp;
}

static const eyedb::Attribute **SysUserAccess_agritems;
static eyedb::Size SysUserAccess_idr_objsz, SysUserAccess_idr_psize;

static eyedb::StructClass *SysUserAccess_make(eyedb::StructClass *SysUserAccess_class = 0, eyedb::Schema *m = 0)
{
  if (!SysUserAccess_class)
    return new eyedb::StructClass("system_user_access", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("user_entry") : UserEntry_Class), "user", eyedb::True, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("system_access_mode") : SysAccessMode_Class), "mode", eyedb::False, 0, dims);

  SysUserAccess_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return SysUserAccess_class;
}

eyedb::Object *SysUserAccess_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new SysUserAccess(cls, idr);
}

eyedb::Object *SysUserAccess_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new SysUserAccess((const eyedb::Struct *)o, share);
}

static void SysUserAccess_init_p()
{
  SysUserAccess_Class = SysUserAccess_make();
  constructors_x[class_ind] = SysUserAccess_construct_x;
  constructors[class_ind] = SysUserAccess_construct;
  hash->insert("system_user_access", class_ind++);
}

static void SysUserAccess_init()
{
  SysUserAccess_make(SysUserAccess_Class);

  SysUserAccess_agritems = SysUserAccess_Class->getAttributes();
  SysUserAccess_idr_objsz = SysUserAccess_Class->getIDRObjectSize(&SysUserAccess_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(SysUserAccess_Class, eyedb::True);
}

static eyedb::Status SysUserAccess_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "system_user_access.user", eyedb::True, eyedb::False, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

SysUserAccess::SysUserAccess(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

SysUserAccess::SysUserAccess(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void SysUserAccess::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("system_user_access") : SysUserAccess_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

SysUserAccess::SysUserAccess(const SysUserAccess& x) : eyedb::Struct(x)
{
  userCopy(x);
}

SysUserAccess& SysUserAccess::operator=(const SysUserAccess& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

SysUserAccess::SysUserAccess(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("system_user_access") : SysUserAccess_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

SysUserAccess::SysUserAccess(const SysUserAccess *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("system_user_access") : SysUserAccess_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status SysUserAccess::user(UserEntry*_user)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ouser = _user;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_ouser, 1, 0);
  return status;
}

const UserEntry*SysUserAccess::user(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (UserEntry *)__o;
     }
     __go = (UserEntry *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (UserEntry*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (UserEntry *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (UserEntry*)__o;
}

UserEntry*SysUserAccess::user(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (UserEntry *)__o;
     }
     __go = (UserEntry *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (UserEntry*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (UserEntry *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (UserEntry*)__o;
}

eyedb::Status SysUserAccess::user_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid SysUserAccess::user_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status SysUserAccess::mode(SysAccessMode _mode, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _mode;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

SysAccessMode SysUserAccess::mode(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (SysAccessMode)0;}
  return (SysAccessMode)__tmp;
}

static const eyedb::Attribute **DBEntry_agritems;
static eyedb::Size DBEntry_idr_objsz, DBEntry_idr_psize;

static eyedb::StructClass *DBEntry_make(eyedb::StructClass *DBEntry_class = 0, eyedb::Schema *m = 0)
{
  if (!DBEntry_class)
    return new eyedb::StructClass("database_entry", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[9];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "dbname", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "dbid", eyedb::False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[4] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "dbfile", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("database_access_mode") : DBAccessMode_Class), "default_access", eyedb::False, 0, dims);

  dims = 0;
  attr[6] = new eyedb::Attribute((m ? m->getClass("object") : eyedb::Object_Class), "schm", eyedb::True, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[7] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "comment", eyedb::False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[8] = new eyedb::Attribute((m ? m->getClass("database_property") : DBProperty_Class), "props", eyedb::True, 1, dims);
  delete[] dims;

  DBEntry_class->setAttributes(&attr[2], 7);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];
  delete attr[6];
  delete attr[7];
  delete attr[8];


  return DBEntry_class;
}

eyedb::Object *DBEntry_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new DBEntry(cls, idr);
}

eyedb::Object *DBEntry_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new DBEntry((const eyedb::Struct *)o, share);
}

static void DBEntry_init_p()
{
  DBEntry_Class = DBEntry_make();
  constructors_x[class_ind] = DBEntry_construct_x;
  constructors[class_ind] = DBEntry_construct;
  hash->insert("database_entry", class_ind++);
}

static void DBEntry_init()
{
  DBEntry_make(DBEntry_Class);

  DBEntry_agritems = DBEntry_Class->getAttributes();
  DBEntry_idr_objsz = DBEntry_Class->getIDRObjectSize(&DBEntry_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(DBEntry_Class, eyedb::True);
}

static eyedb::Status DBEntry_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  comp = new eyedb::UniqueConstraint(db, cls, "database_entry.dbname", eyedb::True);
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "database_entry.dbname", eyedb::True, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::BTreeIndex(db, cls, "database_entry.dbid", eyedb::True, eyedb::False, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

DBEntry::DBEntry(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

DBEntry::DBEntry(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void DBEntry::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("database_entry") : DBEntry_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

DBEntry::DBEntry(const DBEntry& x) : eyedb::Struct(x)
{
  userCopy(x);
}

DBEntry& DBEntry::operator=(const DBEntry& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

DBEntry::DBEntry(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_entry") : DBEntry_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

DBEntry::DBEntry(const DBEntry *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_entry") : DBEntry_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status DBEntry::dbname(const std::string &_dbname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _dbname.size() + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)_dbname.c_str(), len, 0);
  return status;

}

eyedb::Status DBEntry::dbname(unsigned int a0, char _dbname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_dbname, 1, from);
  return status;
}

std::string DBEntry::dbname(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char DBEntry::dbname(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status DBEntry::dbid(eyedblib::int32 _dbid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_dbid, 1, 0);
  return status;
}

eyedblib::int32 DBEntry::dbid(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status DBEntry::dbfile(const std::string &_dbfile)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _dbfile.size() + 1;

  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[4]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)_dbfile.c_str(), len, 0);
  return status;

}

eyedb::Status DBEntry::dbfile(unsigned int a0, char _dbfile)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[4]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_dbfile, 1, from);
  return status;
}

std::string DBEntry::dbfile(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char DBEntry::dbfile(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status DBEntry::default_access(DBAccessMode _default_access, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _default_access;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

DBAccessMode DBEntry::default_access(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (DBAccessMode)0;}
  return (DBAccessMode)__tmp;
}

eyedb::Status DBEntry::schm(eyedb::Object*_schm)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_oschm = _schm;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_oschm, 1, 0);
  return status;
}

const eyedb::Object*DBEntry::schm(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Object *)__o;
     }
     __go = (eyedb::Object *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[6]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Object*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[6]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Object *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[6]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Object*)__o;
}

eyedb::Object*DBEntry::schm(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Object *)__o;
     }
     __go = (eyedb::Object *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[6]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Object*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[6]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Object *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[6]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Object*)__o;
}

eyedb::Status DBEntry::schm_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[6]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid DBEntry::schm_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status DBEntry::comment(const std::string &_comment)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _comment.size() + 1;

  status = getClass()->getAttributes()[7]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[7]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[7]->setValue(this, (eyedb::Data)_comment.c_str(), len, 0);
  return status;

}

eyedb::Status DBEntry::comment(unsigned int a0, char _comment)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[7]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[7]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[7]->setValue(this, (eyedb::Data)&_comment, 1, from);
  return status;
}

std::string DBEntry::comment(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char DBEntry::comment(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[7]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status DBEntry::props(unsigned int a0, DBProperty*_props)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[8]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[8]->setSize(this, from+1);
  if (status)
    return status;

  eyedb::Object *_oprops = _props;

  status = getClass()->getAttributes()[8]->setValue(this, (eyedb::Data)&_oprops, 1, from);
  return status;
}

eyedb::Status DBEntry::props_cnt(unsigned int a0)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;
  status = getClass()->getAttributes()[8]->setSize(this, from);
  return status;
}

const DBProperty*DBEntry::props(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[8]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (DBProperty *)__o;
     }
     __go = (DBProperty *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[8]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (DBProperty*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[8]->getOid(this, &toid, 1, from);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (DBProperty *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[8]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, from);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (DBProperty*)__o;
}

DBProperty*DBEntry::props(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[8]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (DBProperty *)__o;
     }
     __go = (DBProperty *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[8]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (DBProperty*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[8]->getOid(this, &toid, 1, from);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (DBProperty *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[8]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, from);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (DBProperty*)__o;
}

unsigned int DBEntry::props_cnt(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Size size;
  eyedb::Status s;
  s = getClass()->getAttributes()[8]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

eyedb::Status DBEntry::props_oid(unsigned int a0, const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[8]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[8]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[8]->setOid(this, &_oid, 1, from, oid_check);
  return status;
}

eyedb::Oid DBEntry::props_oid(unsigned int a0, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[8]->getOid(this, &__tmp, 1, from);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const eyedb::Attribute **DBPropertyValue_agritems;
static eyedb::Size DBPropertyValue_idr_objsz, DBPropertyValue_idr_psize;

static eyedb::StructClass *DBPropertyValue_make(eyedb::StructClass *DBPropertyValue_class = 0, eyedb::Schema *m = 0)
{
  if (!DBPropertyValue_class)
    return new eyedb::StructClass("database_property_value", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[6];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("long") : eyedb::Int64_Class), "ival", eyedb::False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "sval", eyedb::False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[4] = new eyedb::Attribute((m ? m->getClass("byte") : eyedb::Byte_Class), "bval", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("object") : eyedb::Object_Class), "oval", eyedb::True, 0, dims);

  DBPropertyValue_class->setAttributes(&attr[2], 4);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];


  return DBPropertyValue_class;
}

eyedb::Object *DBPropertyValue_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new DBPropertyValue(cls, idr);
}

eyedb::Object *DBPropertyValue_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new DBPropertyValue((const eyedb::Struct *)o, share);
}

static void DBPropertyValue_init_p()
{
  DBPropertyValue_Class = DBPropertyValue_make();
  constructors_x[class_ind] = DBPropertyValue_construct_x;
  constructors[class_ind] = DBPropertyValue_construct;
  hash->insert("database_property_value", class_ind++);
}

static void DBPropertyValue_init()
{
  DBPropertyValue_make(DBPropertyValue_Class);

  DBPropertyValue_agritems = DBPropertyValue_Class->getAttributes();
  DBPropertyValue_idr_objsz = DBPropertyValue_Class->getIDRObjectSize(&DBPropertyValue_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(DBPropertyValue_Class, eyedb::True);
}

static eyedb::Status DBPropertyValue_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

DBPropertyValue::DBPropertyValue(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

DBPropertyValue::DBPropertyValue(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void DBPropertyValue::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("database_property_value") : DBPropertyValue_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

DBPropertyValue::DBPropertyValue(const DBPropertyValue& x) : eyedb::Struct(x)
{
  userCopy(x);
}

DBPropertyValue& DBPropertyValue::operator=(const DBPropertyValue& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

DBPropertyValue::DBPropertyValue(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_property_value") : DBPropertyValue_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

DBPropertyValue::DBPropertyValue(const DBPropertyValue *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_property_value") : DBPropertyValue_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status DBPropertyValue::ival(eyedblib::int64 _ival)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_ival, 1, 0);
  return status;
}

eyedblib::int64 DBPropertyValue::ival(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int64 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status DBPropertyValue::sval(const std::string &_sval)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _sval.size() + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)_sval.c_str(), len, 0);
  return status;

}

eyedb::Status DBPropertyValue::sval(unsigned int a0, char _sval)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_sval, 1, from);
  return status;
}

std::string DBPropertyValue::sval(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char DBPropertyValue::sval(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status DBPropertyValue::bval(const unsigned char *_bval, unsigned int len)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[4]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)_bval, len, 0);
  return status;

}

eyedb::Status DBPropertyValue::bval(unsigned int a0, unsigned char _bval)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[4]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_bval, 1, from);
  return status;
}

eyedb::Status DBPropertyValue::bval_cnt(unsigned int a0)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;
  status = getClass()->getAttributes()[4]->setSize(this, from);
  return status;
}

const unsigned char *DBPropertyValue::bval(unsigned int *len, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  if (len) *len = bval_cnt();
  return (const unsigned char *)data;
}

unsigned char DBPropertyValue::bval(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  unsigned char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

unsigned int DBPropertyValue::bval_cnt(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Size size;
  eyedb::Status s;
  s = getClass()->getAttributes()[4]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

eyedb::Status DBPropertyValue::oval(eyedb::Object*_oval)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ooval = _oval;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_ooval, 1, 0);
  return status;
}

const eyedb::Object*DBPropertyValue::oval(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Object *)__o;
     }
     __go = (eyedb::Object *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Object*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[5]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Object *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[5]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Object*)__o;
}

eyedb::Object*DBPropertyValue::oval(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Object *)__o;
     }
     __go = (eyedb::Object *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Object*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[5]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Object *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[5]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Object*)__o;
}

eyedb::Status DBPropertyValue::oval_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[5]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid DBPropertyValue::oval_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const eyedb::Attribute **DBProperty_agritems;
static eyedb::Size DBProperty_idr_objsz, DBProperty_idr_psize;

static eyedb::StructClass *DBProperty_make(eyedb::StructClass *DBProperty_class = 0, eyedb::Schema *m = 0)
{
  if (!DBProperty_class)
    return new eyedb::StructClass("database_property", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "key", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("database_property_value") : DBPropertyValue_Class), "value", eyedb::False, 0, dims);

  DBProperty_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return DBProperty_class;
}

eyedb::Object *DBProperty_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new DBProperty(cls, idr);
}

eyedb::Object *DBProperty_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new DBProperty((const eyedb::Struct *)o, share);
}

static void DBProperty_init_p()
{
  DBProperty_Class = DBProperty_make();
  constructors_x[class_ind] = DBProperty_construct_x;
  constructors[class_ind] = DBProperty_construct;
  hash->insert("database_property", class_ind++);
}

static void DBProperty_init()
{
  DBProperty_make(DBProperty_Class);

  DBProperty_agritems = DBProperty_Class->getAttributes();
  DBProperty_idr_objsz = DBProperty_Class->getIDRObjectSize(&DBProperty_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(DBProperty_Class, eyedb::True);
}

static eyedb::Status DBProperty_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "database_property.key", eyedb::True, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

DBProperty::DBProperty(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

DBProperty::DBProperty(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void DBProperty::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("database_property") : DBProperty_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

DBProperty::DBProperty(const DBProperty& x) : eyedb::Struct(x)
{
  userCopy(x);
}

DBProperty& DBProperty::operator=(const DBProperty& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

DBProperty::DBProperty(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_property") : DBProperty_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

DBProperty::DBProperty(const DBProperty *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_property") : DBProperty_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status DBProperty::key(const std::string &_key)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _key.size() + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)_key.c_str(), len, 0);
  return status;

}

eyedb::Status DBProperty::key(unsigned int a0, char _key)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_key, 1, from);
  return status;
}

std::string DBProperty::key(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char DBProperty::key(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status DBProperty::value(DBPropertyValue*_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ovalue = _value;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_ovalue, 1, 0);
  return status;
}

const DBPropertyValue*DBProperty::value(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (DBPropertyValue *)__o;
     }
     __go = (DBPropertyValue *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (DBPropertyValue*)__o;
}

DBPropertyValue*DBProperty::value(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (DBPropertyValue *)__o;
     }
     __go = (DBPropertyValue *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (DBPropertyValue*)__o;
}

static const char not_exit_msg[] = "class does not exist";
static const char differ_msg[] = "class differs in database and in runtime environment";

void DBMInit(void)
{
  if (hash) return;

  hash = new eyedb::GenHashTable(0, 113);

  SysAccessMode_init_p();
  DBAccessMode_init_p();
  UserType_init_p();
  UserEntry_init_p();
  DBUserAccess_init_p();
  SysUserAccess_init_p();
  DBEntry_init_p();
  DBPropertyValue_init_p();
  DBProperty_init_p();
  SysAccessMode_init();
  DBAccessMode_init();
  UserType_init();
  UserEntry_init();
  DBUserAccess_init();
  SysUserAccess_init();
  DBEntry_init();
  DBPropertyValue_init();
  DBProperty_init();
}

void DBMRelease(void)
{
  if (!hash) return;

  delete hash;
  hash = 0;

  SysAccessMode_Class->release();
  DBAccessMode_Class->release();
  UserType_Class->release();
  UserEntry_Class->release();
  DBUserAccess_Class->release();
  SysUserAccess_Class->release();
  DBEntry_Class->release();
  DBPropertyValue_Class->release();
  DBProperty_Class->release();
}

static eyedb::Status
DBMSchemaUpdate(eyedb::Schema *m, eyedb::Database *db)
{
  m->setName("eyedbdbm");
  eyedb::Status status;
  eyedb::EnumClass *SysAccessMode_class = SysAccessMode_make(0, m);
  if (!m->getClass("system_access_mode"))
    {
      status = m->addClass(SysAccessMode_class);
      if (status)
        return status;
    }
  eyedb::EnumClass *DBAccessMode_class = DBAccessMode_make(0, m);
  if (!m->getClass("database_access_mode"))
    {
      status = m->addClass(DBAccessMode_class);
      if (status)
        return status;
    }
  eyedb::EnumClass *UserType_class = UserType_make(0, m);
  if (!m->getClass("user_type"))
    {
      status = m->addClass(UserType_class);
      if (status)
        return status;
    }
  eyedb::StructClass *UserEntry_class = UserEntry_make(0, m);
  if (!m->getClass("user_entry"))
    {
      status = m->addClass(UserEntry_class);
      if (status)
        return status;
    }
  eyedb::StructClass *DBUserAccess_class = DBUserAccess_make(0, m);
  if (!m->getClass("database_user_access"))
    {
      status = m->addClass(DBUserAccess_class);
      if (status)
        return status;
    }
  eyedb::StructClass *SysUserAccess_class = SysUserAccess_make(0, m);
  if (!m->getClass("system_user_access"))
    {
      status = m->addClass(SysUserAccess_class);
      if (status)
        return status;
    }
  eyedb::StructClass *DBEntry_class = DBEntry_make(0, m);
  if (!m->getClass("database_entry"))
    {
      status = m->addClass(DBEntry_class);
      if (status)
        return status;
    }
  eyedb::StructClass *DBPropertyValue_class = DBPropertyValue_make(0, m);
  if (!m->getClass("database_property_value"))
    {
      status = m->addClass(DBPropertyValue_class);
      if (status)
        return status;
    }
  eyedb::StructClass *DBProperty_class = DBProperty_make(0, m);
  if (!m->getClass("database_property"))
    {
      status = m->addClass(DBProperty_class);
      if (status)
        return status;
    }

  SysAccessMode_make(SysAccessMode_class, m);
  DBAccessMode_make(DBAccessMode_class, m);
  UserType_make(UserType_class, m);
  UserEntry_make(UserEntry_class, m);
  DBUserAccess_make(DBUserAccess_class, m);
  SysUserAccess_make(SysUserAccess_class, m);
  DBEntry_make(DBEntry_class, m);
  DBPropertyValue_make(DBPropertyValue_class, m);
  DBProperty_make(DBProperty_class, m);

  if (!db) return eyedb::Success;

  if (!SysAccessMode_class->compare(m->getClass("system_access_mode")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'SysAccessMode' %s", differ_msg);
  if (!DBAccessMode_class->compare(m->getClass("database_access_mode")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'DBAccessMode' %s", differ_msg);
  if (!UserType_class->compare(m->getClass("user_type")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'UserType' %s", differ_msg);
  if (!UserEntry_class->compare(m->getClass("user_entry")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'UserEntry' %s", differ_msg);
  if (!DBUserAccess_class->compare(m->getClass("database_user_access")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'DBUserAccess' %s", differ_msg);
  if (!SysUserAccess_class->compare(m->getClass("system_user_access")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'SysUserAccess' %s", differ_msg);
  if (!DBEntry_class->compare(m->getClass("database_entry")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'DBEntry' %s", differ_msg);
  if (!DBPropertyValue_class->compare(m->getClass("database_property_value")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'DBPropertyValue' %s", differ_msg);
  if (!DBProperty_class->compare(m->getClass("database_property")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'DBProperty' %s", differ_msg);

  db->transactionBegin();

  if ((status = UserEntry_attrcomp_realize(db, m->getClass("user_entry")))) return status;

  if ((status = DBUserAccess_attrcomp_realize(db, m->getClass("database_user_access")))) return status;

  if ((status = SysUserAccess_attrcomp_realize(db, m->getClass("system_user_access")))) return status;

  if ((status = DBEntry_attrcomp_realize(db, m->getClass("database_entry")))) return status;

  if ((status = DBPropertyValue_attrcomp_realize(db, m->getClass("database_property_value")))) return status;

  if ((status = DBProperty_attrcomp_realize(db, m->getClass("database_property")))) return status;
  status = m->realize();
  if (status) return status;
  db->transactionCommit();
  return eyedb::Success;
}

eyedb::Status DBMSchemaUpdate(eyedb::Database *db)
{
  return DBMSchemaUpdate(db->getSchema(), db);
}

eyedb::Status DBMSchemaUpdate(eyedb::Schema *m)
{
  return DBMSchemaUpdate(m, NULL);
}

eyedb::Object *DBMMakeObject(eyedb::Object *o, eyedb::Bool remove)
{
  if (!o->getClass()) return (eyedb::Object *)0;
  if (eyedb::ObjectPeer::isGRTObject(o))
    return o;
  int ind = hash->get(o->getClass()->getName());
  if (ind < 0 && (!o->getClass()->getStrictAliasName() || (ind = hash->get(o->getClass()->getStrictAliasName())) < 0)) return 0;
  eyedb::Object *co = constructors[ind](o, (remove ? eyedb::True : eyedb::False));
  eyedb::ObjectPeer::setClass(co, o->getClass());
  if (remove) o->release();
  if (co->getDatabase())
    co->getDatabase()->cacheObject(co);
  return co;
}

DBMDatabase::DBMDatabase(eyedb::Connection *conn, const char *dbname, eyedb::Database::OpenFlag flag, const char *userauth, const char *passwdauth) : eyedb::Database(dbname)
{
  eyedb::Status status = open(conn, flag, 0, userauth, passwdauth);
  if (status) throw *status;
}

DBMDatabase::DBMDatabase(eyedb::Connection *conn, const char *dbname, const char *dbmdb_str, eyedb::Database::OpenFlag flag, const char *userauth, const char *passwdauth) : eyedb::Database(dbname, dbmdb_str)
{
  eyedb::Status status = open(conn, flag, 0, userauth, passwdauth);
  if (status) throw *status;
}

eyedb::Status DBMDatabase::open(eyedb::Connection *conn, eyedb::Database::OpenFlag flag, const char *userauth, const char *passwdauth)
{
  return open(conn, flag, 0, userauth, passwdauth);
}

eyedb::Status DBMDatabase::open(eyedb::Connection *conn, eyedb::Database::OpenFlag flag, const eyedb::OpenHints *hints, const char *userauth, const char *passwdauth)
{
  eyedb::Status status = eyedb::Database::open(conn, flag, hints, userauth, passwdauth);
  if (status) return status;
  transactionBegin();
  status = DBMDatabase::checkSchema(getSchema());
  transactionCommit();

  if (!status) add(hash, constructors_x);

  return status;
}

void DBMDatabase::setConsApp(eyedb::Database *_db)
{
  _db->add(hash, constructors_x);
}

static void append(char *&s, const char *m1, const char *m2)
{
  if (!s) {s = (char *)malloc(strlen(m1)+strlen(m2)+2); *s = 0;}
  else s = (char *)realloc(s, strlen(s)+strlen(m1)+strlen(m2)+2);
  strcat(s, m1);
  strcat(s, m2);
  strcat(s, "\n");
}

eyedb::Bool DBMDatabase::getDynamicGetErrorPolicy() {
   throw *eyedb::Exception::make(eyedb::IDB_ERROR, "getDynamicGetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

eyedb::Bool DBMDatabase::getDynamicSetErrorPolicy() {
   throw *eyedb::Exception::make(eyedb::IDB_ERROR, "getDynamicSetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

void DBMDatabase::setDynamicGetErrorPolicy(eyedb::Bool policy) {
   throw *eyedb::Exception::make(eyedb::IDB_ERROR, "setDynamicGetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

void DBMDatabase::setDynamicSetErrorPolicy(eyedb::Bool policy) {
   throw *eyedb::Exception::make(eyedb::IDB_ERROR, "setDynamicSetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

eyedb::Status DBMDatabase::checkSchema(eyedb::Schema *m)
{
  eyedb::Class *cl;
  char *s = 0;

  if (!(cl = m->getClass("system_access_mode")))
    append(s, "'system_access_mode' ", not_exit_msg);
  else if (!SysAccessMode_Class->compare(cl))
    append(s, "'SysAccessMode' ", differ_msg);
  if (!(cl = m->getClass("database_access_mode")))
    append(s, "'database_access_mode' ", not_exit_msg);
  else if (!DBAccessMode_Class->compare(cl))
    append(s, "'DBAccessMode' ", differ_msg);
  if (!(cl = m->getClass("user_type")))
    append(s, "'user_type' ", not_exit_msg);
  else if (!UserType_Class->compare(cl))
    append(s, "'UserType' ", differ_msg);
  if (!(cl = m->getClass("user_entry")))
    append(s, "'user_entry' ", not_exit_msg);
  else if (!UserEntry_Class->compare(cl))
    append(s, "'UserEntry' ", differ_msg);
  if (!(cl = m->getClass("database_user_access")))
    append(s, "'database_user_access' ", not_exit_msg);
  else if (!DBUserAccess_Class->compare(cl))
    append(s, "'DBUserAccess' ", differ_msg);
  if (!(cl = m->getClass("system_user_access")))
    append(s, "'system_user_access' ", not_exit_msg);
  else if (!SysUserAccess_Class->compare(cl))
    append(s, "'SysUserAccess' ", differ_msg);
  if (!(cl = m->getClass("database_entry")))
    append(s, "'database_entry' ", not_exit_msg);
  else if (!DBEntry_Class->compare(cl))
    append(s, "'DBEntry' ", differ_msg);
  if (!(cl = m->getClass("database_property_value")))
    append(s, "'database_property_value' ", not_exit_msg);
  else if (!DBPropertyValue_Class->compare(cl))
    append(s, "'DBPropertyValue' ", differ_msg);
  if (!(cl = m->getClass("database_property")))
    append(s, "'database_property' ", not_exit_msg);
  else if (!DBProperty_Class->compare(cl))
    append(s, "'DBProperty' ", differ_msg);
  if (s) {eyedb::Status status = eyedb::Exception::make(s); free(s); return status;}
  return eyedb::Success;
}

eyedb::Bool DBM_set_oid_check(eyedb::Bool _oid_check)
{
  eyedb::Bool old = oid_check;
  oid_check = _oid_check;
  return old;
}

eyedb::Bool DBM_get_oid_check()
{
  return oid_check;
}

}
