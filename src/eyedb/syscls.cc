
/*
 * EyeDB Version 2.8.8 Copyright (c) 1995-2006 SYSRA
 *
 * File 'syscls.cc'
 *
 * Package Name 'syscls'
 *
 * Generated by eyedbodl at Thu Sep 10 15:17:01 2009
 *
 * ---------------------------------------------------
 * -------------- DO NOT EDIT THIS CODE --------------
 * ---------------------------------------------------
 *
 */

#include <eyedb/eyedb.h>

#include <eyedb/internals/ObjectPeer.h>
#include <eyedb/internals/ClassPeer.h>
#include <eyedb/internals/kern_const.h>

#include <eyedb/syscls.h>

#define min(x,y)((x)<(y)?(x):(y))

namespace eyedb {

static eyedb::Bool dynget_error_policy = eyedb::False;
static eyedb::Bool dynset_error_policy = eyedb::True;
static eyedb::Oid nulloid;
static unsigned char nulldata[1];
static eyedb::Bool oid_check = eyedb::True;
static int class_ind;
static eyedb::Database::consapp_t *constructors_x = new eyedb::Database::consapp_t[105];
static eyedb::Object *(*constructors[105])(const eyedb::Object *, eyedb::Bool);
static eyedb::GenHashTable *hash;
#define make_object sysclsMakeObject
extern void sysclsInit(void);
extern void sysclsRelease(void);
extern eyedb::Status sysclsSchemaUpdate(eyedb::Database *);
extern eyedb::Status sysclsSchemaUpdate(eyedb::Schema *);

static eyedb::Class *index_Class = new eyedb::Class("index");

void syscls::init()
{
  sysclsInit();
}

void syscls::release()
{
  sysclsRelease();
}

eyedb::Status syscls::updateSchema(eyedb::Database *db)
{
  return sysclsSchemaUpdate(db);
}

eyedb::Status syscls::updateSchema(eyedb::Schema *m)
{
  return sysclsSchemaUpdate(m);
}

eyedb::EnumClass *IndexType_Class;
eyedb::EnumClass *ExecutableLang_Class;
eyedb::EnumClass *ArgType_Type_Class;
eyedb::EnumClass *ExecutableLocalisation_Class;
eyedb::EnumClass *ExecutableType_Class;
eyedb::EnumClass *TriggerType_Class;
eyedb::EnumClass *ProtectionMode_Class;
eyedb::EnumClass *ClassUpdateType_Class;
eyedb::EnumClass *AttributeConvertType_Class;
eyedb::StructClass *AttributeComponent_Class;
eyedb::StructClass *AttributeComponentSet_Class;
eyedb::StructClass *ClassComponent_Class;
eyedb::StructClass *AgregatClassComponent_Class;
eyedb::StructClass *ClassVariable_Class;
eyedb::StructClass *Index_Class;
eyedb::StructClass *HashIndex_Class;
eyedb::StructClass *BTreeIndex_Class;
eyedb::StructClass *CollAttrImpl_Class;
eyedb::StructClass *ArgType_Class;
eyedb::StructClass *Signature_Class;
eyedb::StructClass *Executable_Class;
eyedb::StructClass *AgregatClassExecutable_Class;
eyedb::StructClass *Method_Class;
eyedb::StructClass *FEMethod_Class;
eyedb::StructClass *FEMethod_C_Class;
eyedb::StructClass *BEMethod_Class;
eyedb::StructClass *BEMethod_C_Class;
eyedb::StructClass *BEMethod_OQL_Class;
eyedb::StructClass *Trigger_Class;
eyedb::StructClass *UniqueConstraint_Class;
eyedb::StructClass *NotNullConstraint_Class;
eyedb::StructClass *CardinalityDescription_Class;
eyedb::StructClass *CardinalityConstraint_Class;
eyedb::StructClass *CardinalityConstraint_Test_Class;
eyedb::StructClass *ProtectionUser_Class;
eyedb::StructClass *Protection_Class;
eyedb::StructClass *UnreadableObject_Class;
eyedb::StructClass *ClassConversion_Class;
static eyedb::CollSetClass *set_class_AttributeComponent_ref_Class;

static eyedb::Size IndexType_idr_objsz, IndexType_idr_psize;

static eyedb::EnumClass *IndexType_make(eyedb::EnumClass *IndexType_class = 0, eyedb::Schema *m = 0)
{
  if (!IndexType_class)
    return new eyedb::EnumClass("index_type");
  eyedb::EnumItem *en[2];
  en[0] = new eyedb::EnumItem("HASH_INDEX_TYPE", "HashIndexType", (unsigned int)32);
  en[1] = new eyedb::EnumItem("BTREE_INDEX_TYPE", "BTreeIndexType", (unsigned int)64);

  IndexType_class->setEnumItems(en, 2);

  delete en[0];
  delete en[1];

  eyedb::ClassPeer::setMType(IndexType_class, eyedb::Class::System);

  return IndexType_class;
}

static void IndexType_init_p()
{
  IndexType_Class = IndexType_make();
}

static void IndexType_init()
{
  IndexType_make(IndexType_Class);

  IndexType_idr_objsz = IndexType_Class->getIDRObjectSize(&IndexType_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(IndexType_Class, eyedb::True);
}

static eyedb::Size ExecutableLang_idr_objsz, ExecutableLang_idr_psize;

static eyedb::EnumClass *ExecutableLang_make(eyedb::EnumClass *ExecutableLang_class = 0, eyedb::Schema *m = 0)
{
  if (!ExecutableLang_class)
    return new eyedb::EnumClass("executable_lang");
  eyedb::EnumItem *en[3];
  en[0] = new eyedb::EnumItem("C_LANG", "C_LANG", (unsigned int)1);
  en[1] = new eyedb::EnumItem("OQL_LANG", "OQL_LANG", (unsigned int)2);
  en[2] = new eyedb::EnumItem("SYSTEM_EXEC", "SYSTEM_EXEC", (unsigned int)256);

  ExecutableLang_class->setEnumItems(en, 3);

  delete en[0];
  delete en[1];
  delete en[2];

  eyedb::ClassPeer::setMType(ExecutableLang_class, eyedb::Class::System);

  return ExecutableLang_class;
}

static void ExecutableLang_init_p()
{
  ExecutableLang_Class = ExecutableLang_make();
}

static void ExecutableLang_init()
{
  ExecutableLang_make(ExecutableLang_Class);

  ExecutableLang_idr_objsz = ExecutableLang_Class->getIDRObjectSize(&ExecutableLang_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ExecutableLang_Class, eyedb::True);
}

static eyedb::Size ArgType_Type_idr_objsz, ArgType_Type_idr_psize;

static eyedb::EnumClass *ArgType_Type_make(eyedb::EnumClass *ArgType_Type_class = 0, eyedb::Schema *m = 0)
{
  if (!ArgType_Type_class)
    return new eyedb::EnumClass("argtype_type");
  eyedb::EnumItem *en[16];
  en[0] = new eyedb::EnumItem("ANY_TYPE", "ANY_TYPE", (unsigned int)0);
  en[1] = new eyedb::EnumItem("VOID_TYPE", "VOID_TYPE", (unsigned int)1);
  en[2] = new eyedb::EnumItem("INT16_TYPE", "INT16_TYPE", (unsigned int)2);
  en[3] = new eyedb::EnumItem("INT32_TYPE", "INT32_TYPE", (unsigned int)3);
  en[4] = new eyedb::EnumItem("INT64_TYPE", "INT64_TYPE", (unsigned int)4);
  en[5] = new eyedb::EnumItem("STRING_TYPE", "STRING_TYPE", (unsigned int)5);
  en[6] = new eyedb::EnumItem("CHAR_TYPE", "CHAR_TYPE", (unsigned int)6);
  en[7] = new eyedb::EnumItem("FLOAT_TYPE", "FLOAT_TYPE", (unsigned int)7);
  en[8] = new eyedb::EnumItem("OID_TYPE", "OID_TYPE", (unsigned int)8);
  en[9] = new eyedb::EnumItem("OBJ_TYPE", "OBJ_TYPE", (unsigned int)9);
  en[10] = new eyedb::EnumItem("RAW_TYPE", "RAW_TYPE", (unsigned int)10);
  en[11] = new eyedb::EnumItem("BYTE_TYPE", "BYTE_TYPE", (unsigned int)11);
  en[12] = new eyedb::EnumItem("ARRAY_TYPE", "ARRAY_TYPE", (unsigned int)256);
  en[13] = new eyedb::EnumItem("IN_ARG_TYPE", "IN_ARG_TYPE", (unsigned int)4096);
  en[14] = new eyedb::EnumItem("OUT_ARG_TYPE", "OUT_ARG_TYPE", (unsigned int)8192);
  en[15] = new eyedb::EnumItem("INOUT_ARG_TYPE", "INOUT_ARG_TYPE", (unsigned int)12288);

  ArgType_Type_class->setEnumItems(en, 16);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];
  delete en[4];
  delete en[5];
  delete en[6];
  delete en[7];
  delete en[8];
  delete en[9];
  delete en[10];
  delete en[11];
  delete en[12];
  delete en[13];
  delete en[14];
  delete en[15];

  eyedb::ClassPeer::setMType(ArgType_Type_class, eyedb::Class::System);

  return ArgType_Type_class;
}

static void ArgType_Type_init_p()
{
  ArgType_Type_Class = ArgType_Type_make();
}

static void ArgType_Type_init()
{
  ArgType_Type_make(ArgType_Type_Class);

  ArgType_Type_idr_objsz = ArgType_Type_Class->getIDRObjectSize(&ArgType_Type_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ArgType_Type_Class, eyedb::True);
}

static eyedb::Size ExecutableLocalisation_idr_objsz, ExecutableLocalisation_idr_psize;

static eyedb::EnumClass *ExecutableLocalisation_make(eyedb::EnumClass *ExecutableLocalisation_class = 0, eyedb::Schema *m = 0)
{
  if (!ExecutableLocalisation_class)
    return new eyedb::EnumClass("executable_localisation");
  eyedb::EnumItem *en[3];
  en[0] = new eyedb::EnumItem("BACKEND", "BACKEND", (unsigned int)1);
  en[1] = new eyedb::EnumItem("FRONTEND", "FRONTEND", (unsigned int)2);
  en[2] = new eyedb::EnumItem("STATIC_EXEC", "STATIC_EXEC", (unsigned int)256);

  ExecutableLocalisation_class->setEnumItems(en, 3);

  delete en[0];
  delete en[1];
  delete en[2];

  eyedb::ClassPeer::setMType(ExecutableLocalisation_class, eyedb::Class::System);

  return ExecutableLocalisation_class;
}

static void ExecutableLocalisation_init_p()
{
  ExecutableLocalisation_Class = ExecutableLocalisation_make();
}

static void ExecutableLocalisation_init()
{
  ExecutableLocalisation_make(ExecutableLocalisation_Class);

  ExecutableLocalisation_idr_objsz = ExecutableLocalisation_Class->getIDRObjectSize(&ExecutableLocalisation_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ExecutableLocalisation_Class, eyedb::True);
}

static eyedb::Size ExecutableType_idr_objsz, ExecutableType_idr_psize;

static eyedb::EnumClass *ExecutableType_make(eyedb::EnumClass *ExecutableType_class = 0, eyedb::Schema *m = 0)
{
  if (!ExecutableType_class)
    return new eyedb::EnumClass("executable_type");
  eyedb::EnumItem *en[4];
  en[0] = new eyedb::EnumItem("METHOD_C_TYPE", "METHOD_C_TYPE", (unsigned int)2);
  en[1] = new eyedb::EnumItem("METHOD_OQL_TYPE", "METHOD_OQL_TYPE", (unsigned int)18);
  en[2] = new eyedb::EnumItem("TRIGGER_C_TYPE", "TRIGGER_C_TYPE", (unsigned int)8);
  en[3] = new eyedb::EnumItem("TRIGGER_OQL_TYPE", "TRIGGER_OQL_TYPE", (unsigned int)24);

  ExecutableType_class->setEnumItems(en, 4);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];

  eyedb::ClassPeer::setMType(ExecutableType_class, eyedb::Class::System);

  return ExecutableType_class;
}

static void ExecutableType_init_p()
{
  ExecutableType_Class = ExecutableType_make();
}

static void ExecutableType_init()
{
  ExecutableType_make(ExecutableType_Class);

  ExecutableType_idr_objsz = ExecutableType_Class->getIDRObjectSize(&ExecutableType_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ExecutableType_Class, eyedb::True);
}

static eyedb::Size TriggerType_idr_objsz, TriggerType_idr_psize;

static eyedb::EnumClass *TriggerType_make(eyedb::EnumClass *TriggerType_class = 0, eyedb::Schema *m = 0)
{
  if (!TriggerType_class)
    return new eyedb::EnumClass("trigger_type");
  eyedb::EnumItem *en[8];
  en[0] = new eyedb::EnumItem("TRIGGER_CREATE_BEFORE", "TriggerCREATE_BEFORE", (unsigned int)17);
  en[1] = new eyedb::EnumItem("TRIGGER_CREATE_AFTER", "TriggerCREATE_AFTER", (unsigned int)18);
  en[2] = new eyedb::EnumItem("TRIGGER_UPDATE_BEFORE", "TriggerUPDATE_BEFORE", (unsigned int)33);
  en[3] = new eyedb::EnumItem("TRIGGER_UPDATE_AFTER", "TriggerUPDATE_AFTER", (unsigned int)34);
  en[4] = new eyedb::EnumItem("TRIGGER_LOAD_BEFORE", "TriggerLOAD_BEFORE", (unsigned int)65);
  en[5] = new eyedb::EnumItem("TRIGGER_LOAD_AFTER", "TriggerLOAD_AFTER", (unsigned int)66);
  en[6] = new eyedb::EnumItem("TRIGGER_REMOVE_BEFORE", "TriggerREMOVE_BEFORE", (unsigned int)129);
  en[7] = new eyedb::EnumItem("TRIGGER_REMOVE_AFTER", "TriggerREMOVE_AFTER", (unsigned int)130);

  TriggerType_class->setEnumItems(en, 8);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];
  delete en[4];
  delete en[5];
  delete en[6];
  delete en[7];

  eyedb::ClassPeer::setMType(TriggerType_class, eyedb::Class::System);

  return TriggerType_class;
}

static void TriggerType_init_p()
{
  TriggerType_Class = TriggerType_make();
}

static void TriggerType_init()
{
  TriggerType_make(TriggerType_Class);

  TriggerType_idr_objsz = TriggerType_Class->getIDRObjectSize(&TriggerType_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(TriggerType_Class, eyedb::True);
}

static eyedb::Size ProtectionMode_idr_objsz, ProtectionMode_idr_psize;

static eyedb::EnumClass *ProtectionMode_make(eyedb::EnumClass *ProtectionMode_class = 0, eyedb::Schema *m = 0)
{
  if (!ProtectionMode_class)
    return new eyedb::EnumClass("protection_mode");
  eyedb::EnumItem *en[2];
  en[0] = new eyedb::EnumItem("PROT_READ", "ProtRead", (unsigned int)256);
  en[1] = new eyedb::EnumItem("PROT_RW", "ProtRW", (unsigned int)257);

  ProtectionMode_class->setEnumItems(en, 2);

  delete en[0];
  delete en[1];

  eyedb::ClassPeer::setMType(ProtectionMode_class, eyedb::Class::System);

  return ProtectionMode_class;
}

static void ProtectionMode_init_p()
{
  ProtectionMode_Class = ProtectionMode_make();
}

static void ProtectionMode_init()
{
  ProtectionMode_make(ProtectionMode_Class);

  ProtectionMode_idr_objsz = ProtectionMode_Class->getIDRObjectSize(&ProtectionMode_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ProtectionMode_Class, eyedb::True);
}

static eyedb::Size ClassUpdateType_idr_objsz, ClassUpdateType_idr_psize;

static eyedb::EnumClass *ClassUpdateType_make(eyedb::EnumClass *ClassUpdateType_class = 0, eyedb::Schema *m = 0)
{
  if (!ClassUpdateType_class)
    return new eyedb::EnumClass("class_update_type");
  eyedb::EnumItem *en[5];
  en[0] = new eyedb::EnumItem("ADD_ATTR", "ADD_ATTR", (unsigned int)0);
  en[1] = new eyedb::EnumItem("RMV_ATTR", "RMV_ATTR", (unsigned int)1);
  en[2] = new eyedb::EnumItem("CNV_ATTR", "CNV_ATTR", (unsigned int)2);
  en[3] = new eyedb::EnumItem("MIG_ATTR", "MIG_ATTR", (unsigned int)3);
  en[4] = new eyedb::EnumItem("RMV_CLASS", "RMV_CLASS", (unsigned int)4);

  ClassUpdateType_class->setEnumItems(en, 5);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];
  delete en[4];

  eyedb::ClassPeer::setMType(ClassUpdateType_class, eyedb::Class::System);

  return ClassUpdateType_class;
}

static void ClassUpdateType_init_p()
{
  ClassUpdateType_Class = ClassUpdateType_make();
}

static void ClassUpdateType_init()
{
  ClassUpdateType_make(ClassUpdateType_Class);

  ClassUpdateType_idr_objsz = ClassUpdateType_Class->getIDRObjectSize(&ClassUpdateType_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ClassUpdateType_Class, eyedb::True);
}

static eyedb::Size AttributeConvertType_idr_objsz, AttributeConvertType_idr_psize;

static eyedb::EnumClass *AttributeConvertType_make(eyedb::EnumClass *AttributeConvertType_class = 0, eyedb::Schema *m = 0)
{
  if (!AttributeConvertType_class)
    return new eyedb::EnumClass("attribute_convert_type");
  eyedb::EnumItem *en[76];
  en[0] = new eyedb::EnumItem("INT16_TO_INT16", "INT16_TO_INT16", (unsigned int)0);
  en[1] = new eyedb::EnumItem("INT16_TO_INT32", "INT16_TO_INT32", (unsigned int)1);
  en[2] = new eyedb::EnumItem("INT16_TO_INT64", "INT16_TO_INT64", (unsigned int)2);
  en[3] = new eyedb::EnumItem("INT16_TO_FLOAT", "INT16_TO_FLOAT", (unsigned int)3);
  en[4] = new eyedb::EnumItem("INT16_TO_BYTE", "INT16_TO_BYTE", (unsigned int)4);
  en[5] = new eyedb::EnumItem("INT16_TO_CHAR", "INT16_TO_CHAR", (unsigned int)5);
  en[6] = new eyedb::EnumItem("INT16_TO_ENUM", "INT16_TO_ENUM", (unsigned int)6);
  en[7] = new eyedb::EnumItem("INT32_TO_INT32", "INT32_TO_INT32", (unsigned int)7);
  en[8] = new eyedb::EnumItem("INT32_TO_INT16", "INT32_TO_INT16", (unsigned int)8);
  en[9] = new eyedb::EnumItem("INT32_TO_INT64", "INT32_TO_INT64", (unsigned int)9);
  en[10] = new eyedb::EnumItem("INT32_TO_FLOAT", "INT32_TO_FLOAT", (unsigned int)10);
  en[11] = new eyedb::EnumItem("INT32_TO_BYTE", "INT32_TO_BYTE", (unsigned int)11);
  en[12] = new eyedb::EnumItem("INT32_TO_CHAR", "INT32_TO_CHAR", (unsigned int)12);
  en[13] = new eyedb::EnumItem("INT32_TO_ENUM", "INT32_TO_ENUM", (unsigned int)13);
  en[14] = new eyedb::EnumItem("INT64_TO_INT64", "INT64_TO_INT64", (unsigned int)14);
  en[15] = new eyedb::EnumItem("INT64_TO_INT16", "INT64_TO_INT16", (unsigned int)15);
  en[16] = new eyedb::EnumItem("INT64_TO_INT32", "INT64_TO_INT32", (unsigned int)16);
  en[17] = new eyedb::EnumItem("INT64_TO_FLOAT", "INT64_TO_FLOAT", (unsigned int)17);
  en[18] = new eyedb::EnumItem("INT64_TO_BYTE", "INT64_TO_BYTE", (unsigned int)18);
  en[19] = new eyedb::EnumItem("INT64_TO_CHAR", "INT64_TO_CHAR", (unsigned int)19);
  en[20] = new eyedb::EnumItem("INT64_TO_ENUM", "INT64_TO_ENUM", (unsigned int)20);
  en[21] = new eyedb::EnumItem("FLOAT_TO_FLOAT", "FLOAT_TO_FLOAT", (unsigned int)21);
  en[22] = new eyedb::EnumItem("FLOAT_TO_INT16", "FLOAT_TO_INT16", (unsigned int)22);
  en[23] = new eyedb::EnumItem("FLOAT_TO_INT32", "FLOAT_TO_INT32", (unsigned int)23);
  en[24] = new eyedb::EnumItem("FLOAT_TO_INT64", "FLOAT_TO_INT64", (unsigned int)24);
  en[25] = new eyedb::EnumItem("FLOAT_TO_BYTE", "FLOAT_TO_BYTE", (unsigned int)25);
  en[26] = new eyedb::EnumItem("FLOAT_TO_CHAR", "FLOAT_TO_CHAR", (unsigned int)26);
  en[27] = new eyedb::EnumItem("FLOAT_TO_ENUM", "FLOAT_TO_ENUM", (unsigned int)27);
  en[28] = new eyedb::EnumItem("CHAR_TO_CHAR", "CHAR_TO_CHAR", (unsigned int)28);
  en[29] = new eyedb::EnumItem("CHAR_TO_INT16", "CHAR_TO_INT16", (unsigned int)29);
  en[30] = new eyedb::EnumItem("CHAR_TO_INT32", "CHAR_TO_INT32", (unsigned int)30);
  en[31] = new eyedb::EnumItem("CHAR_TO_INT64", "CHAR_TO_INT64", (unsigned int)31);
  en[32] = new eyedb::EnumItem("CHAR_TO_FLOAT", "CHAR_TO_FLOAT", (unsigned int)32);
  en[33] = new eyedb::EnumItem("CHAR_TO_BYTE", "CHAR_TO_BYTE", (unsigned int)33);
  en[34] = new eyedb::EnumItem("CHAR_TO_ENUM", "CHAR_TO_ENUM", (unsigned int)34);
  en[35] = new eyedb::EnumItem("BYTE_TO_BYTE", "BYTE_TO_BYTE", (unsigned int)35);
  en[36] = new eyedb::EnumItem("BYTE_TO_INT16", "BYTE_TO_INT16", (unsigned int)36);
  en[37] = new eyedb::EnumItem("BYTE_TO_INT32", "BYTE_TO_INT32", (unsigned int)37);
  en[38] = new eyedb::EnumItem("BYTE_TO_INT64", "BYTE_TO_INT64", (unsigned int)38);
  en[39] = new eyedb::EnumItem("BYTE_TO_FLOAT", "BYTE_TO_FLOAT", (unsigned int)39);
  en[40] = new eyedb::EnumItem("BYTE_TO_CHAR", "BYTE_TO_CHAR", (unsigned int)40);
  en[41] = new eyedb::EnumItem("BYTE_TO_ENUM", "BYTE_TO_ENUM", (unsigned int)41);
  en[42] = new eyedb::EnumItem("ENUM_TO_ENUM", "ENUM_TO_ENUM", (unsigned int)42);
  en[43] = new eyedb::EnumItem("ENUM_TO_INT16", "ENUM_TO_INT16", (unsigned int)43);
  en[44] = new eyedb::EnumItem("ENUM_TO_INT32", "ENUM_TO_INT32", (unsigned int)44);
  en[45] = new eyedb::EnumItem("ENUM_TO_INT64", "ENUM_TO_INT64", (unsigned int)45);
  en[46] = new eyedb::EnumItem("ENUM_TO_FLOAT", "ENUM_TO_FLOAT", (unsigned int)46);
  en[47] = new eyedb::EnumItem("ENUM_TO_CHAR", "ENUM_TO_CHAR", (unsigned int)47);
  en[48] = new eyedb::EnumItem("ENUM_TO_BYTE", "ENUM_TO_BYTE", (unsigned int)48);
  en[49] = new eyedb::EnumItem("CHAR_TO_STRING", "CHAR_TO_STRING", (unsigned int)49);
  en[50] = new eyedb::EnumItem("STRING_TO_CHAR", "STRING_TO_CHAR", (unsigned int)50);
  en[51] = new eyedb::EnumItem("INT16_TO_STRING", "INT16_TO_STRING", (unsigned int)51);
  en[52] = new eyedb::EnumItem("STRING_TO_INT16", "STRING_TO_INT16", (unsigned int)52);
  en[53] = new eyedb::EnumItem("INT32_TO_STRING", "INT32_TO_STRING", (unsigned int)53);
  en[54] = new eyedb::EnumItem("STRING_TO_INT32", "STRING_TO_INT32", (unsigned int)54);
  en[55] = new eyedb::EnumItem("INT64_TO_STRING", "INT64_TO_STRING", (unsigned int)55);
  en[56] = new eyedb::EnumItem("STRING_TO_INT64", "STRING_TO_INT64", (unsigned int)56);
  en[57] = new eyedb::EnumItem("FLOAT_TO_STRING", "FLOAT_TO_STRING", (unsigned int)57);
  en[58] = new eyedb::EnumItem("STRING_TO_FLOAT", "STRING_TO_FLOAT", (unsigned int)58);
  en[59] = new eyedb::EnumItem("BYTE_TO_STRING", "BYTE_TO_STRING", (unsigned int)59);
  en[60] = new eyedb::EnumItem("STRING_TO_BYTE", "STRING_TO_BYTE", (unsigned int)60);
  en[61] = new eyedb::EnumItem("SET_TO_BAG", "SET_TO_BAG", (unsigned int)61);
  en[62] = new eyedb::EnumItem("SET_TO_ARRAY", "SET_TO_ARRAY", (unsigned int)62);
  en[63] = new eyedb::EnumItem("SET_TO_LIST", "SET_TO_LIST", (unsigned int)63);
  en[64] = new eyedb::EnumItem("BAG_TO_SET", "BAG_TO_SET", (unsigned int)64);
  en[65] = new eyedb::EnumItem("BAG_TO_ARRAY", "BAG_TO_ARRAY", (unsigned int)65);
  en[66] = new eyedb::EnumItem("BAG_TO_LIST", "BAG_TO_LIST", (unsigned int)66);
  en[67] = new eyedb::EnumItem("ARRAY_TO_BAG", "ARRAY_TO_BAG", (unsigned int)67);
  en[68] = new eyedb::EnumItem("ARRAY_TO_SET", "ARRAY_TO_SET", (unsigned int)68);
  en[69] = new eyedb::EnumItem("ARRAY_TO_LIST", "ARRAY_TO_LIST", (unsigned int)69);
  en[70] = new eyedb::EnumItem("LIST_TO_BAG", "LIST_TO_BAG", (unsigned int)70);
  en[71] = new eyedb::EnumItem("LIST_TO_ARRAY", "LIST_TO_ARRAY", (unsigned int)71);
  en[72] = new eyedb::EnumItem("LIST_TO_SET", "LIST_TO_SET", (unsigned int)72);
  en[73] = new eyedb::EnumItem("CLASS_TO_CLASS", "CLASS_TO_CLASS", (unsigned int)73);
  en[74] = new eyedb::EnumItem("USER_CNV", "USER_CNV", (unsigned int)74);
  en[75] = new eyedb::EnumItem("NIL_CNV", "NIL_CNV", (unsigned int)75);

  AttributeConvertType_class->setEnumItems(en, 76);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];
  delete en[4];
  delete en[5];
  delete en[6];
  delete en[7];
  delete en[8];
  delete en[9];
  delete en[10];
  delete en[11];
  delete en[12];
  delete en[13];
  delete en[14];
  delete en[15];
  delete en[16];
  delete en[17];
  delete en[18];
  delete en[19];
  delete en[20];
  delete en[21];
  delete en[22];
  delete en[23];
  delete en[24];
  delete en[25];
  delete en[26];
  delete en[27];
  delete en[28];
  delete en[29];
  delete en[30];
  delete en[31];
  delete en[32];
  delete en[33];
  delete en[34];
  delete en[35];
  delete en[36];
  delete en[37];
  delete en[38];
  delete en[39];
  delete en[40];
  delete en[41];
  delete en[42];
  delete en[43];
  delete en[44];
  delete en[45];
  delete en[46];
  delete en[47];
  delete en[48];
  delete en[49];
  delete en[50];
  delete en[51];
  delete en[52];
  delete en[53];
  delete en[54];
  delete en[55];
  delete en[56];
  delete en[57];
  delete en[58];
  delete en[59];
  delete en[60];
  delete en[61];
  delete en[62];
  delete en[63];
  delete en[64];
  delete en[65];
  delete en[66];
  delete en[67];
  delete en[68];
  delete en[69];
  delete en[70];
  delete en[71];
  delete en[72];
  delete en[73];
  delete en[74];
  delete en[75];

  eyedb::ClassPeer::setMType(AttributeConvertType_class, eyedb::Class::System);

  return AttributeConvertType_class;
}

static void AttributeConvertType_init_p()
{
  AttributeConvertType_Class = AttributeConvertType_make();
}

static void AttributeConvertType_init()
{
  AttributeConvertType_make(AttributeConvertType_Class);

  AttributeConvertType_idr_objsz = AttributeConvertType_Class->getIDRObjectSize(&AttributeConvertType_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(AttributeConvertType_Class, eyedb::True);
}

static const eyedb::Attribute **AttributeComponent_agritems;
static eyedb::Size AttributeComponent_idr_objsz, AttributeComponent_idr_psize;

static eyedb::StructClass *AttributeComponent_make(eyedb::StructClass *AttributeComponent_class = 0, eyedb::Schema *m = 0)
{
  if (!AttributeComponent_class)
    return new eyedb::StructClass("attribute_component", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[6];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "name", eyedb::False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "attrpath", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("class") : eyedb::Class_Class), "class_owner", eyedb::True, 0, dims);

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("bool") : eyedb::Bool_Class), "propagate", eyedb::False, 0, dims);

  AttributeComponent_class->setAttributes(&attr[2], 4);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];

  eyedb::ClassPeer::setMType(AttributeComponent_class, eyedb::Class::System);

  return AttributeComponent_class;
}

eyedb::Object *AttributeComponent_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new AttributeComponent(cls, idr);
}

eyedb::Object *AttributeComponent_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new AttributeComponent((const eyedb::Struct *)o, share);
}

static void AttributeComponent_init_p()
{
  AttributeComponent_Class = AttributeComponent_make();
  constructors_x[class_ind] = AttributeComponent_construct_x;
  constructors[class_ind] = AttributeComponent_construct;
  hash->insert("attribute_component", class_ind++);
}

static void AttributeComponent_init()
{
  AttributeComponent_make(AttributeComponent_Class);

  AttributeComponent_agritems = AttributeComponent_Class->getAttributes();
  AttributeComponent_idr_objsz = AttributeComponent_Class->getIDRObjectSize(&AttributeComponent_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(AttributeComponent_Class, eyedb::True);
}

static eyedb::Status AttributeComponent_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

AttributeComponent::AttributeComponent(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

AttributeComponent::AttributeComponent(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void AttributeComponent::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("attribute_component") : AttributeComponent_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

AttributeComponent::AttributeComponent(const AttributeComponent& x) : eyedb::Struct(x)
{
  userCopy(x);
}

AttributeComponent& AttributeComponent::operator=(const AttributeComponent& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

AttributeComponent::AttributeComponent(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("attribute_component") : AttributeComponent_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

AttributeComponent::AttributeComponent(const AttributeComponent *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("attribute_component") : AttributeComponent_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status AttributeComponent::setName(const std::string &_name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _name.size() + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)_name.c_str(), len, 0);
  return status;

}

eyedb::Status AttributeComponent::setName(unsigned int a0, char _name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_name, 1, from);
  return status;
}

std::string AttributeComponent::getName(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char AttributeComponent::getName(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status AttributeComponent::setAttrpath(const std::string &_attrpath)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _attrpath.size() + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)_attrpath.c_str(), len, 0);
  return status;

}

eyedb::Status AttributeComponent::setAttrpath(unsigned int a0, char _attrpath)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_attrpath, 1, from);
  return status;
}

std::string AttributeComponent::getAttrpath(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char AttributeComponent::getAttrpath(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status AttributeComponent::setClassOwner(eyedb::Class*_class_owner)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_oclass_owner = _class_owner;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_oclass_owner, 1, 0);
  return status;
}

const eyedb::Class*AttributeComponent::getClassOwner(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Class *)__o;
     }
     __go = (eyedb::Class *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Class*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Class *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Class*)__o;
}

eyedb::Class*AttributeComponent::getClassOwner(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Class *)__o;
     }
     __go = (eyedb::Class *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Class*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Class *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Class*)__o;
}

eyedb::Status AttributeComponent::setClassOwnerOid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid AttributeComponent::getClassOwnerOid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status AttributeComponent::setPropagate(eyedb::Bool _propagate, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _propagate;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

eyedb::Bool AttributeComponent::getPropagate(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (eyedb::Bool)0;}
  return (eyedb::Bool)__tmp;
}

static const eyedb::Attribute **AttributeComponentSet_agritems;
static eyedb::Size AttributeComponentSet_idr_objsz, AttributeComponentSet_idr_psize;

static eyedb::StructClass *AttributeComponentSet_make(eyedb::StructClass *AttributeComponentSet_class = 0, eyedb::Schema *m = 0)
{
  if (!AttributeComponentSet_class)
    return new eyedb::StructClass("attribute_component_set", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[5];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "attrname", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("set<attribute_component*>") : set_class_AttributeComponent_ref_Class), "comps", eyedb::False, 0, dims);

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("class") : eyedb::Class_Class), "class_owner", eyedb::True, 0, dims);

  AttributeComponentSet_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];

  eyedb::ClassPeer::setMType(AttributeComponentSet_class, eyedb::Class::System);

  return AttributeComponentSet_class;
}

eyedb::Object *AttributeComponentSet_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new AttributeComponentSet(cls, idr);
}

eyedb::Object *AttributeComponentSet_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new AttributeComponentSet((const eyedb::Struct *)o, share);
}

static void AttributeComponentSet_init_p()
{
  AttributeComponentSet_Class = AttributeComponentSet_make();
  constructors_x[class_ind] = AttributeComponentSet_construct_x;
  constructors[class_ind] = AttributeComponentSet_construct;
  hash->insert("attribute_component_set", class_ind++);
}

static void AttributeComponentSet_init()
{
  AttributeComponentSet_make(AttributeComponentSet_Class);

  AttributeComponentSet_agritems = AttributeComponentSet_Class->getAttributes();
  AttributeComponentSet_idr_objsz = AttributeComponentSet_Class->getIDRObjectSize(&AttributeComponentSet_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(AttributeComponentSet_Class, eyedb::True);
}

static eyedb::Status AttributeComponentSet_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

AttributeComponentSet::AttributeComponentSet(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

AttributeComponentSet::AttributeComponentSet(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void AttributeComponentSet::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("attribute_component_set") : AttributeComponentSet_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

AttributeComponentSet::AttributeComponentSet(const AttributeComponentSet& x) : eyedb::Struct(x)
{
  userCopy(x);
}

AttributeComponentSet& AttributeComponentSet::operator=(const AttributeComponentSet& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

AttributeComponentSet::AttributeComponentSet(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("attribute_component_set") : AttributeComponentSet_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

AttributeComponentSet::AttributeComponentSet(const AttributeComponentSet *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("attribute_component_set") : AttributeComponentSet_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status AttributeComponentSet::setAttrname(const std::string &_attrname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _attrname.size() + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)_attrname.c_str(), len, 0);
  return status;

}

eyedb::Status AttributeComponentSet::setAttrname(unsigned int a0, char _attrname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_attrname, 1, from);
  return status;
}

std::string AttributeComponentSet::getAttrname(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char AttributeComponentSet::getAttrname(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status AttributeComponentSet::setCompsColl(eyedb::CollSet*_comps)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ocomps = _comps;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_ocomps, 1, 0);
  return status;
}

const eyedb::CollSet*AttributeComponentSet::getCompsColl(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollSet*)__o;
}

eyedb::CollSet*AttributeComponentSet::getCompsColl(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollSet*)__o;
}

eyedb::Status AttributeComponentSet::addToCompsColl(AttributeComponent*_comps, eyedb::Bool noDup, const eyedb::CollImpl *collimpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollSet *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[3]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollSet(db, "", db->getSchema()->getClass("attribute_component"), eyedb::True, collimpl);
       }
    }

  status = _coll->insert(_comps, noDup);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status AttributeComponentSet::addToCompsColl(const eyedb::Oid &_oid, const eyedb::CollImpl *collimpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollSet *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[3]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollSet(db, "", db->getSchema()->getClass("attribute_component"), eyedb::True, collimpl);
       }
    }

  status = _coll->insert(_oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status AttributeComponentSet::rmvFromCompsColl(AttributeComponent*_comps, eyedb::Bool checkFirst)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollSet *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[3]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
        return eyedb::Exception::make(eyedb::IDB_ERROR, "no valid collection in attribute AttributeComponentSet::comps");

    }

  status = _coll->suppress(_comps, checkFirst);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status AttributeComponentSet::rmvFromCompsColl(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollSet *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[3]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
        return eyedb::Exception::make(eyedb::IDB_ERROR, "no valid collection in attribute AttributeComponentSet::comps");

    }

  status = _coll->suppress(_oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status AttributeComponentSet::setClassOwner(eyedb::Class*_class_owner)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_oclass_owner = _class_owner;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_oclass_owner, 1, 0);
  return status;
}

const eyedb::Class*AttributeComponentSet::getClassOwner(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Class *)__o;
     }
     __go = (eyedb::Class *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Class*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Class *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Class*)__o;
}

eyedb::Class*AttributeComponentSet::getClassOwner(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Class *)__o;
     }
     __go = (eyedb::Class *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Class*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Class *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Class*)__o;
}

eyedb::Status AttributeComponentSet::setClassOwnerOid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid AttributeComponentSet::getClassOwnerOid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const eyedb::Attribute **ClassComponent_agritems;
static eyedb::Size ClassComponent_idr_objsz, ClassComponent_idr_psize;

static eyedb::StructClass *ClassComponent_make(eyedb::StructClass *ClassComponent_class = 0, eyedb::Schema *m = 0)
{
  if (!ClassComponent_class)
    return new eyedb::StructClass("class_component", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("class") : eyedb::Class_Class), "class_owner", eyedb::True, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "name", eyedb::False, 1, dims);
  delete[] dims;

  ClassComponent_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];

  eyedb::ClassPeer::setMType(ClassComponent_class, eyedb::Class::System);

  return ClassComponent_class;
}

eyedb::Object *ClassComponent_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new ClassComponent(cls, idr);
}

eyedb::Object *ClassComponent_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new ClassComponent((const eyedb::Struct *)o, share);
}

static void ClassComponent_init_p()
{
  ClassComponent_Class = ClassComponent_make();
  constructors_x[class_ind] = ClassComponent_construct_x;
  constructors[class_ind] = ClassComponent_construct;
  hash->insert("class_component", class_ind++);
}

static void ClassComponent_init()
{
  ClassComponent_make(ClassComponent_Class);

  ClassComponent_agritems = ClassComponent_Class->getAttributes();
  ClassComponent_idr_objsz = ClassComponent_Class->getIDRObjectSize(&ClassComponent_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ClassComponent_Class, eyedb::True);
}

static eyedb::Status ClassComponent_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

ClassComponent::ClassComponent(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

ClassComponent::ClassComponent(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void ClassComponent::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("class_component") : ClassComponent_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

ClassComponent::ClassComponent(const ClassComponent& x) : eyedb::Struct(x)
{
  userCopy(x);
}

ClassComponent& ClassComponent::operator=(const ClassComponent& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

ClassComponent::ClassComponent(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("class_component") : ClassComponent_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

ClassComponent::ClassComponent(const ClassComponent *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("class_component") : ClassComponent_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status ClassComponent::setClassOwner(eyedb::Class*_class_owner)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_oclass_owner = _class_owner;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_oclass_owner, 1, 0);
  return status;
}

const eyedb::Class*ClassComponent::getClassOwner(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Class *)__o;
     }
     __go = (eyedb::Class *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Class*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Class *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Class*)__o;
}

eyedb::Class*ClassComponent::getClassOwner(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Class *)__o;
     }
     __go = (eyedb::Class *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Class*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Class *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Class*)__o;
}

eyedb::Status ClassComponent::setClassOwnerOid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid ClassComponent::getClassOwnerOid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status ClassComponent::setName(const std::string &_name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _name.size() + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)_name.c_str(), len, 0);
  return status;

}

eyedb::Status ClassComponent::setName(unsigned int a0, char _name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_name, 1, from);
  return status;
}

std::string ClassComponent::getName(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char ClassComponent::getName(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **AgregatClassComponent_agritems;
static eyedb::Size AgregatClassComponent_idr_objsz, AgregatClassComponent_idr_psize;

static eyedb::StructClass *AgregatClassComponent_make(eyedb::StructClass *AgregatClassComponent_class = 0, eyedb::Schema *m = 0)
{
  if (!AgregatClassComponent_class)
    return new eyedb::StructClass("agregat_class_component", (m ? m->getClass("class_component") : ClassComponent_Class));
  eyedb::Attribute *attr[4];

  AgregatClassComponent_class->setAttributes(&attr[4], 0);


  eyedb::ClassPeer::setMType(AgregatClassComponent_class, eyedb::Class::System);

  return AgregatClassComponent_class;
}

eyedb::Object *AgregatClassComponent_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new AgregatClassComponent(cls, idr);
}

eyedb::Object *AgregatClassComponent_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new AgregatClassComponent((const eyedb::Struct *)o, share);
}

static void AgregatClassComponent_init_p()
{
  AgregatClassComponent_Class = AgregatClassComponent_make();
  constructors_x[class_ind] = AgregatClassComponent_construct_x;
  constructors[class_ind] = AgregatClassComponent_construct;
  hash->insert("agregat_class_component", class_ind++);
}

static void AgregatClassComponent_init()
{
  AgregatClassComponent_make(AgregatClassComponent_Class);

  AgregatClassComponent_agritems = AgregatClassComponent_Class->getAttributes();
  AgregatClassComponent_idr_objsz = AgregatClassComponent_Class->getIDRObjectSize(&AgregatClassComponent_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(AgregatClassComponent_Class, eyedb::True);
}

static eyedb::Status AgregatClassComponent_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

AgregatClassComponent::AgregatClassComponent(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : ClassComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

AgregatClassComponent::AgregatClassComponent(const eyedb::Class *_cls, eyedb::Data _idr): ClassComponent((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void AgregatClassComponent::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("agregat_class_component") : AgregatClassComponent_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

AgregatClassComponent::AgregatClassComponent(const AgregatClassComponent& x) : ClassComponent(x)
{
  userCopy(x);
}

AgregatClassComponent& AgregatClassComponent::operator=(const AgregatClassComponent& x)
{
  *(ClassComponent *)this = ClassComponent::operator=((const ClassComponent &)x);
  userCopy(x);
  return *this;
}

AgregatClassComponent::AgregatClassComponent(const eyedb::Struct *x, eyedb::Bool share) : ClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("agregat_class_component") : AgregatClassComponent_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

AgregatClassComponent::AgregatClassComponent(const AgregatClassComponent *x, eyedb::Bool share) : ClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("agregat_class_component") : AgregatClassComponent_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

static const eyedb::Attribute **ClassVariable_agritems;
static eyedb::Size ClassVariable_idr_objsz, ClassVariable_idr_psize;

static eyedb::StructClass *ClassVariable_make(eyedb::StructClass *ClassVariable_class = 0, eyedb::Schema *m = 0)
{
  if (!ClassVariable_class)
    return new eyedb::StructClass("class_variable", (m ? m->getClass("class_component") : ClassComponent_Class));
  eyedb::Attribute *attr[6];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[4] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "vname", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("object") : eyedb::Object_Class), "val", eyedb::True, 0, dims);

  ClassVariable_class->setAttributes(&attr[4], 2);

  delete attr[4];
  delete attr[5];

  eyedb::ClassPeer::setMType(ClassVariable_class, eyedb::Class::System);

  return ClassVariable_class;
}

eyedb::Object *ClassVariable_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new ClassVariable(cls, idr);
}

eyedb::Object *ClassVariable_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new ClassVariable((const eyedb::Struct *)o, share);
}

static void ClassVariable_init_p()
{
  ClassVariable_Class = ClassVariable_make();
  constructors_x[class_ind] = ClassVariable_construct_x;
  constructors[class_ind] = ClassVariable_construct;
  hash->insert("class_variable", class_ind++);
}

static void ClassVariable_init()
{
  ClassVariable_make(ClassVariable_Class);

  ClassVariable_agritems = ClassVariable_Class->getAttributes();
  ClassVariable_idr_objsz = ClassVariable_Class->getIDRObjectSize(&ClassVariable_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ClassVariable_Class, eyedb::True);
}

static eyedb::Status ClassVariable_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

ClassVariable::ClassVariable(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : ClassComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

ClassVariable::ClassVariable(const eyedb::Class *_cls, eyedb::Data _idr): ClassComponent((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void ClassVariable::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("class_variable") : ClassVariable_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

ClassVariable::ClassVariable(const ClassVariable& x) : ClassComponent(x)
{
  userCopy(x);
}

ClassVariable& ClassVariable::operator=(const ClassVariable& x)
{
  *(ClassComponent *)this = ClassComponent::operator=((const ClassComponent &)x);
  userCopy(x);
  return *this;
}

ClassVariable::ClassVariable(const eyedb::Struct *x, eyedb::Bool share) : ClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("class_variable") : ClassVariable_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

ClassVariable::ClassVariable(const ClassVariable *x, eyedb::Bool share) : ClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("class_variable") : ClassVariable_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status ClassVariable::setVname(const std::string &_vname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _vname.size() + 1;

  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[4]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)_vname.c_str(), len, 0);
  return status;

}

eyedb::Status ClassVariable::setVname(unsigned int a0, char _vname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[4]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_vname, 1, from);
  return status;
}

std::string ClassVariable::getVname(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char ClassVariable::getVname(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ClassVariable::setVal(eyedb::Object*_val)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_oval = _val;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_oval, 1, 0);
  return status;
}

const eyedb::Object*ClassVariable::getVal(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Object *)__o;
     }
     __go = (eyedb::Object *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Object*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[5]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Object *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[5]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Object*)__o;
}

eyedb::Object*ClassVariable::getVal(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Object *)__o;
     }
     __go = (eyedb::Object *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Object*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[5]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Object *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[5]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Object*)__o;
}

eyedb::Status ClassVariable::setValOid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[5]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid ClassVariable::getValOid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const eyedb::Attribute **Index_agritems;
static eyedb::Size Index_idr_objsz, Index_idr_psize;

static eyedb::StructClass *Index_make(eyedb::StructClass *Index_class = 0, eyedb::Schema *m = 0)
{
  if (!Index_class)
    return new eyedb::StructClass("index", (m ? m->getClass("attribute_component") : AttributeComponent_Class));
  eyedb::Attribute *attr[10];
  int *dims;

  dims = 0;
  attr[6] = new eyedb::Attribute((m ? m->getClass("oid") : eyedb::OidP_Class), "idx_oid", eyedb::False, 0, dims);

  dims = 0;
  attr[7] = new eyedb::Attribute((m ? m->getClass("short") : eyedb::Int16_Class), "dspid", eyedb::False, 0, dims);

  dims = 0;
  attr[8] = new eyedb::Attribute((m ? m->getClass("bool") : eyedb::Bool_Class), "is_string", eyedb::False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[9] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "impl_hints", eyedb::False, 1, dims);
  delete[] dims;

  Index_class->setAttributes(&attr[6], 4);

  delete attr[6];
  delete attr[7];
  delete attr[8];
  delete attr[9];

  eyedb::ClassPeer::setMType(Index_class, eyedb::Class::System);

  return Index_class;
}

eyedb::Object *Index_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Index(cls, idr);
}

eyedb::Object *Index_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Index((const eyedb::Struct *)o, share);
}

static void Index_init_p()
{
  Index_Class = Index_make();
  constructors_x[class_ind] = Index_construct_x;
  constructors[class_ind] = Index_construct;
  hash->insert("index", class_ind++);
}

static void Index_init()
{
  Index_make(Index_Class);

  Index_agritems = Index_Class->getAttributes();
  Index_idr_objsz = Index_Class->getIDRObjectSize(&Index_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Index_Class, eyedb::True);
}

static eyedb::Status Index_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

Index::Index(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : AttributeComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

Index::Index(const eyedb::Class *_cls, eyedb::Data _idr): AttributeComponent((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Index::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("index") : Index_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Index::Index(const Index& x) : AttributeComponent(x)
{
  userCopy(x);
}

Index& Index::operator=(const Index& x)
{
  *(AttributeComponent *)this = AttributeComponent::operator=((const AttributeComponent &)x);
  userCopy(x);
  return *this;
}

Index::Index(const eyedb::Struct *x, eyedb::Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("index") : Index_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Index::Index(const Index *x, eyedb::Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("index") : Index_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Index::setIdxOid(eyedb::Oid _idx_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_idx_oid, 1, 0);
  return status;
}

eyedb::Oid Index::getIdxOid(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status Index::setDspid(eyedblib::int16 _dspid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[7]->setValue(this, (eyedb::Data)&_dspid, 1, 0);
  return status;
}

eyedblib::int16 Index::getDspid(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int16 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Index::setIsString(eyedb::Bool _is_string, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _is_string;

  status = getClass()->getAttributes()[8]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

eyedb::Bool Index::getIsString(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[8]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (eyedb::Bool)0;}
  return (eyedb::Bool)__tmp;
}

eyedb::Status Index::setImplHints(unsigned int a0, eyedblib::int32 _impl_hints)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[9]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[9]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[9]->setValue(this, (eyedb::Data)&_impl_hints, 1, from);
  return status;
}

eyedb::Status Index::setImplHintsCount(unsigned int a0)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;
  status = getClass()->getAttributes()[9]->setSize(this, from);
  return status;
}

eyedblib::int32 Index::getImplHints(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[9]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

unsigned int Index::getImplHintsCount(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Size size;
  eyedb::Status s;
  s = getClass()->getAttributes()[9]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

static const eyedb::Attribute **HashIndex_agritems;
static eyedb::Size HashIndex_idr_objsz, HashIndex_idr_psize;

static eyedb::StructClass *HashIndex_make(eyedb::StructClass *HashIndex_class = 0, eyedb::Schema *m = 0)
{
  if (!HashIndex_class)
    return new eyedb::StructClass("hashindex", (m ? m->getClass("index") : Index_Class));
  eyedb::Attribute *attr[12];
  int *dims;

  dims = 0;
  attr[10] = new eyedb::Attribute((m ? m->getClass("be_method_C") : BEMethod_C_Class), "hash_method", eyedb::True, 0, dims);

  dims = 0;
  attr[11] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "key_count", eyedb::False, 0, dims);

  HashIndex_class->setAttributes(&attr[10], 2);

  delete attr[10];
  delete attr[11];

  eyedb::ClassPeer::setMType(HashIndex_class, eyedb::Class::System);

  return HashIndex_class;
}

eyedb::Object *HashIndex_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new HashIndex(cls, idr);
}

eyedb::Object *HashIndex_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new HashIndex((const eyedb::Struct *)o, share);
}

static void HashIndex_init_p()
{
  HashIndex_Class = HashIndex_make();
  constructors_x[class_ind] = HashIndex_construct_x;
  constructors[class_ind] = HashIndex_construct;
  hash->insert("hashindex", class_ind++);
}

static void HashIndex_init()
{
  HashIndex_make(HashIndex_Class);

  HashIndex_agritems = HashIndex_Class->getAttributes();
  HashIndex_idr_objsz = HashIndex_Class->getIDRObjectSize(&HashIndex_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(HashIndex_Class, eyedb::True);
}

static eyedb::Status HashIndex_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

HashIndex::HashIndex(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Index(_db, _dataspace, 1)
{
  initialize(_db);
}

HashIndex::HashIndex(const eyedb::Class *_cls, eyedb::Data _idr): Index((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void HashIndex::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("hashindex") : HashIndex_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

HashIndex::HashIndex(const HashIndex& x) : Index(x)
{
  userCopy(x);
}

HashIndex& HashIndex::operator=(const HashIndex& x)
{
  *(Index *)this = Index::operator=((const Index &)x);
  userCopy(x);
  return *this;
}

HashIndex::HashIndex(const eyedb::Struct *x, eyedb::Bool share) : Index(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("hashindex") : HashIndex_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

HashIndex::HashIndex(const HashIndex *x, eyedb::Bool share) : Index(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("hashindex") : HashIndex_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status HashIndex::setHashMethod(BEMethod_C*_hash_method)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ohash_method = _hash_method;

  status = getClass()->getAttributes()[10]->setValue(this, (eyedb::Data)&_ohash_method, 1, 0);
  return status;
}

const BEMethod_C*HashIndex::getHashMethod(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[10]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (BEMethod_C *)__o;
     }
     __go = (BEMethod_C *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[10]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (BEMethod_C*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[10]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (BEMethod_C *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[10]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (BEMethod_C*)__o;
}

BEMethod_C*HashIndex::getHashMethod(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[10]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (BEMethod_C *)__o;
     }
     __go = (BEMethod_C *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[10]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (BEMethod_C*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[10]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (BEMethod_C *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[10]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (BEMethod_C*)__o;
}

eyedb::Status HashIndex::setHashMethodOid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[10]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid HashIndex::getHashMethodOid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[10]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status HashIndex::setKeyCount(eyedblib::int32 _key_count)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[11]->setValue(this, (eyedb::Data)&_key_count, 1, 0);
  return status;
}

eyedblib::int32 HashIndex::getKeyCount(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[11]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **BTreeIndex_agritems;
static eyedb::Size BTreeIndex_idr_objsz, BTreeIndex_idr_psize;

static eyedb::StructClass *BTreeIndex_make(eyedb::StructClass *BTreeIndex_class = 0, eyedb::Schema *m = 0)
{
  if (!BTreeIndex_class)
    return new eyedb::StructClass("btreeindex", (m ? m->getClass("index") : Index_Class));
  eyedb::Attribute *attr[11];
  int *dims;

  dims = 0;
  attr[10] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "degree", eyedb::False, 0, dims);

  BTreeIndex_class->setAttributes(&attr[10], 1);

  delete attr[10];

  eyedb::ClassPeer::setMType(BTreeIndex_class, eyedb::Class::System);

  return BTreeIndex_class;
}

eyedb::Object *BTreeIndex_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new BTreeIndex(cls, idr);
}

eyedb::Object *BTreeIndex_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new BTreeIndex((const eyedb::Struct *)o, share);
}

static void BTreeIndex_init_p()
{
  BTreeIndex_Class = BTreeIndex_make();
  constructors_x[class_ind] = BTreeIndex_construct_x;
  constructors[class_ind] = BTreeIndex_construct;
  hash->insert("btreeindex", class_ind++);
}

static void BTreeIndex_init()
{
  BTreeIndex_make(BTreeIndex_Class);

  BTreeIndex_agritems = BTreeIndex_Class->getAttributes();
  BTreeIndex_idr_objsz = BTreeIndex_Class->getIDRObjectSize(&BTreeIndex_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(BTreeIndex_Class, eyedb::True);
}

static eyedb::Status BTreeIndex_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

BTreeIndex::BTreeIndex(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Index(_db, _dataspace, 1)
{
  initialize(_db);
}

BTreeIndex::BTreeIndex(const eyedb::Class *_cls, eyedb::Data _idr): Index((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void BTreeIndex::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("btreeindex") : BTreeIndex_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

BTreeIndex::BTreeIndex(const BTreeIndex& x) : Index(x)
{
  userCopy(x);
}

BTreeIndex& BTreeIndex::operator=(const BTreeIndex& x)
{
  *(Index *)this = Index::operator=((const Index &)x);
  userCopy(x);
  return *this;
}

BTreeIndex::BTreeIndex(const eyedb::Struct *x, eyedb::Bool share) : Index(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("btreeindex") : BTreeIndex_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

BTreeIndex::BTreeIndex(const BTreeIndex *x, eyedb::Bool share) : Index(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("btreeindex") : BTreeIndex_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status BTreeIndex::setDegree(eyedblib::int32 _degree)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[10]->setValue(this, (eyedb::Data)&_degree, 1, 0);
  return status;
}

eyedblib::int32 BTreeIndex::getDegree(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[10]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **CollAttrImpl_agritems;
static eyedb::Size CollAttrImpl_idr_objsz, CollAttrImpl_idr_psize;

static eyedb::StructClass *CollAttrImpl_make(eyedb::StructClass *CollAttrImpl_class = 0, eyedb::Schema *m = 0)
{
  if (!CollAttrImpl_class)
    return new eyedb::StructClass("collection_attribute_implementation", (m ? m->getClass("attribute_component") : AttributeComponent_Class));
  eyedb::Attribute *attr[11];
  int *dims;

  dims = 0;
  attr[6] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "impl_type", eyedb::False, 0, dims);

  dims = 0;
  attr[7] = new eyedb::Attribute((m ? m->getClass("short") : eyedb::Int16_Class), "dspid", eyedb::False, 0, dims);

  dims = 0;
  attr[8] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "key_count_or_degree", eyedb::False, 0, dims);

  dims = 0;
  attr[9] = new eyedb::Attribute((m ? m->getClass("be_method_C") : BEMethod_C_Class), "hash_method", eyedb::True, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[10] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "impl_hints", eyedb::False, 1, dims);
  delete[] dims;

  CollAttrImpl_class->setAttributes(&attr[6], 5);

  delete attr[6];
  delete attr[7];
  delete attr[8];
  delete attr[9];
  delete attr[10];

  eyedb::ClassPeer::setMType(CollAttrImpl_class, eyedb::Class::System);

  return CollAttrImpl_class;
}

eyedb::Object *CollAttrImpl_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new CollAttrImpl(cls, idr);
}

eyedb::Object *CollAttrImpl_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new CollAttrImpl((const eyedb::Struct *)o, share);
}

static void CollAttrImpl_init_p()
{
  CollAttrImpl_Class = CollAttrImpl_make();
  constructors_x[class_ind] = CollAttrImpl_construct_x;
  constructors[class_ind] = CollAttrImpl_construct;
  hash->insert("collection_attribute_implementation", class_ind++);
}

static void CollAttrImpl_init()
{
  CollAttrImpl_make(CollAttrImpl_Class);

  CollAttrImpl_agritems = CollAttrImpl_Class->getAttributes();
  CollAttrImpl_idr_objsz = CollAttrImpl_Class->getIDRObjectSize(&CollAttrImpl_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(CollAttrImpl_Class, eyedb::True);
}

static eyedb::Status CollAttrImpl_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

CollAttrImpl::CollAttrImpl(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : AttributeComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

CollAttrImpl::CollAttrImpl(const eyedb::Class *_cls, eyedb::Data _idr): AttributeComponent((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void CollAttrImpl::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("collection_attribute_implementation") : CollAttrImpl_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

CollAttrImpl::CollAttrImpl(const CollAttrImpl& x) : AttributeComponent(x)
{
  userCopy(x);
}

CollAttrImpl& CollAttrImpl::operator=(const CollAttrImpl& x)
{
  *(AttributeComponent *)this = AttributeComponent::operator=((const AttributeComponent &)x);
  userCopy(x);
  return *this;
}

CollAttrImpl::CollAttrImpl(const eyedb::Struct *x, eyedb::Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("collection_attribute_implementation") : CollAttrImpl_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

CollAttrImpl::CollAttrImpl(const CollAttrImpl *x, eyedb::Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("collection_attribute_implementation") : CollAttrImpl_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status CollAttrImpl::setImplType(eyedblib::int32 _impl_type)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_impl_type, 1, 0);
  return status;
}

eyedblib::int32 CollAttrImpl::getImplType(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status CollAttrImpl::setDspid(eyedblib::int16 _dspid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[7]->setValue(this, (eyedb::Data)&_dspid, 1, 0);
  return status;
}

eyedblib::int16 CollAttrImpl::getDspid(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int16 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status CollAttrImpl::setKeyCountOrDegree(eyedblib::int32 _key_count_or_degree)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[8]->setValue(this, (eyedb::Data)&_key_count_or_degree, 1, 0);
  return status;
}

eyedblib::int32 CollAttrImpl::getKeyCountOrDegree(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[8]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status CollAttrImpl::setHashMethod(BEMethod_C*_hash_method)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ohash_method = _hash_method;

  status = getClass()->getAttributes()[9]->setValue(this, (eyedb::Data)&_ohash_method, 1, 0);
  return status;
}

const BEMethod_C*CollAttrImpl::getHashMethod(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[9]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (BEMethod_C *)__o;
     }
     __go = (BEMethod_C *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[9]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (BEMethod_C*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[9]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (BEMethod_C *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[9]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (BEMethod_C*)__o;
}

BEMethod_C*CollAttrImpl::getHashMethod(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[9]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (BEMethod_C *)__o;
     }
     __go = (BEMethod_C *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[9]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (BEMethod_C*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[9]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (BEMethod_C *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[9]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (BEMethod_C*)__o;
}

eyedb::Status CollAttrImpl::setHashMethodOid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[9]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid CollAttrImpl::getHashMethodOid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[9]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status CollAttrImpl::setImplHints(unsigned int a0, eyedblib::int32 _impl_hints)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[10]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[10]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[10]->setValue(this, (eyedb::Data)&_impl_hints, 1, from);
  return status;
}

eyedb::Status CollAttrImpl::setImplHintsCount(unsigned int a0)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;
  status = getClass()->getAttributes()[10]->setSize(this, from);
  return status;
}

eyedblib::int32 CollAttrImpl::getImplHints(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[10]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

unsigned int CollAttrImpl::getImplHintsCount(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Size size;
  eyedb::Status s;
  s = getClass()->getAttributes()[10]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

static const eyedb::Attribute **ArgType_agritems;
static eyedb::Size ArgType_idr_objsz, ArgType_idr_psize;

static eyedb::StructClass *ArgType_make(eyedb::StructClass *ArgType_class = 0, eyedb::Schema *m = 0)
{
  if (!ArgType_class)
    return new eyedb::StructClass("argtype", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("argtype_type") : ArgType_Type_Class), "type", eyedb::False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "clname", eyedb::False, 1, dims);
  delete[] dims;

  ArgType_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];

  eyedb::ClassPeer::setMType(ArgType_class, eyedb::Class::System);

  return ArgType_class;
}

eyedb::Object *ArgType_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new ArgType(cls, idr);
}

eyedb::Object *ArgType_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new ArgType((const eyedb::Struct *)o, share);
}

static void ArgType_init_p()
{
  ArgType_Class = ArgType_make();
  constructors_x[class_ind] = ArgType_construct_x;
  constructors[class_ind] = ArgType_construct;
  hash->insert("argtype", class_ind++);
}

static void ArgType_init()
{
  ArgType_make(ArgType_Class);

  ArgType_agritems = ArgType_Class->getAttributes();
  ArgType_idr_objsz = ArgType_Class->getIDRObjectSize(&ArgType_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ArgType_Class, eyedb::True);
}

static eyedb::Status ArgType_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

ArgType::ArgType(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

ArgType::ArgType(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void ArgType::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("argtype") : ArgType_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

ArgType::ArgType(const ArgType& x) : eyedb::Struct(x)
{
  userCopy(x);
}

ArgType& ArgType::operator=(const ArgType& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

ArgType::ArgType(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("argtype") : ArgType_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

ArgType::ArgType(const ArgType *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("argtype") : ArgType_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status ArgType::setType(ArgType_Type _type, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _type;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

ArgType_Type ArgType::getType(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (ArgType_Type)0;}
  return (ArgType_Type)__tmp;
}

eyedb::Status ArgType::setClname(const std::string &_clname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _clname.size() + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)_clname.c_str(), len, 0);
  return status;

}

eyedb::Status ArgType::setClname(unsigned int a0, char _clname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_clname, 1, from);
  return status;
}

std::string ArgType::getClname(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char ArgType::getClname(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **Signature_agritems;
static eyedb::Size Signature_idr_objsz, Signature_idr_psize;

static eyedb::StructClass *Signature_make(eyedb::StructClass *Signature_class = 0, eyedb::Schema *m = 0)
{
  if (!Signature_class)
    return new eyedb::StructClass("signature", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[5];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("argtype") : ArgType_Class), "rettype", eyedb::False, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "nargs", eyedb::False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[4] = new eyedb::Attribute((m ? m->getClass("argtype") : ArgType_Class), "types", eyedb::False, 1, dims);
  delete[] dims;

  Signature_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];

  eyedb::ClassPeer::setMType(Signature_class, eyedb::Class::System);

  return Signature_class;
}

eyedb::Object *Signature_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Signature(cls, idr);
}

eyedb::Object *Signature_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Signature((const eyedb::Struct *)o, share);
}

static void Signature_init_p()
{
  Signature_Class = Signature_make();
  constructors_x[class_ind] = Signature_construct_x;
  constructors[class_ind] = Signature_construct;
  hash->insert("signature", class_ind++);
}

static void Signature_init()
{
  Signature_make(Signature_Class);

  Signature_agritems = Signature_Class->getAttributes();
  Signature_idr_objsz = Signature_Class->getIDRObjectSize(&Signature_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Signature_Class, eyedb::True);
}

static eyedb::Status Signature_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

Signature::Signature(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

Signature::Signature(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Signature::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("signature") : Signature_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Signature::Signature(const Signature& x) : eyedb::Struct(x)
{
  userCopy(x);
}

Signature& Signature::operator=(const Signature& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

Signature::Signature(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("signature") : Signature_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Signature::Signature(const Signature *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("signature") : Signature_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Signature::setRettype(ArgType*_rettype)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_orettype = _rettype;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_orettype, 1, 0);
  return status;
}

const ArgType*Signature::getRettype(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ArgType *)__o;
     }
     __go = (ArgType *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ArgType*)__o;
}

ArgType*Signature::getRettype(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ArgType *)__o;
     }
     __go = (ArgType *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ArgType*)__o;
}

eyedb::Status Signature::setNargs(eyedblib::int32 _nargs)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_nargs, 1, 0);
  return status;
}

eyedblib::int32 Signature::getNargs(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Signature::setTypes(unsigned int a0, ArgType*_types)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[4]->setSize(this, from+1);
  if (status)
    return status;

  eyedb::Object *_otypes = _types;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_otypes, 1, from);
  return status;
}

eyedb::Status Signature::setTypesCount(unsigned int a0)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;
  status = getClass()->getAttributes()[4]->setSize(this, from);
  return status;
}

const ArgType*Signature::getTypes(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ArgType *)__o;
     }
     __go = (ArgType *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ArgType*)__o;
}

ArgType*Signature::getTypes(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ArgType *)__o;
     }
     __go = (ArgType *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ArgType*)__o;
}

unsigned int Signature::getTypesCount(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Size size;
  eyedb::Status s;
  s = getClass()->getAttributes()[4]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

static const eyedb::Attribute **Executable_agritems;
static eyedb::Size Executable_idr_objsz, Executable_idr_psize;

static eyedb::StructClass *Executable_make(eyedb::StructClass *Executable_class = 0, eyedb::Schema *m = 0)
{
  if (!Executable_class)
    return new eyedb::StructClass("executable", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[8];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "exname", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("executable_lang") : ExecutableLang_Class), "lang", eyedb::False, 0, dims);

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("executable_localisation") : ExecutableLocalisation_Class), "loc", eyedb::False, 0, dims);

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("signature") : Signature_Class), "sign", eyedb::False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[6] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "intname", eyedb::False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[7] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "extref_body", eyedb::False, 1, dims);
  delete[] dims;

  Executable_class->setAttributes(&attr[2], 6);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];
  delete attr[6];
  delete attr[7];

  eyedb::ClassPeer::setMType(Executable_class, eyedb::Class::System);

  return Executable_class;
}

eyedb::Object *Executable_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Executable(cls, idr);
}

eyedb::Object *Executable_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Executable((const eyedb::Struct *)o, share);
}

static void Executable_init_p()
{
  Executable_Class = Executable_make();
  constructors_x[class_ind] = Executable_construct_x;
  constructors[class_ind] = Executable_construct;
  hash->insert("executable", class_ind++);
}

static void Executable_init()
{
  Executable_make(Executable_Class);

  Executable_agritems = Executable_Class->getAttributes();
  Executable_idr_objsz = Executable_Class->getIDRObjectSize(&Executable_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Executable_Class, eyedb::True);
}

static eyedb::Status Executable_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  comp = new eyedb::NotNullConstraint(db, cls, "executable.exname", eyedb::True);
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

Executable::Executable(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

Executable::Executable(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Executable::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("executable") : Executable_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Executable::Executable(const Executable& x) : eyedb::Struct(x)
{
  userCopy(x);
}

Executable& Executable::operator=(const Executable& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

Executable::Executable(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("executable") : Executable_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Executable::Executable(const Executable *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("executable") : Executable_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Executable::setExname(const std::string &_exname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _exname.size() + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)_exname.c_str(), len, 0);
  return status;

}

eyedb::Status Executable::setExname(unsigned int a0, char _exname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_exname, 1, from);
  return status;
}

std::string Executable::getExname(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char Executable::getExname(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Executable::setLang(ExecutableLang _lang, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _lang;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

ExecutableLang Executable::getLang(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (ExecutableLang)0;}
  return (ExecutableLang)__tmp;
}

eyedb::Status Executable::setLoc(ExecutableLocalisation _loc, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _loc;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

ExecutableLocalisation Executable::getLoc(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (ExecutableLocalisation)0;}
  return (ExecutableLocalisation)__tmp;
}

eyedb::Status Executable::setSign(Signature*_sign)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_osign = _sign;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_osign, 1, 0);
  return status;
}

const Signature*Executable::getSign(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Signature *)__o;
     }
     __go = (Signature *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Signature*)__o;
}

Signature*Executable::getSign(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Signature *)__o;
     }
     __go = (Signature *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Signature*)__o;
}

eyedb::Status Executable::setIntname(const std::string &_intname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _intname.size() + 1;

  status = getClass()->getAttributes()[6]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[6]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)_intname.c_str(), len, 0);
  return status;

}

eyedb::Status Executable::setIntname(unsigned int a0, char _intname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[6]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[6]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_intname, 1, from);
  return status;
}

std::string Executable::getIntname(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char Executable::getIntname(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Executable::setExtrefBody(const std::string &_extref_body)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _extref_body.size() + 1;

  status = getClass()->getAttributes()[7]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[7]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[7]->setValue(this, (eyedb::Data)_extref_body.c_str(), len, 0);
  return status;

}

eyedb::Status Executable::setExtrefBody(unsigned int a0, char _extref_body)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[7]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[7]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[7]->setValue(this, (eyedb::Data)&_extref_body, 1, from);
  return status;
}

std::string Executable::getExtrefBody(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char Executable::getExtrefBody(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[7]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **AgregatClassExecutable_agritems;
static eyedb::Size AgregatClassExecutable_idr_objsz, AgregatClassExecutable_idr_psize;

static eyedb::StructClass *AgregatClassExecutable_make(eyedb::StructClass *AgregatClassExecutable_class = 0, eyedb::Schema *m = 0)
{
  if (!AgregatClassExecutable_class)
    return new eyedb::StructClass("agregat_class_executable", (m ? m->getClass("agregat_class_component") : AgregatClassComponent_Class));
  eyedb::Attribute *attr[5];
  int *dims;

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("executable") : Executable_Class), "ex", eyedb::False, 0, dims);

  AgregatClassExecutable_class->setAttributes(&attr[4], 1);

  delete attr[4];

  eyedb::ClassPeer::setMType(AgregatClassExecutable_class, eyedb::Class::System);

  return AgregatClassExecutable_class;
}

eyedb::Object *AgregatClassExecutable_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new AgregatClassExecutable(cls, idr);
}

eyedb::Object *AgregatClassExecutable_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new AgregatClassExecutable((const eyedb::Struct *)o, share);
}

static void AgregatClassExecutable_init_p()
{
  AgregatClassExecutable_Class = AgregatClassExecutable_make();
  constructors_x[class_ind] = AgregatClassExecutable_construct_x;
  constructors[class_ind] = AgregatClassExecutable_construct;
  hash->insert("agregat_class_executable", class_ind++);
}

static void AgregatClassExecutable_init()
{
  AgregatClassExecutable_make(AgregatClassExecutable_Class);

  AgregatClassExecutable_agritems = AgregatClassExecutable_Class->getAttributes();
  AgregatClassExecutable_idr_objsz = AgregatClassExecutable_Class->getIDRObjectSize(&AgregatClassExecutable_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(AgregatClassExecutable_Class, eyedb::True);
}

static eyedb::Status AgregatClassExecutable_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "agregat_class_executable.ex.exname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "agregat_class_executable.ex.intname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

AgregatClassExecutable::AgregatClassExecutable(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : AgregatClassComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

AgregatClassExecutable::AgregatClassExecutable(const eyedb::Class *_cls, eyedb::Data _idr): AgregatClassComponent((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void AgregatClassExecutable::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("agregat_class_executable") : AgregatClassExecutable_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

AgregatClassExecutable::AgregatClassExecutable(const AgregatClassExecutable& x) : AgregatClassComponent(x)
{
  userCopy(x);
}

AgregatClassExecutable& AgregatClassExecutable::operator=(const AgregatClassExecutable& x)
{
  *(AgregatClassComponent *)this = AgregatClassComponent::operator=((const AgregatClassComponent &)x);
  userCopy(x);
  return *this;
}

AgregatClassExecutable::AgregatClassExecutable(const eyedb::Struct *x, eyedb::Bool share) : AgregatClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("agregat_class_executable") : AgregatClassExecutable_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

AgregatClassExecutable::AgregatClassExecutable(const AgregatClassExecutable *x, eyedb::Bool share) : AgregatClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("agregat_class_executable") : AgregatClassExecutable_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status AgregatClassExecutable::setEx(Executable*_ex)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_oex = _ex;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_oex, 1, 0);
  return status;
}

const Executable*AgregatClassExecutable::getEx(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Executable *)__o;
     }
     __go = (Executable *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Executable*)__o;
}

Executable*AgregatClassExecutable::getEx(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Executable *)__o;
     }
     __go = (Executable *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Executable*)__o;
}

static const eyedb::Attribute **Method_agritems;
static eyedb::Size Method_idr_objsz, Method_idr_psize;

static eyedb::StructClass *Method_make(eyedb::StructClass *Method_class = 0, eyedb::Schema *m = 0)
{
  if (!Method_class)
    return new eyedb::StructClass("method", (m ? m->getClass("agregat_class_executable") : AgregatClassExecutable_Class));
  eyedb::Attribute *attr[5];

  Method_class->setAttributes(&attr[5], 0);


  eyedb::ClassPeer::setMType(Method_class, eyedb::Class::System);

  return Method_class;
}

eyedb::Object *Method_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Method(cls, idr);
}

eyedb::Object *Method_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Method((const eyedb::Struct *)o, share);
}

static void Method_init_p()
{
  Method_Class = Method_make();
  constructors_x[class_ind] = Method_construct_x;
  constructors[class_ind] = Method_construct;
  hash->insert("method", class_ind++);
}

static void Method_init()
{
  Method_make(Method_Class);

  Method_agritems = Method_Class->getAttributes();
  Method_idr_objsz = Method_Class->getIDRObjectSize(&Method_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Method_Class, eyedb::True);
}

static eyedb::Status Method_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "method.ex.exname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "method.ex.intname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

Method::Method(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : AgregatClassExecutable(_db, _dataspace, 1)
{
  initialize(_db);
}

Method::Method(const eyedb::Class *_cls, eyedb::Data _idr): AgregatClassExecutable((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Method::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("method") : Method_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Method::Method(const Method& x) : AgregatClassExecutable(x)
{
  userCopy(x);
}

Method& Method::operator=(const Method& x)
{
  *(AgregatClassExecutable *)this = AgregatClassExecutable::operator=((const AgregatClassExecutable &)x);
  userCopy(x);
  return *this;
}

Method::Method(const eyedb::Struct *x, eyedb::Bool share) : AgregatClassExecutable(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("method") : Method_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Method::Method(const Method *x, eyedb::Bool share) : AgregatClassExecutable(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("method") : Method_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

static const eyedb::Attribute **FEMethod_agritems;
static eyedb::Size FEMethod_idr_objsz, FEMethod_idr_psize;

static eyedb::StructClass *FEMethod_make(eyedb::StructClass *FEMethod_class = 0, eyedb::Schema *m = 0)
{
  if (!FEMethod_class)
    return new eyedb::StructClass("fe_method", (m ? m->getClass("method") : Method_Class));
  eyedb::Attribute *attr[5];

  FEMethod_class->setAttributes(&attr[5], 0);


  eyedb::ClassPeer::setMType(FEMethod_class, eyedb::Class::System);

  return FEMethod_class;
}

eyedb::Object *FEMethod_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new FEMethod(cls, idr);
}

eyedb::Object *FEMethod_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new FEMethod((const eyedb::Struct *)o, share);
}

static void FEMethod_init_p()
{
  FEMethod_Class = FEMethod_make();
  constructors_x[class_ind] = FEMethod_construct_x;
  constructors[class_ind] = FEMethod_construct;
  hash->insert("fe_method", class_ind++);
}

static void FEMethod_init()
{
  FEMethod_make(FEMethod_Class);

  FEMethod_agritems = FEMethod_Class->getAttributes();
  FEMethod_idr_objsz = FEMethod_Class->getIDRObjectSize(&FEMethod_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(FEMethod_Class, eyedb::True);
}

static eyedb::Status FEMethod_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "fe_method.ex.exname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "fe_method.ex.intname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

FEMethod::FEMethod(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Method(_db, _dataspace, 1)
{
  initialize(_db);
}

FEMethod::FEMethod(const eyedb::Class *_cls, eyedb::Data _idr): Method((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void FEMethod::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("fe_method") : FEMethod_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

FEMethod::FEMethod(const FEMethod& x) : Method(x)
{
  userCopy(x);
}

FEMethod& FEMethod::operator=(const FEMethod& x)
{
  *(Method *)this = Method::operator=((const Method &)x);
  userCopy(x);
  return *this;
}

FEMethod::FEMethod(const eyedb::Struct *x, eyedb::Bool share) : Method(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("fe_method") : FEMethod_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

FEMethod::FEMethod(const FEMethod *x, eyedb::Bool share) : Method(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("fe_method") : FEMethod_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

static const eyedb::Attribute **FEMethod_C_agritems;
static eyedb::Size FEMethod_C_idr_objsz, FEMethod_C_idr_psize;

static eyedb::StructClass *FEMethod_C_make(eyedb::StructClass *FEMethod_C_class = 0, eyedb::Schema *m = 0)
{
  if (!FEMethod_C_class)
    return new eyedb::StructClass("fe_method_C", (m ? m->getClass("fe_method") : FEMethod_Class));
  eyedb::Attribute *attr[5];

  FEMethod_C_class->setAttributes(&attr[5], 0);


  eyedb::ClassPeer::setMType(FEMethod_C_class, eyedb::Class::System);

  return FEMethod_C_class;
}

eyedb::Object *FEMethod_C_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new FEMethod_C(cls, idr);
}

eyedb::Object *FEMethod_C_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new FEMethod_C((const eyedb::Struct *)o, share);
}

static void FEMethod_C_init_p()
{
  FEMethod_C_Class = FEMethod_C_make();
  constructors_x[class_ind] = FEMethod_C_construct_x;
  constructors[class_ind] = FEMethod_C_construct;
  hash->insert("fe_method_C", class_ind++);
}

static void FEMethod_C_init()
{
  FEMethod_C_make(FEMethod_C_Class);

  FEMethod_C_agritems = FEMethod_C_Class->getAttributes();
  FEMethod_C_idr_objsz = FEMethod_C_Class->getIDRObjectSize(&FEMethod_C_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(FEMethod_C_Class, eyedb::True);
}

static eyedb::Status FEMethod_C_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "fe_method_C.ex.exname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "fe_method_C.ex.intname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

FEMethod_C::FEMethod_C(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : FEMethod(_db, _dataspace, 1)
{
  initialize(_db);
}

FEMethod_C::FEMethod_C(const eyedb::Class *_cls, eyedb::Data _idr): FEMethod((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void FEMethod_C::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("fe_method_C") : FEMethod_C_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

FEMethod_C::FEMethod_C(const FEMethod_C& x) : FEMethod(x)
{
  userCopy(x);
}

FEMethod_C& FEMethod_C::operator=(const FEMethod_C& x)
{
  *(FEMethod *)this = FEMethod::operator=((const FEMethod &)x);
  userCopy(x);
  return *this;
}

FEMethod_C::FEMethod_C(const eyedb::Struct *x, eyedb::Bool share) : FEMethod(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("fe_method_C") : FEMethod_C_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

FEMethod_C::FEMethod_C(const FEMethod_C *x, eyedb::Bool share) : FEMethod(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("fe_method_C") : FEMethod_C_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

static const eyedb::Attribute **BEMethod_agritems;
static eyedb::Size BEMethod_idr_objsz, BEMethod_idr_psize;

static eyedb::StructClass *BEMethod_make(eyedb::StructClass *BEMethod_class = 0, eyedb::Schema *m = 0)
{
  if (!BEMethod_class)
    return new eyedb::StructClass("be_method", (m ? m->getClass("method") : Method_Class));
  eyedb::Attribute *attr[5];

  BEMethod_class->setAttributes(&attr[5], 0);


  eyedb::ClassPeer::setMType(BEMethod_class, eyedb::Class::System);

  return BEMethod_class;
}

eyedb::Object *BEMethod_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new BEMethod(cls, idr);
}

eyedb::Object *BEMethod_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new BEMethod((const eyedb::Struct *)o, share);
}

static void BEMethod_init_p()
{
  BEMethod_Class = BEMethod_make();
  constructors_x[class_ind] = BEMethod_construct_x;
  constructors[class_ind] = BEMethod_construct;
  hash->insert("be_method", class_ind++);
}

static void BEMethod_init()
{
  BEMethod_make(BEMethod_Class);

  BEMethod_agritems = BEMethod_Class->getAttributes();
  BEMethod_idr_objsz = BEMethod_Class->getIDRObjectSize(&BEMethod_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(BEMethod_Class, eyedb::True);
}

static eyedb::Status BEMethod_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "be_method.ex.exname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "be_method.ex.intname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

BEMethod::BEMethod(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Method(_db, _dataspace, 1)
{
  initialize(_db);
}

BEMethod::BEMethod(const eyedb::Class *_cls, eyedb::Data _idr): Method((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void BEMethod::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("be_method") : BEMethod_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

BEMethod::BEMethod(const BEMethod& x) : Method(x)
{
  userCopy(x);
}

BEMethod& BEMethod::operator=(const BEMethod& x)
{
  *(Method *)this = Method::operator=((const Method &)x);
  userCopy(x);
  return *this;
}

BEMethod::BEMethod(const eyedb::Struct *x, eyedb::Bool share) : Method(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("be_method") : BEMethod_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

BEMethod::BEMethod(const BEMethod *x, eyedb::Bool share) : Method(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("be_method") : BEMethod_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

static const eyedb::Attribute **BEMethod_C_agritems;
static eyedb::Size BEMethod_C_idr_objsz, BEMethod_C_idr_psize;

static eyedb::StructClass *BEMethod_C_make(eyedb::StructClass *BEMethod_C_class = 0, eyedb::Schema *m = 0)
{
  if (!BEMethod_C_class)
    return new eyedb::StructClass("be_method_C", (m ? m->getClass("be_method") : BEMethod_Class));
  eyedb::Attribute *attr[5];

  BEMethod_C_class->setAttributes(&attr[5], 0);


  eyedb::ClassPeer::setMType(BEMethod_C_class, eyedb::Class::System);

  return BEMethod_C_class;
}

eyedb::Object *BEMethod_C_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new BEMethod_C(cls, idr);
}

eyedb::Object *BEMethod_C_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new BEMethod_C((const eyedb::Struct *)o, share);
}

static void BEMethod_C_init_p()
{
  BEMethod_C_Class = BEMethod_C_make();
  constructors_x[class_ind] = BEMethod_C_construct_x;
  constructors[class_ind] = BEMethod_C_construct;
  hash->insert("be_method_C", class_ind++);
}

static void BEMethod_C_init()
{
  BEMethod_C_make(BEMethod_C_Class);

  BEMethod_C_agritems = BEMethod_C_Class->getAttributes();
  BEMethod_C_idr_objsz = BEMethod_C_Class->getIDRObjectSize(&BEMethod_C_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(BEMethod_C_Class, eyedb::True);
}

static eyedb::Status BEMethod_C_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "be_method_C.ex.exname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "be_method_C.ex.intname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

BEMethod_C::BEMethod_C(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : BEMethod(_db, _dataspace, 1)
{
  initialize(_db);
}

BEMethod_C::BEMethod_C(const eyedb::Class *_cls, eyedb::Data _idr): BEMethod((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void BEMethod_C::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("be_method_C") : BEMethod_C_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

BEMethod_C::BEMethod_C(const BEMethod_C& x) : BEMethod(x)
{
  userCopy(x);
}

BEMethod_C& BEMethod_C::operator=(const BEMethod_C& x)
{
  *(BEMethod *)this = BEMethod::operator=((const BEMethod &)x);
  userCopy(x);
  return *this;
}

BEMethod_C::BEMethod_C(const eyedb::Struct *x, eyedb::Bool share) : BEMethod(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("be_method_C") : BEMethod_C_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

BEMethod_C::BEMethod_C(const BEMethod_C *x, eyedb::Bool share) : BEMethod(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("be_method_C") : BEMethod_C_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

static const eyedb::Attribute **BEMethod_OQL_agritems;
static eyedb::Size BEMethod_OQL_idr_objsz, BEMethod_OQL_idr_psize;

static eyedb::StructClass *BEMethod_OQL_make(eyedb::StructClass *BEMethod_OQL_class = 0, eyedb::Schema *m = 0)
{
  if (!BEMethod_OQL_class)
    return new eyedb::StructClass("be_method_OQL", (m ? m->getClass("be_method") : BEMethod_Class));
  eyedb::Attribute *attr[5];

  BEMethod_OQL_class->setAttributes(&attr[5], 0);


  eyedb::ClassPeer::setMType(BEMethod_OQL_class, eyedb::Class::System);

  return BEMethod_OQL_class;
}

eyedb::Object *BEMethod_OQL_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new BEMethod_OQL(cls, idr);
}

eyedb::Object *BEMethod_OQL_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new BEMethod_OQL((const eyedb::Struct *)o, share);
}

static void BEMethod_OQL_init_p()
{
  BEMethod_OQL_Class = BEMethod_OQL_make();
  constructors_x[class_ind] = BEMethod_OQL_construct_x;
  constructors[class_ind] = BEMethod_OQL_construct;
  hash->insert("be_method_OQL", class_ind++);
}

static void BEMethod_OQL_init()
{
  BEMethod_OQL_make(BEMethod_OQL_Class);

  BEMethod_OQL_agritems = BEMethod_OQL_Class->getAttributes();
  BEMethod_OQL_idr_objsz = BEMethod_OQL_Class->getIDRObjectSize(&BEMethod_OQL_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(BEMethod_OQL_Class, eyedb::True);
}

static eyedb::Status BEMethod_OQL_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "be_method_OQL.ex.exname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "be_method_OQL.ex.intname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

BEMethod_OQL::BEMethod_OQL(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : BEMethod(_db, _dataspace, 1)
{
  initialize(_db);
}

BEMethod_OQL::BEMethod_OQL(const eyedb::Class *_cls, eyedb::Data _idr): BEMethod((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void BEMethod_OQL::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("be_method_OQL") : BEMethod_OQL_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

BEMethod_OQL::BEMethod_OQL(const BEMethod_OQL& x) : BEMethod(x)
{
  userCopy(x);
}

BEMethod_OQL& BEMethod_OQL::operator=(const BEMethod_OQL& x)
{
  *(BEMethod *)this = BEMethod::operator=((const BEMethod &)x);
  userCopy(x);
  return *this;
}

BEMethod_OQL::BEMethod_OQL(const eyedb::Struct *x, eyedb::Bool share) : BEMethod(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("be_method_OQL") : BEMethod_OQL_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

BEMethod_OQL::BEMethod_OQL(const BEMethod_OQL *x, eyedb::Bool share) : BEMethod(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("be_method_OQL") : BEMethod_OQL_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

static const eyedb::Attribute **Trigger_agritems;
static eyedb::Size Trigger_idr_objsz, Trigger_idr_psize;

static eyedb::StructClass *Trigger_make(eyedb::StructClass *Trigger_class = 0, eyedb::Schema *m = 0)
{
  if (!Trigger_class)
    return new eyedb::StructClass("trigger", (m ? m->getClass("agregat_class_executable") : AgregatClassExecutable_Class));
  eyedb::Attribute *attr[8];
  int *dims;

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("trigger_type") : TriggerType_Class), "type", eyedb::False, 0, dims);

  dims = 0;
  attr[6] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "light", eyedb::False, 0, dims);

  dims = new int[1];
  dims[0] = 16;
  attr[7] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "suffix", eyedb::False, 1, dims);
  delete[] dims;

  Trigger_class->setAttributes(&attr[5], 3);

  delete attr[5];
  delete attr[6];
  delete attr[7];

  eyedb::ClassPeer::setMType(Trigger_class, eyedb::Class::System);

  return Trigger_class;
}

eyedb::Object *Trigger_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Trigger(cls, idr);
}

eyedb::Object *Trigger_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Trigger((const eyedb::Struct *)o, share);
}

static void Trigger_init_p()
{
  Trigger_Class = Trigger_make();
  constructors_x[class_ind] = Trigger_construct_x;
  constructors[class_ind] = Trigger_construct;
  hash->insert("trigger", class_ind++);
}

static void Trigger_init()
{
  Trigger_make(Trigger_Class);

  Trigger_agritems = Trigger_Class->getAttributes();
  Trigger_idr_objsz = Trigger_Class->getIDRObjectSize(&Trigger_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Trigger_Class, eyedb::True);
}

static eyedb::Status Trigger_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "trigger.ex.exname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "trigger.ex.intname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

Trigger::Trigger(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : AgregatClassExecutable(_db, _dataspace, 1)
{
  initialize(_db);
}

Trigger::Trigger(const eyedb::Class *_cls, eyedb::Data _idr): AgregatClassExecutable((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Trigger::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("trigger") : Trigger_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Trigger::Trigger(const Trigger& x) : AgregatClassExecutable(x)
{
  userCopy(x);
}

Trigger& Trigger::operator=(const Trigger& x)
{
  *(AgregatClassExecutable *)this = AgregatClassExecutable::operator=((const AgregatClassExecutable &)x);
  userCopy(x);
  return *this;
}

Trigger::Trigger(const eyedb::Struct *x, eyedb::Bool share) : AgregatClassExecutable(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("trigger") : Trigger_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Trigger::Trigger(const Trigger *x, eyedb::Bool share) : AgregatClassExecutable(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("trigger") : Trigger_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Trigger::setType(TriggerType _type, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _type;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

TriggerType Trigger::getType(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (TriggerType)0;}
  return (TriggerType)__tmp;
}

eyedb::Status Trigger::setLight(eyedblib::int32 _light)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_light, 1, 0);
  return status;
}

eyedblib::int32 Trigger::getLight(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Trigger::setSuffix(const std::string &_suffix)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  unsigned char data[16];
  eyedb::Size len = _suffix.size();
  if (len >= 16)
    return eyedb::Exception::make(eyedb::IDB_ERROR, "string `%s' [%d] too long for attribute Trigger::suffix, maximum is 16\n", _suffix.c_str(), len);
  memset(data, 0, 16);
  strncpy((char *)data, _suffix.c_str(), min(15, len));
  status = getClass()->getAttributes()[7]->setValue(this, data, 16, 0);
  return status;

}

eyedb::Status Trigger::setSuffix(unsigned int a0, char _suffix)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  status = getClass()->getAttributes()[7]->setValue(this, (eyedb::Data)&_suffix, 1, from);
  return status;
}

std::string Trigger::getSuffix(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (const char *)data;
}

char Trigger::getSuffix(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[7]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **UniqueConstraint_agritems;
static eyedb::Size UniqueConstraint_idr_objsz, UniqueConstraint_idr_psize;

static eyedb::StructClass *UniqueConstraint_make(eyedb::StructClass *UniqueConstraint_class = 0, eyedb::Schema *m = 0)
{
  if (!UniqueConstraint_class)
    return new eyedb::StructClass("unique_constraint", (m ? m->getClass("attribute_component") : AttributeComponent_Class));
  eyedb::Attribute *attr[6];

  UniqueConstraint_class->setAttributes(&attr[6], 0);


  eyedb::ClassPeer::setMType(UniqueConstraint_class, eyedb::Class::System);

  return UniqueConstraint_class;
}

eyedb::Object *UniqueConstraint_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new UniqueConstraint(cls, idr);
}

eyedb::Object *UniqueConstraint_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new UniqueConstraint((const eyedb::Struct *)o, share);
}

static void UniqueConstraint_init_p()
{
  UniqueConstraint_Class = UniqueConstraint_make();
  constructors_x[class_ind] = UniqueConstraint_construct_x;
  constructors[class_ind] = UniqueConstraint_construct;
  hash->insert("unique_constraint", class_ind++);
}

static void UniqueConstraint_init()
{
  UniqueConstraint_make(UniqueConstraint_Class);

  UniqueConstraint_agritems = UniqueConstraint_Class->getAttributes();
  UniqueConstraint_idr_objsz = UniqueConstraint_Class->getIDRObjectSize(&UniqueConstraint_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(UniqueConstraint_Class, eyedb::True);
}

static eyedb::Status UniqueConstraint_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

UniqueConstraint::UniqueConstraint(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : AttributeComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

UniqueConstraint::UniqueConstraint(const eyedb::Class *_cls, eyedb::Data _idr): AttributeComponent((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void UniqueConstraint::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("unique_constraint") : UniqueConstraint_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

UniqueConstraint::UniqueConstraint(const UniqueConstraint& x) : AttributeComponent(x)
{
  userCopy(x);
}

UniqueConstraint& UniqueConstraint::operator=(const UniqueConstraint& x)
{
  *(AttributeComponent *)this = AttributeComponent::operator=((const AttributeComponent &)x);
  userCopy(x);
  return *this;
}

UniqueConstraint::UniqueConstraint(const eyedb::Struct *x, eyedb::Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("unique_constraint") : UniqueConstraint_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

UniqueConstraint::UniqueConstraint(const UniqueConstraint *x, eyedb::Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("unique_constraint") : UniqueConstraint_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

static const eyedb::Attribute **NotNullConstraint_agritems;
static eyedb::Size NotNullConstraint_idr_objsz, NotNullConstraint_idr_psize;

static eyedb::StructClass *NotNullConstraint_make(eyedb::StructClass *NotNullConstraint_class = 0, eyedb::Schema *m = 0)
{
  if (!NotNullConstraint_class)
    return new eyedb::StructClass("notnull_constraint", (m ? m->getClass("attribute_component") : AttributeComponent_Class));
  eyedb::Attribute *attr[6];

  NotNullConstraint_class->setAttributes(&attr[6], 0);


  eyedb::ClassPeer::setMType(NotNullConstraint_class, eyedb::Class::System);

  return NotNullConstraint_class;
}

eyedb::Object *NotNullConstraint_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new NotNullConstraint(cls, idr);
}

eyedb::Object *NotNullConstraint_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new NotNullConstraint((const eyedb::Struct *)o, share);
}

static void NotNullConstraint_init_p()
{
  NotNullConstraint_Class = NotNullConstraint_make();
  constructors_x[class_ind] = NotNullConstraint_construct_x;
  constructors[class_ind] = NotNullConstraint_construct;
  hash->insert("notnull_constraint", class_ind++);
}

static void NotNullConstraint_init()
{
  NotNullConstraint_make(NotNullConstraint_Class);

  NotNullConstraint_agritems = NotNullConstraint_Class->getAttributes();
  NotNullConstraint_idr_objsz = NotNullConstraint_Class->getIDRObjectSize(&NotNullConstraint_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(NotNullConstraint_Class, eyedb::True);
}

static eyedb::Status NotNullConstraint_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

NotNullConstraint::NotNullConstraint(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : AttributeComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

NotNullConstraint::NotNullConstraint(const eyedb::Class *_cls, eyedb::Data _idr): AttributeComponent((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void NotNullConstraint::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("notnull_constraint") : NotNullConstraint_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

NotNullConstraint::NotNullConstraint(const NotNullConstraint& x) : AttributeComponent(x)
{
  userCopy(x);
}

NotNullConstraint& NotNullConstraint::operator=(const NotNullConstraint& x)
{
  *(AttributeComponent *)this = AttributeComponent::operator=((const AttributeComponent &)x);
  userCopy(x);
  return *this;
}

NotNullConstraint::NotNullConstraint(const eyedb::Struct *x, eyedb::Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("notnull_constraint") : NotNullConstraint_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

NotNullConstraint::NotNullConstraint(const NotNullConstraint *x, eyedb::Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("notnull_constraint") : NotNullConstraint_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

static const eyedb::Attribute **CardinalityDescription_agritems;
static eyedb::Size CardinalityDescription_idr_objsz, CardinalityDescription_idr_psize;

static eyedb::StructClass *CardinalityDescription_make(eyedb::StructClass *CardinalityDescription_class = 0, eyedb::Schema *m = 0)
{
  if (!CardinalityDescription_class)
    return new eyedb::StructClass("cardinality_description", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[6];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "bottom", eyedb::False, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "bottom_excl", eyedb::False, 0, dims);

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "top", eyedb::False, 0, dims);

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "top_excl", eyedb::False, 0, dims);

  CardinalityDescription_class->setAttributes(&attr[2], 4);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];

  eyedb::ClassPeer::setMType(CardinalityDescription_class, eyedb::Class::System);

  return CardinalityDescription_class;
}

eyedb::Object *CardinalityDescription_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new CardinalityDescription(cls, idr);
}

eyedb::Object *CardinalityDescription_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new CardinalityDescription((const eyedb::Struct *)o, share);
}

static void CardinalityDescription_init_p()
{
  CardinalityDescription_Class = CardinalityDescription_make();
  constructors_x[class_ind] = CardinalityDescription_construct_x;
  constructors[class_ind] = CardinalityDescription_construct;
  hash->insert("cardinality_description", class_ind++);
}

static void CardinalityDescription_init()
{
  CardinalityDescription_make(CardinalityDescription_Class);

  CardinalityDescription_agritems = CardinalityDescription_Class->getAttributes();
  CardinalityDescription_idr_objsz = CardinalityDescription_Class->getIDRObjectSize(&CardinalityDescription_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(CardinalityDescription_Class, eyedb::True);
}

static eyedb::Status CardinalityDescription_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

CardinalityDescription::CardinalityDescription(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

CardinalityDescription::CardinalityDescription(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void CardinalityDescription::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("cardinality_description") : CardinalityDescription_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

CardinalityDescription::CardinalityDescription(const CardinalityDescription& x) : eyedb::Struct(x)
{
  userCopy(x);
}

CardinalityDescription& CardinalityDescription::operator=(const CardinalityDescription& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

CardinalityDescription::CardinalityDescription(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("cardinality_description") : CardinalityDescription_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

CardinalityDescription::CardinalityDescription(const CardinalityDescription *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("cardinality_description") : CardinalityDescription_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status CardinalityDescription::setBottom(eyedblib::int32 _bottom)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_bottom, 1, 0);
  return status;
}

eyedblib::int32 CardinalityDescription::getBottom(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status CardinalityDescription::setBottomExcl(eyedblib::int32 _bottom_excl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_bottom_excl, 1, 0);
  return status;
}

eyedblib::int32 CardinalityDescription::getBottomExcl(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status CardinalityDescription::setTop(eyedblib::int32 _top)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_top, 1, 0);
  return status;
}

eyedblib::int32 CardinalityDescription::getTop(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status CardinalityDescription::setTopExcl(eyedblib::int32 _top_excl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_top_excl, 1, 0);
  return status;
}

eyedblib::int32 CardinalityDescription::getTopExcl(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **CardinalityConstraint_agritems;
static eyedb::Size CardinalityConstraint_idr_objsz, CardinalityConstraint_idr_psize;

static eyedb::StructClass *CardinalityConstraint_make(eyedb::StructClass *CardinalityConstraint_class = 0, eyedb::Schema *m = 0)
{
  if (!CardinalityConstraint_class)
    return new eyedb::StructClass("cardinality_constraint", (m ? m->getClass("agregat_class_component") : AgregatClassComponent_Class));
  eyedb::Attribute *attr[6];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[4] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "attrname", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("cardinality_description") : CardinalityDescription_Class), "card_desc", eyedb::False, 0, dims);

  CardinalityConstraint_class->setAttributes(&attr[4], 2);

  delete attr[4];
  delete attr[5];

  eyedb::ClassPeer::setMType(CardinalityConstraint_class, eyedb::Class::System);

  return CardinalityConstraint_class;
}

eyedb::Object *CardinalityConstraint_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new CardinalityConstraint(cls, idr);
}

eyedb::Object *CardinalityConstraint_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new CardinalityConstraint((const eyedb::Struct *)o, share);
}

static void CardinalityConstraint_init_p()
{
  CardinalityConstraint_Class = CardinalityConstraint_make();
  constructors_x[class_ind] = CardinalityConstraint_construct_x;
  constructors[class_ind] = CardinalityConstraint_construct;
  hash->insert("cardinality_constraint", class_ind++);
}

static void CardinalityConstraint_init()
{
  CardinalityConstraint_make(CardinalityConstraint_Class);

  CardinalityConstraint_agritems = CardinalityConstraint_Class->getAttributes();
  CardinalityConstraint_idr_objsz = CardinalityConstraint_Class->getIDRObjectSize(&CardinalityConstraint_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(CardinalityConstraint_Class, eyedb::True);
}

static eyedb::Status CardinalityConstraint_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

CardinalityConstraint::CardinalityConstraint(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : AgregatClassComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

CardinalityConstraint::CardinalityConstraint(const eyedb::Class *_cls, eyedb::Data _idr): AgregatClassComponent((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void CardinalityConstraint::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("cardinality_constraint") : CardinalityConstraint_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

CardinalityConstraint::CardinalityConstraint(const CardinalityConstraint& x) : AgregatClassComponent(x)
{
  userCopy(x);
}

CardinalityConstraint& CardinalityConstraint::operator=(const CardinalityConstraint& x)
{
  *(AgregatClassComponent *)this = AgregatClassComponent::operator=((const AgregatClassComponent &)x);
  userCopy(x);
  return *this;
}

CardinalityConstraint::CardinalityConstraint(const eyedb::Struct *x, eyedb::Bool share) : AgregatClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("cardinality_constraint") : CardinalityConstraint_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

CardinalityConstraint::CardinalityConstraint(const CardinalityConstraint *x, eyedb::Bool share) : AgregatClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("cardinality_constraint") : CardinalityConstraint_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status CardinalityConstraint::setAttrname(const std::string &_attrname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _attrname.size() + 1;

  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[4]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)_attrname.c_str(), len, 0);
  return status;

}

eyedb::Status CardinalityConstraint::setAttrname(unsigned int a0, char _attrname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[4]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_attrname, 1, from);
  return status;
}

std::string CardinalityConstraint::getAttrname(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char CardinalityConstraint::getAttrname(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status CardinalityConstraint::setCardDesc(CardinalityDescription*_card_desc)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ocard_desc = _card_desc;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_ocard_desc, 1, 0);
  return status;
}

const CardinalityDescription*CardinalityConstraint::getCardDesc(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (CardinalityDescription *)__o;
     }
     __go = (CardinalityDescription *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (CardinalityDescription*)__o;
}

CardinalityDescription*CardinalityConstraint::getCardDesc(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (CardinalityDescription *)__o;
     }
     __go = (CardinalityDescription *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (CardinalityDescription*)__o;
}

static const eyedb::Attribute **CardinalityConstraint_Test_agritems;
static eyedb::Size CardinalityConstraint_Test_idr_objsz, CardinalityConstraint_Test_idr_psize;

static eyedb::StructClass *CardinalityConstraint_Test_make(eyedb::StructClass *CardinalityConstraint_Test_class = 0, eyedb::Schema *m = 0)
{
  if (!CardinalityConstraint_Test_class)
    return new eyedb::StructClass("cardinality_constraint_test", (m ? m->getClass("attribute_component") : AttributeComponent_Class));
  eyedb::Attribute *attr[7];
  int *dims;

  dims = 0;
  attr[6] = new eyedb::Attribute((m ? m->getClass("cardinality_description") : CardinalityDescription_Class), "card_desc", eyedb::False, 0, dims);

  CardinalityConstraint_Test_class->setAttributes(&attr[6], 1);

  delete attr[6];

  eyedb::ClassPeer::setMType(CardinalityConstraint_Test_class, eyedb::Class::System);

  return CardinalityConstraint_Test_class;
}

eyedb::Object *CardinalityConstraint_Test_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new CardinalityConstraint_Test(cls, idr);
}

eyedb::Object *CardinalityConstraint_Test_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new CardinalityConstraint_Test((const eyedb::Struct *)o, share);
}

static void CardinalityConstraint_Test_init_p()
{
  CardinalityConstraint_Test_Class = CardinalityConstraint_Test_make();
  constructors_x[class_ind] = CardinalityConstraint_Test_construct_x;
  constructors[class_ind] = CardinalityConstraint_Test_construct;
  hash->insert("cardinality_constraint_test", class_ind++);
}

static void CardinalityConstraint_Test_init()
{
  CardinalityConstraint_Test_make(CardinalityConstraint_Test_Class);

  CardinalityConstraint_Test_agritems = CardinalityConstraint_Test_Class->getAttributes();
  CardinalityConstraint_Test_idr_objsz = CardinalityConstraint_Test_Class->getIDRObjectSize(&CardinalityConstraint_Test_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(CardinalityConstraint_Test_Class, eyedb::True);
}

static eyedb::Status CardinalityConstraint_Test_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

CardinalityConstraint_Test::CardinalityConstraint_Test(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : AttributeComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

CardinalityConstraint_Test::CardinalityConstraint_Test(const eyedb::Class *_cls, eyedb::Data _idr): AttributeComponent((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void CardinalityConstraint_Test::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("cardinality_constraint_test") : CardinalityConstraint_Test_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

CardinalityConstraint_Test::CardinalityConstraint_Test(const CardinalityConstraint_Test& x) : AttributeComponent(x)
{
  userCopy(x);
}

CardinalityConstraint_Test& CardinalityConstraint_Test::operator=(const CardinalityConstraint_Test& x)
{
  *(AttributeComponent *)this = AttributeComponent::operator=((const AttributeComponent &)x);
  userCopy(x);
  return *this;
}

CardinalityConstraint_Test::CardinalityConstraint_Test(const eyedb::Struct *x, eyedb::Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("cardinality_constraint_test") : CardinalityConstraint_Test_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

CardinalityConstraint_Test::CardinalityConstraint_Test(const CardinalityConstraint_Test *x, eyedb::Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("cardinality_constraint_test") : CardinalityConstraint_Test_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status CardinalityConstraint_Test::setCardDesc(CardinalityDescription*_card_desc)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ocard_desc = _card_desc;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_ocard_desc, 1, 0);
  return status;
}

const CardinalityDescription*CardinalityConstraint_Test::getCardDesc(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (CardinalityDescription *)__o;
     }
     __go = (CardinalityDescription *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[6]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (CardinalityDescription*)__o;
}

CardinalityDescription*CardinalityConstraint_Test::getCardDesc(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (CardinalityDescription *)__o;
     }
     __go = (CardinalityDescription *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[6]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (CardinalityDescription*)__o;
}

static const eyedb::Attribute **ProtectionUser_agritems;
static eyedb::Size ProtectionUser_idr_objsz, ProtectionUser_idr_psize;

static eyedb::StructClass *ProtectionUser_make(eyedb::StructClass *ProtectionUser_class = 0, eyedb::Schema *m = 0)
{
  if (!ProtectionUser_class)
    return new eyedb::StructClass("protection_user", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("object") : eyedb::Object_Class), "user", eyedb::True, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("protection_mode") : ProtectionMode_Class), "mode", eyedb::False, 0, dims);

  ProtectionUser_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];

  eyedb::ClassPeer::setMType(ProtectionUser_class, eyedb::Class::System);

  return ProtectionUser_class;
}

eyedb::Object *ProtectionUser_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new ProtectionUser(cls, idr);
}

eyedb::Object *ProtectionUser_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new ProtectionUser((const eyedb::Struct *)o, share);
}

static void ProtectionUser_init_p()
{
  ProtectionUser_Class = ProtectionUser_make();
  constructors_x[class_ind] = ProtectionUser_construct_x;
  constructors[class_ind] = ProtectionUser_construct;
  hash->insert("protection_user", class_ind++);
}

static void ProtectionUser_init()
{
  ProtectionUser_make(ProtectionUser_Class);

  ProtectionUser_agritems = ProtectionUser_Class->getAttributes();
  ProtectionUser_idr_objsz = ProtectionUser_Class->getIDRObjectSize(&ProtectionUser_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ProtectionUser_Class, eyedb::True);
}

static eyedb::Status ProtectionUser_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

ProtectionUser::ProtectionUser(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

ProtectionUser::ProtectionUser(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void ProtectionUser::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("protection_user") : ProtectionUser_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

ProtectionUser::ProtectionUser(const ProtectionUser& x) : eyedb::Struct(x)
{
  userCopy(x);
}

ProtectionUser& ProtectionUser::operator=(const ProtectionUser& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

ProtectionUser::ProtectionUser(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("protection_user") : ProtectionUser_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

ProtectionUser::ProtectionUser(const ProtectionUser *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("protection_user") : ProtectionUser_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status ProtectionUser::setUser(eyedb::Object*_user)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ouser = _user;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_ouser, 1, 0);
  return status;
}

const eyedb::Object*ProtectionUser::getUser(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Object *)__o;
     }
     __go = (eyedb::Object *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Object*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Object *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Object*)__o;
}

eyedb::Object*ProtectionUser::getUser(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (eyedb::Object *)__o;
     }
     __go = (eyedb::Object *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (eyedb::Object*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (eyedb::Object *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (eyedb::Object*)__o;
}

eyedb::Status ProtectionUser::setUserOid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid ProtectionUser::getUserOid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status ProtectionUser::setMode(ProtectionMode _mode, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _mode;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

ProtectionMode ProtectionUser::getMode(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (ProtectionMode)0;}
  return (ProtectionMode)__tmp;
}

static const eyedb::Attribute **Protection_agritems;
static eyedb::Size Protection_idr_objsz, Protection_idr_psize;

static eyedb::StructClass *Protection_make(eyedb::StructClass *Protection_class = 0, eyedb::Schema *m = 0)
{
  if (!Protection_class)
    return new eyedb::StructClass("protection", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[5];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "name", eyedb::False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new eyedb::Attribute((m ? m->getClass("protection_user") : ProtectionUser_Class), "pusers", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("oid") : eyedb::OidP_Class), "poid", eyedb::False, 0, dims);

  Protection_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];

  eyedb::ClassPeer::setMType(Protection_class, eyedb::Class::System);

  return Protection_class;
}

eyedb::Object *Protection_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Protection(cls, idr);
}

eyedb::Object *Protection_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Protection((const eyedb::Struct *)o, share);
}

static void Protection_init_p()
{
  Protection_Class = Protection_make();
  constructors_x[class_ind] = Protection_construct_x;
  constructors[class_ind] = Protection_construct;
  hash->insert("protection", class_ind++);
}

static void Protection_init()
{
  Protection_make(Protection_Class);

  Protection_agritems = Protection_Class->getAttributes();
  Protection_idr_objsz = Protection_Class->getIDRObjectSize(&Protection_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Protection_Class, eyedb::True);
}

static eyedb::Status Protection_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

Protection::Protection(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

Protection::Protection(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Protection::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("protection") : Protection_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Protection::Protection(const Protection& x) : eyedb::Struct(x)
{
  userCopy(x);
}

Protection& Protection::operator=(const Protection& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

Protection::Protection(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("protection") : Protection_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Protection::Protection(const Protection *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("protection") : Protection_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Protection::setName(const std::string &_name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _name.size() + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)_name.c_str(), len, 0);
  return status;

}

eyedb::Status Protection::setName(unsigned int a0, char _name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_name, 1, from);
  return status;
}

std::string Protection::getName(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char Protection::getName(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Protection::setPusers(unsigned int a0, ProtectionUser*_pusers)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  eyedb::Object *_opusers = _pusers;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_opusers, 1, from);
  return status;
}

eyedb::Status Protection::setPusersCount(unsigned int a0)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;
  status = getClass()->getAttributes()[3]->setSize(this, from);
  return status;
}

const ProtectionUser*Protection::getPusers(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ProtectionUser *)__o;
     }
     __go = (ProtectionUser *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ProtectionUser*)__o;
}

ProtectionUser*Protection::getPusers(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ProtectionUser *)__o;
     }
     __go = (ProtectionUser *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ProtectionUser*)__o;
}

unsigned int Protection::getPusersCount(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Size size;
  eyedb::Status s;
  s = getClass()->getAttributes()[3]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

eyedb::Status Protection::setPoid(eyedb::Oid _poid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_poid, 1, 0);
  return status;
}

eyedb::Oid Protection::getPoid(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const eyedb::Attribute **UnreadableObject_agritems;
static eyedb::Size UnreadableObject_idr_objsz, UnreadableObject_idr_psize;

static eyedb::StructClass *UnreadableObject_make(eyedb::StructClass *UnreadableObject_class = 0, eyedb::Schema *m = 0)
{
  if (!UnreadableObject_class)
    return new eyedb::StructClass("unreadable_object", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[2];

  UnreadableObject_class->setAttributes(&attr[2], 0);


  eyedb::ClassPeer::setMType(UnreadableObject_class, eyedb::Class::System);

  return UnreadableObject_class;
}

eyedb::Object *UnreadableObject_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new UnreadableObject(cls, idr);
}

eyedb::Object *UnreadableObject_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new UnreadableObject((const eyedb::Struct *)o, share);
}

static void UnreadableObject_init_p()
{
  UnreadableObject_Class = UnreadableObject_make();
  constructors_x[class_ind] = UnreadableObject_construct_x;
  constructors[class_ind] = UnreadableObject_construct;
  hash->insert("unreadable_object", class_ind++);
}

static void UnreadableObject_init()
{
  UnreadableObject_make(UnreadableObject_Class);

  UnreadableObject_agritems = UnreadableObject_Class->getAttributes();
  UnreadableObject_idr_objsz = UnreadableObject_Class->getIDRObjectSize(&UnreadableObject_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(UnreadableObject_Class, eyedb::True);
}

static eyedb::Status UnreadableObject_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

UnreadableObject::UnreadableObject(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

UnreadableObject::UnreadableObject(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void UnreadableObject::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("unreadable_object") : UnreadableObject_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

UnreadableObject::UnreadableObject(const UnreadableObject& x) : eyedb::Struct(x)
{
  userCopy(x);
}

UnreadableObject& UnreadableObject::operator=(const UnreadableObject& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

UnreadableObject::UnreadableObject(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("unreadable_object") : UnreadableObject_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

UnreadableObject::UnreadableObject(const UnreadableObject *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("unreadable_object") : UnreadableObject_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

static const eyedb::Attribute **ClassConversion_agritems;
static eyedb::Size ClassConversion_idr_objsz, ClassConversion_idr_psize;

static eyedb::StructClass *ClassConversion_make(eyedb::StructClass *ClassConversion_class = 0, eyedb::Schema *m = 0)
{
  if (!ClassConversion_class)
    return new eyedb::StructClass("class_conversion", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[19];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("class_update_type") : ClassUpdateType_Class), "updtype", eyedb::False, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("attribute_convert_type") : AttributeConvertType_Class), "cnvtype", eyedb::False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[4] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "clsname", eyedb::False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[5] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "attrname", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[6] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "attrnum", eyedb::False, 0, dims);

  dims = 0;
  attr[7] = new eyedb::Attribute((m ? m->getClass("oid") : eyedb::OidP_Class), "oid_o", eyedb::False, 0, dims);

  dims = 0;
  attr[8] = new eyedb::Attribute((m ? m->getClass("oid") : eyedb::OidP_Class), "oid_n", eyedb::False, 0, dims);

  dims = 0;
  attr[9] = new eyedb::Attribute((m ? m->getClass("oid") : eyedb::OidP_Class), "roid_o", eyedb::False, 0, dims);

  dims = 0;
  attr[10] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "sync", eyedb::False, 0, dims);

  dims = 0;
  attr[11] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "with_check", eyedb::False, 0, dims);

  dims = 0;
  attr[12] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "src_dim", eyedb::False, 0, dims);

  dims = 0;
  attr[13] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "dest_dim", eyedb::False, 0, dims);

  dims = 0;
  attr[14] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "offset_o", eyedb::False, 0, dims);

  dims = 0;
  attr[15] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "offset_n", eyedb::False, 0, dims);

  dims = 0;
  attr[16] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "size_o", eyedb::False, 0, dims);

  dims = 0;
  attr[17] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "size_n", eyedb::False, 0, dims);

  dims = 0;
  attr[18] = new eyedb::Attribute((m ? m->getClass("be_method_C") : BEMethod_C_Class), "cnv_mth", eyedb::True, 0, dims);

  ClassConversion_class->setAttributes(&attr[2], 17);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];
  delete attr[6];
  delete attr[7];
  delete attr[8];
  delete attr[9];
  delete attr[10];
  delete attr[11];
  delete attr[12];
  delete attr[13];
  delete attr[14];
  delete attr[15];
  delete attr[16];
  delete attr[17];
  delete attr[18];

  eyedb::ClassPeer::setMType(ClassConversion_class, eyedb::Class::System);

  return ClassConversion_class;
}

eyedb::Object *ClassConversion_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new ClassConversion(cls, idr);
}

eyedb::Object *ClassConversion_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new ClassConversion((const eyedb::Struct *)o, share);
}

static void ClassConversion_init_p()
{
  ClassConversion_Class = ClassConversion_make();
  constructors_x[class_ind] = ClassConversion_construct_x;
  constructors[class_ind] = ClassConversion_construct;
  hash->insert("class_conversion", class_ind++);
}

static void ClassConversion_init()
{
  ClassConversion_make(ClassConversion_Class);

  ClassConversion_agritems = ClassConversion_Class->getAttributes();
  ClassConversion_idr_objsz = ClassConversion_Class->getIDRObjectSize(&ClassConversion_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ClassConversion_Class, eyedb::True);
}

static eyedb::Status ClassConversion_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "class_conversion.clsname", eyedb::False, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::BTreeIndex(db, cls, "class_conversion.oid_o", eyedb::False, eyedb::False, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::BTreeIndex(db, cls, "class_conversion.oid_n", eyedb::False, eyedb::False, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

ClassConversion::ClassConversion(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

ClassConversion::ClassConversion(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void ClassConversion::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("class_conversion") : ClassConversion_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

ClassConversion::ClassConversion(const ClassConversion& x) : eyedb::Struct(x)
{
  userCopy(x);
}

ClassConversion& ClassConversion::operator=(const ClassConversion& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

ClassConversion::ClassConversion(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("class_conversion") : ClassConversion_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

ClassConversion::ClassConversion(const ClassConversion *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("class_conversion") : ClassConversion_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status ClassConversion::setUpdtype(ClassUpdateType _updtype, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _updtype;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

ClassUpdateType ClassConversion::getUpdtype(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (ClassUpdateType)0;}
  return (ClassUpdateType)__tmp;
}

eyedb::Status ClassConversion::setCnvtype(AttributeConvertType _cnvtype, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _cnvtype;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

AttributeConvertType ClassConversion::getCnvtype(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (AttributeConvertType)0;}
  return (AttributeConvertType)__tmp;
}

eyedb::Status ClassConversion::setClsname(const std::string &_clsname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _clsname.size() + 1;

  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[4]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)_clsname.c_str(), len, 0);
  return status;

}

eyedb::Status ClassConversion::setClsname(unsigned int a0, char _clsname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[4]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_clsname, 1, from);
  return status;
}

std::string ClassConversion::getClsname(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char ClassConversion::getClsname(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ClassConversion::setAttrname(const std::string &_attrname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _attrname.size() + 1;

  status = getClass()->getAttributes()[5]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[5]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)_attrname.c_str(), len, 0);
  return status;

}

eyedb::Status ClassConversion::setAttrname(unsigned int a0, char _attrname)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[5]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[5]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_attrname, 1, from);
  return status;
}

std::string ClassConversion::getAttrname(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char ClassConversion::getAttrname(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ClassConversion::setAttrnum(eyedblib::int32 _attrnum)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_attrnum, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getAttrnum(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ClassConversion::setOidO(eyedb::Oid _oid_o)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[7]->setValue(this, (eyedb::Data)&_oid_o, 1, 0);
  return status;
}

eyedb::Oid ClassConversion::getOidO(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status ClassConversion::setOidN(eyedb::Oid _oid_n)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[8]->setValue(this, (eyedb::Data)&_oid_n, 1, 0);
  return status;
}

eyedb::Oid ClassConversion::getOidN(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[8]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status ClassConversion::setRoidO(eyedb::Oid _roid_o)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[9]->setValue(this, (eyedb::Data)&_roid_o, 1, 0);
  return status;
}

eyedb::Oid ClassConversion::getRoidO(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[9]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status ClassConversion::setSync(eyedblib::int32 _sync)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[10]->setValue(this, (eyedb::Data)&_sync, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getSync(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[10]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ClassConversion::setWithCheck(eyedblib::int32 _with_check)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[11]->setValue(this, (eyedb::Data)&_with_check, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getWithCheck(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[11]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ClassConversion::setSrcDim(eyedblib::int32 _src_dim)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[12]->setValue(this, (eyedb::Data)&_src_dim, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getSrcDim(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[12]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ClassConversion::setDestDim(eyedblib::int32 _dest_dim)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[13]->setValue(this, (eyedb::Data)&_dest_dim, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getDestDim(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[13]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ClassConversion::setOffsetO(eyedblib::int32 _offset_o)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[14]->setValue(this, (eyedb::Data)&_offset_o, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getOffsetO(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[14]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ClassConversion::setOffsetN(eyedblib::int32 _offset_n)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[15]->setValue(this, (eyedb::Data)&_offset_n, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getOffsetN(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[15]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ClassConversion::setSizeO(eyedblib::int32 _size_o)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[16]->setValue(this, (eyedb::Data)&_size_o, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getSizeO(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[16]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ClassConversion::setSizeN(eyedblib::int32 _size_n)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[17]->setValue(this, (eyedb::Data)&_size_n, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getSizeN(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[17]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ClassConversion::setCnvMth(BEMethod_C*_cnv_mth)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ocnv_mth = _cnv_mth;

  status = getClass()->getAttributes()[18]->setValue(this, (eyedb::Data)&_ocnv_mth, 1, 0);
  return status;
}

const BEMethod_C*ClassConversion::getCnvMth(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[18]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (BEMethod_C *)__o;
     }
     __go = (BEMethod_C *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[18]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (BEMethod_C*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[18]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (BEMethod_C *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[18]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (BEMethod_C*)__o;
}

BEMethod_C*ClassConversion::getCnvMth(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[18]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (BEMethod_C *)__o;
     }
     __go = (BEMethod_C *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[18]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (BEMethod_C*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[18]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (BEMethod_C *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[18]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (BEMethod_C*)__o;
}

eyedb::Status ClassConversion::setCnvMthOid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[18]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid ClassConversion::getCnvMthOid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[18]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static eyedb::CollSetClass *set_class_AttributeComponent_ref_make(eyedb::CollSetClass *cls = 0, eyedb::Schema *m = 0)
{
  if (!cls)
    {
      cls = new eyedb::CollSetClass((m ? m->getClass("attribute_component") : AttributeComponent_Class), eyedb::True);
      eyedb::ClassPeer::setMType(cls, eyedb::Class::System);
    }
  return cls;
}

static void set_class_AttributeComponent_ref_init_p()
{
  set_class_AttributeComponent_ref_Class = set_class_AttributeComponent_ref_make();
}

static const char not_exit_msg[] = "class does not exist";
static const char differ_msg[] = "class differs in database and in runtime environment";

void sysclsInit(void)
{
  if (hash) return;

  hash = new eyedb::GenHashTable(0, 105);

  IndexType_init_p();
  ExecutableLang_init_p();
  ArgType_Type_init_p();
  ExecutableLocalisation_init_p();
  ExecutableType_init_p();
  TriggerType_init_p();
  ProtectionMode_init_p();
  ClassUpdateType_init_p();
  AttributeConvertType_init_p();
  AttributeComponent_init_p();
  AttributeComponentSet_init_p();
  ClassComponent_init_p();
  AgregatClassComponent_init_p();
  ClassVariable_init_p();
  Index_init_p();
  HashIndex_init_p();
  BTreeIndex_init_p();
  CollAttrImpl_init_p();
  ArgType_init_p();
  Signature_init_p();
  Executable_init_p();
  AgregatClassExecutable_init_p();
  Method_init_p();
  FEMethod_init_p();
  FEMethod_C_init_p();
  BEMethod_init_p();
  BEMethod_C_init_p();
  BEMethod_OQL_init_p();
  Trigger_init_p();
  UniqueConstraint_init_p();
  NotNullConstraint_init_p();
  CardinalityDescription_init_p();
  CardinalityConstraint_init_p();
  CardinalityConstraint_Test_init_p();
  ProtectionUser_init_p();
  Protection_init_p();
  UnreadableObject_init_p();
  ClassConversion_init_p();
  set_class_AttributeComponent_ref_init_p();
  IndexType_init();
  ExecutableLang_init();
  ArgType_Type_init();
  ExecutableLocalisation_init();
  ExecutableType_init();
  TriggerType_init();
  ProtectionMode_init();
  ClassUpdateType_init();
  AttributeConvertType_init();
  AttributeComponent_init();
  AttributeComponentSet_init();
  ClassComponent_init();
  AgregatClassComponent_init();
  ClassVariable_init();
  Index_init();
  HashIndex_init();
  BTreeIndex_init();
  CollAttrImpl_init();
  ArgType_init();
  Signature_init();
  Executable_init();
  AgregatClassExecutable_init();
  Method_init();
  FEMethod_init();
  FEMethod_C_init();
  BEMethod_init();
  BEMethod_C_init();
  BEMethod_OQL_init();
  Trigger_init();
  UniqueConstraint_init();
  NotNullConstraint_init();
  CardinalityDescription_init();
  CardinalityConstraint_init();
  CardinalityConstraint_Test_init();
  ProtectionUser_init();
  Protection_init();
  UnreadableObject_init();
  ClassConversion_init();
}

void sysclsRelease(void)
{
  if (!hash) return;

  delete hash;
  hash = 0;

  IndexType_Class->release();
  ExecutableLang_Class->release();
  ArgType_Type_Class->release();
  ExecutableLocalisation_Class->release();
  ExecutableType_Class->release();
  TriggerType_Class->release();
  ProtectionMode_Class->release();
  ClassUpdateType_Class->release();
  AttributeConvertType_Class->release();
  AttributeComponent_Class->release();
  AttributeComponentSet_Class->release();
  ClassComponent_Class->release();
  AgregatClassComponent_Class->release();
  ClassVariable_Class->release();
  Index_Class->release();
  HashIndex_Class->release();
  BTreeIndex_Class->release();
  CollAttrImpl_Class->release();
  ArgType_Class->release();
  Signature_Class->release();
  Executable_Class->release();
  AgregatClassExecutable_Class->release();
  Method_Class->release();
  FEMethod_Class->release();
  FEMethod_C_Class->release();
  BEMethod_Class->release();
  BEMethod_C_Class->release();
  BEMethod_OQL_Class->release();
  Trigger_Class->release();
  UniqueConstraint_Class->release();
  NotNullConstraint_Class->release();
  CardinalityDescription_Class->release();
  CardinalityConstraint_Class->release();
  CardinalityConstraint_Test_Class->release();
  ProtectionUser_Class->release();
  Protection_Class->release();
  UnreadableObject_Class->release();
  ClassConversion_Class->release();
  set_class_AttributeComponent_ref_Class->release();
}

static eyedb::Status
sysclsSchemaUpdate(eyedb::Schema *m, eyedb::Database *db)
{
  m->setName("eyedb");
  eyedb::Status status;
  eyedb::EnumClass *IndexType_class = IndexType_make(0, m);
  if (!m->getClass("index_type"))
    {
      status = m->addClass(IndexType_class);
      if (status)
        return status;
    }
  eyedb::EnumClass *ExecutableLang_class = ExecutableLang_make(0, m);
  if (!m->getClass("executable_lang"))
    {
      status = m->addClass(ExecutableLang_class);
      if (status)
        return status;
    }
  eyedb::EnumClass *ArgType_Type_class = ArgType_Type_make(0, m);
  if (!m->getClass("argtype_type"))
    {
      status = m->addClass(ArgType_Type_class);
      if (status)
        return status;
    }
  eyedb::EnumClass *ExecutableLocalisation_class = ExecutableLocalisation_make(0, m);
  if (!m->getClass("executable_localisation"))
    {
      status = m->addClass(ExecutableLocalisation_class);
      if (status)
        return status;
    }
  eyedb::EnumClass *ExecutableType_class = ExecutableType_make(0, m);
  if (!m->getClass("executable_type"))
    {
      status = m->addClass(ExecutableType_class);
      if (status)
        return status;
    }
  eyedb::EnumClass *TriggerType_class = TriggerType_make(0, m);
  if (!m->getClass("trigger_type"))
    {
      status = m->addClass(TriggerType_class);
      if (status)
        return status;
    }
  eyedb::EnumClass *ProtectionMode_class = ProtectionMode_make(0, m);
  if (!m->getClass("protection_mode"))
    {
      status = m->addClass(ProtectionMode_class);
      if (status)
        return status;
    }
  eyedb::EnumClass *ClassUpdateType_class = ClassUpdateType_make(0, m);
  if (!m->getClass("class_update_type"))
    {
      status = m->addClass(ClassUpdateType_class);
      if (status)
        return status;
    }
  eyedb::EnumClass *AttributeConvertType_class = AttributeConvertType_make(0, m);
  if (!m->getClass("attribute_convert_type"))
    {
      status = m->addClass(AttributeConvertType_class);
      if (status)
        return status;
    }
  eyedb::StructClass *AttributeComponent_class = AttributeComponent_make(0, m);
  if (!m->getClass("attribute_component"))
    {
      status = m->addClass(AttributeComponent_class);
      if (status)
        return status;
    }
  eyedb::StructClass *AttributeComponentSet_class = AttributeComponentSet_make(0, m);
  if (!m->getClass("attribute_component_set"))
    {
      status = m->addClass(AttributeComponentSet_class);
      if (status)
        return status;
    }
  eyedb::StructClass *ClassComponent_class = ClassComponent_make(0, m);
  if (!m->getClass("class_component"))
    {
      status = m->addClass(ClassComponent_class);
      if (status)
        return status;
    }
  eyedb::StructClass *AgregatClassComponent_class = AgregatClassComponent_make(0, m);
  if (!m->getClass("agregat_class_component"))
    {
      status = m->addClass(AgregatClassComponent_class);
      if (status)
        return status;
    }
  eyedb::StructClass *ClassVariable_class = ClassVariable_make(0, m);
  if (!m->getClass("class_variable"))
    {
      status = m->addClass(ClassVariable_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Index_class = Index_make(0, m);
  if (!m->getClass("index"))
    {
      status = m->addClass(Index_class);
      if (status)
        return status;
    }
  eyedb::StructClass *HashIndex_class = HashIndex_make(0, m);
  if (!m->getClass("hashindex"))
    {
      status = m->addClass(HashIndex_class);
      if (status)
        return status;
    }
  eyedb::StructClass *BTreeIndex_class = BTreeIndex_make(0, m);
  if (!m->getClass("btreeindex"))
    {
      status = m->addClass(BTreeIndex_class);
      if (status)
        return status;
    }
  eyedb::StructClass *CollAttrImpl_class = CollAttrImpl_make(0, m);
  if (!m->getClass("collection_attribute_implementation"))
    {
      status = m->addClass(CollAttrImpl_class);
      if (status)
        return status;
    }
  eyedb::StructClass *ArgType_class = ArgType_make(0, m);
  if (!m->getClass("argtype"))
    {
      status = m->addClass(ArgType_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Signature_class = Signature_make(0, m);
  if (!m->getClass("signature"))
    {
      status = m->addClass(Signature_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Executable_class = Executable_make(0, m);
  if (!m->getClass("executable"))
    {
      status = m->addClass(Executable_class);
      if (status)
        return status;
    }
  eyedb::StructClass *AgregatClassExecutable_class = AgregatClassExecutable_make(0, m);
  if (!m->getClass("agregat_class_executable"))
    {
      status = m->addClass(AgregatClassExecutable_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Method_class = Method_make(0, m);
  if (!m->getClass("method"))
    {
      status = m->addClass(Method_class);
      if (status)
        return status;
    }
  eyedb::StructClass *FEMethod_class = FEMethod_make(0, m);
  if (!m->getClass("fe_method"))
    {
      status = m->addClass(FEMethod_class);
      if (status)
        return status;
    }
  eyedb::StructClass *FEMethod_C_class = FEMethod_C_make(0, m);
  if (!m->getClass("fe_method_C"))
    {
      status = m->addClass(FEMethod_C_class);
      if (status)
        return status;
    }
  eyedb::StructClass *BEMethod_class = BEMethod_make(0, m);
  if (!m->getClass("be_method"))
    {
      status = m->addClass(BEMethod_class);
      if (status)
        return status;
    }
  eyedb::StructClass *BEMethod_C_class = BEMethod_C_make(0, m);
  if (!m->getClass("be_method_C"))
    {
      status = m->addClass(BEMethod_C_class);
      if (status)
        return status;
    }
  eyedb::StructClass *BEMethod_OQL_class = BEMethod_OQL_make(0, m);
  if (!m->getClass("be_method_OQL"))
    {
      status = m->addClass(BEMethod_OQL_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Trigger_class = Trigger_make(0, m);
  if (!m->getClass("trigger"))
    {
      status = m->addClass(Trigger_class);
      if (status)
        return status;
    }
  eyedb::StructClass *UniqueConstraint_class = UniqueConstraint_make(0, m);
  if (!m->getClass("unique_constraint"))
    {
      status = m->addClass(UniqueConstraint_class);
      if (status)
        return status;
    }
  eyedb::StructClass *NotNullConstraint_class = NotNullConstraint_make(0, m);
  if (!m->getClass("notnull_constraint"))
    {
      status = m->addClass(NotNullConstraint_class);
      if (status)
        return status;
    }
  eyedb::StructClass *CardinalityDescription_class = CardinalityDescription_make(0, m);
  if (!m->getClass("cardinality_description"))
    {
      status = m->addClass(CardinalityDescription_class);
      if (status)
        return status;
    }
  eyedb::StructClass *CardinalityConstraint_class = CardinalityConstraint_make(0, m);
  if (!m->getClass("cardinality_constraint"))
    {
      status = m->addClass(CardinalityConstraint_class);
      if (status)
        return status;
    }
  eyedb::StructClass *CardinalityConstraint_Test_class = CardinalityConstraint_Test_make(0, m);
  if (!m->getClass("cardinality_constraint_test"))
    {
      status = m->addClass(CardinalityConstraint_Test_class);
      if (status)
        return status;
    }
  eyedb::StructClass *ProtectionUser_class = ProtectionUser_make(0, m);
  if (!m->getClass("protection_user"))
    {
      status = m->addClass(ProtectionUser_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Protection_class = Protection_make(0, m);
  if (!m->getClass("protection"))
    {
      status = m->addClass(Protection_class);
      if (status)
        return status;
    }
  eyedb::StructClass *UnreadableObject_class = UnreadableObject_make(0, m);
  if (!m->getClass("unreadable_object"))
    {
      status = m->addClass(UnreadableObject_class);
      if (status)
        return status;
    }
  eyedb::StructClass *ClassConversion_class = ClassConversion_make(0, m);
  if (!m->getClass("class_conversion"))
    {
      status = m->addClass(ClassConversion_class);
      if (status)
        return status;
    }
  eyedb::CollSetClass *set_class_AttributeComponent_ref_class = set_class_AttributeComponent_ref_make(0, m);
  if (!m->getClass("set<attribute_component*>"))
    {
      status = m->addClass(set_class_AttributeComponent_ref_class);
      if (status)
        return status;
    }

  IndexType_make(IndexType_class, m);
  ExecutableLang_make(ExecutableLang_class, m);
  ArgType_Type_make(ArgType_Type_class, m);
  ExecutableLocalisation_make(ExecutableLocalisation_class, m);
  ExecutableType_make(ExecutableType_class, m);
  TriggerType_make(TriggerType_class, m);
  ProtectionMode_make(ProtectionMode_class, m);
  ClassUpdateType_make(ClassUpdateType_class, m);
  AttributeConvertType_make(AttributeConvertType_class, m);
  AttributeComponent_make(AttributeComponent_class, m);
  AttributeComponentSet_make(AttributeComponentSet_class, m);
  ClassComponent_make(ClassComponent_class, m);
  AgregatClassComponent_make(AgregatClassComponent_class, m);
  ClassVariable_make(ClassVariable_class, m);
  Index_make(Index_class, m);
  HashIndex_make(HashIndex_class, m);
  BTreeIndex_make(BTreeIndex_class, m);
  CollAttrImpl_make(CollAttrImpl_class, m);
  ArgType_make(ArgType_class, m);
  Signature_make(Signature_class, m);
  Executable_make(Executable_class, m);
  AgregatClassExecutable_make(AgregatClassExecutable_class, m);
  Method_make(Method_class, m);
  FEMethod_make(FEMethod_class, m);
  FEMethod_C_make(FEMethod_C_class, m);
  BEMethod_make(BEMethod_class, m);
  BEMethod_C_make(BEMethod_C_class, m);
  BEMethod_OQL_make(BEMethod_OQL_class, m);
  Trigger_make(Trigger_class, m);
  UniqueConstraint_make(UniqueConstraint_class, m);
  NotNullConstraint_make(NotNullConstraint_class, m);
  CardinalityDescription_make(CardinalityDescription_class, m);
  CardinalityConstraint_make(CardinalityConstraint_class, m);
  CardinalityConstraint_Test_make(CardinalityConstraint_Test_class, m);
  ProtectionUser_make(ProtectionUser_class, m);
  Protection_make(Protection_class, m);
  UnreadableObject_make(UnreadableObject_class, m);
  ClassConversion_make(ClassConversion_class, m);

  if (!db) return eyedb::Success;

  if (!IndexType_class->compare(m->getClass("index_type")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'IndexType' %s", differ_msg);
  if (!ExecutableLang_class->compare(m->getClass("executable_lang")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ExecutableLang' %s", differ_msg);
  if (!ArgType_Type_class->compare(m->getClass("argtype_type")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ArgType_Type' %s", differ_msg);
  if (!ExecutableLocalisation_class->compare(m->getClass("executable_localisation")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ExecutableLocalisation' %s", differ_msg);
  if (!ExecutableType_class->compare(m->getClass("executable_type")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ExecutableType' %s", differ_msg);
  if (!TriggerType_class->compare(m->getClass("trigger_type")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'TriggerType' %s", differ_msg);
  if (!ProtectionMode_class->compare(m->getClass("protection_mode")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ProtectionMode' %s", differ_msg);
  if (!ClassUpdateType_class->compare(m->getClass("class_update_type")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ClassUpdateType' %s", differ_msg);
  if (!AttributeConvertType_class->compare(m->getClass("attribute_convert_type")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'AttributeConvertType' %s", differ_msg);
  if (!AttributeComponent_class->compare(m->getClass("attribute_component")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'AttributeComponent' %s", differ_msg);
  if (!AttributeComponentSet_class->compare(m->getClass("attribute_component_set")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'AttributeComponentSet' %s", differ_msg);
  if (!ClassComponent_class->compare(m->getClass("class_component")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ClassComponent' %s", differ_msg);
  if (!AgregatClassComponent_class->compare(m->getClass("agregat_class_component")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'AgregatClassComponent' %s", differ_msg);
  if (!ClassVariable_class->compare(m->getClass("class_variable")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ClassVariable' %s", differ_msg);
  if (!Index_class->compare(m->getClass("index")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Index' %s", differ_msg);
  if (!HashIndex_class->compare(m->getClass("hashindex")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'HashIndex' %s", differ_msg);
  if (!BTreeIndex_class->compare(m->getClass("btreeindex")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'BTreeIndex' %s", differ_msg);
  if (!CollAttrImpl_class->compare(m->getClass("collection_attribute_implementation")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'CollAttrImpl' %s", differ_msg);
  if (!ArgType_class->compare(m->getClass("argtype")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ArgType' %s", differ_msg);
  if (!Signature_class->compare(m->getClass("signature")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Signature' %s", differ_msg);
  if (!Executable_class->compare(m->getClass("executable")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Executable' %s", differ_msg);
  if (!AgregatClassExecutable_class->compare(m->getClass("agregat_class_executable")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'AgregatClassExecutable' %s", differ_msg);
  if (!Method_class->compare(m->getClass("method")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Method' %s", differ_msg);
  if (!FEMethod_class->compare(m->getClass("fe_method")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'FEMethod' %s", differ_msg);
  if (!FEMethod_C_class->compare(m->getClass("fe_method_C")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'FEMethod_C' %s", differ_msg);
  if (!BEMethod_class->compare(m->getClass("be_method")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'BEMethod' %s", differ_msg);
  if (!BEMethod_C_class->compare(m->getClass("be_method_C")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'BEMethod_C' %s", differ_msg);
  if (!BEMethod_OQL_class->compare(m->getClass("be_method_OQL")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'BEMethod_OQL' %s", differ_msg);
  if (!Trigger_class->compare(m->getClass("trigger")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Trigger' %s", differ_msg);
  if (!UniqueConstraint_class->compare(m->getClass("unique_constraint")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'UniqueConstraint' %s", differ_msg);
  if (!NotNullConstraint_class->compare(m->getClass("notnull_constraint")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'NotNullConstraint' %s", differ_msg);
  if (!CardinalityDescription_class->compare(m->getClass("cardinality_description")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'CardinalityDescription' %s", differ_msg);
  if (!CardinalityConstraint_class->compare(m->getClass("cardinality_constraint")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'CardinalityConstraint' %s", differ_msg);
  if (!CardinalityConstraint_Test_class->compare(m->getClass("cardinality_constraint_test")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'CardinalityConstraint_Test' %s", differ_msg);
  if (!ProtectionUser_class->compare(m->getClass("protection_user")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ProtectionUser' %s", differ_msg);
  if (!Protection_class->compare(m->getClass("protection")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Protection' %s", differ_msg);
  if (!UnreadableObject_class->compare(m->getClass("unreadable_object")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'UnreadableObject' %s", differ_msg);
  if (!ClassConversion_class->compare(m->getClass("class_conversion")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ClassConversion' %s", differ_msg);

  db->transactionBegin();

  if ((status = AttributeComponent_attrcomp_realize(db, m->getClass("attribute_component")))) return status;

  if ((status = AttributeComponentSet_attrcomp_realize(db, m->getClass("attribute_component_set")))) return status;

  if ((status = ClassComponent_attrcomp_realize(db, m->getClass("class_component")))) return status;

  if ((status = AgregatClassComponent_attrcomp_realize(db, m->getClass("agregat_class_component")))) return status;

  if ((status = ClassVariable_attrcomp_realize(db, m->getClass("class_variable")))) return status;

  if ((status = Index_attrcomp_realize(db, m->getClass("index")))) return status;

  if ((status = HashIndex_attrcomp_realize(db, m->getClass("hashindex")))) return status;

  if ((status = BTreeIndex_attrcomp_realize(db, m->getClass("btreeindex")))) return status;

  if ((status = CollAttrImpl_attrcomp_realize(db, m->getClass("collection_attribute_implementation")))) return status;

  if ((status = ArgType_attrcomp_realize(db, m->getClass("argtype")))) return status;

  if ((status = Signature_attrcomp_realize(db, m->getClass("signature")))) return status;

  if ((status = Executable_attrcomp_realize(db, m->getClass("executable")))) return status;

  if ((status = AgregatClassExecutable_attrcomp_realize(db, m->getClass("agregat_class_executable")))) return status;

  if ((status = Method_attrcomp_realize(db, m->getClass("method")))) return status;

  if ((status = FEMethod_attrcomp_realize(db, m->getClass("fe_method")))) return status;

  if ((status = FEMethod_C_attrcomp_realize(db, m->getClass("fe_method_C")))) return status;

  if ((status = BEMethod_attrcomp_realize(db, m->getClass("be_method")))) return status;

  if ((status = BEMethod_C_attrcomp_realize(db, m->getClass("be_method_C")))) return status;

  if ((status = BEMethod_OQL_attrcomp_realize(db, m->getClass("be_method_OQL")))) return status;

  if ((status = Trigger_attrcomp_realize(db, m->getClass("trigger")))) return status;

  if ((status = UniqueConstraint_attrcomp_realize(db, m->getClass("unique_constraint")))) return status;

  if ((status = NotNullConstraint_attrcomp_realize(db, m->getClass("notnull_constraint")))) return status;

  if ((status = CardinalityDescription_attrcomp_realize(db, m->getClass("cardinality_description")))) return status;

  if ((status = CardinalityConstraint_attrcomp_realize(db, m->getClass("cardinality_constraint")))) return status;

  if ((status = CardinalityConstraint_Test_attrcomp_realize(db, m->getClass("cardinality_constraint_test")))) return status;

  if ((status = ProtectionUser_attrcomp_realize(db, m->getClass("protection_user")))) return status;

  if ((status = Protection_attrcomp_realize(db, m->getClass("protection")))) return status;

  if ((status = UnreadableObject_attrcomp_realize(db, m->getClass("unreadable_object")))) return status;

  if ((status = ClassConversion_attrcomp_realize(db, m->getClass("class_conversion")))) return status;
  status = m->realize();
  if (status) return status;
  db->transactionCommit();
  return eyedb::Success;
}

eyedb::Status sysclsSchemaUpdate(eyedb::Database *db)
{
  return sysclsSchemaUpdate(db->getSchema(), db);
}

eyedb::Status sysclsSchemaUpdate(eyedb::Schema *m)
{
  return sysclsSchemaUpdate(m, NULL);
}

eyedb::Object *sysclsMakeObject(eyedb::Object *o, eyedb::Bool remove)
{
  if (!o->getClass()) return (eyedb::Object *)0;
  if (eyedb::ObjectPeer::isGRTObject(o))
    return o;
  int ind = hash->get(o->getClass()->getName());
  if (ind < 0 && (!o->getClass()->getStrictAliasName() || (ind = hash->get(o->getClass()->getStrictAliasName())) < 0)) return 0;
  eyedb::Object *co = constructors[ind](o, (remove ? eyedb::True : eyedb::False));
  eyedb::ObjectPeer::setClass(co, o->getClass());
  if (remove) o->release();
  if (co->getDatabase())
    co->getDatabase()->cacheObject(co);
  return co;
}

sysclsDatabase::sysclsDatabase(eyedb::Connection *conn, const char *dbname, eyedb::Database::OpenFlag flag, const char *userauth, const char *passwdauth) : eyedb::Database(dbname)
{
  eyedb::Status status = open(conn, flag, 0, userauth, passwdauth);
  if (status) throw *status;
}

sysclsDatabase::sysclsDatabase(eyedb::Connection *conn, const char *dbname, const char *dbmdb_str, eyedb::Database::OpenFlag flag, const char *userauth, const char *passwdauth) : eyedb::Database(dbname, dbmdb_str)
{
  eyedb::Status status = open(conn, flag, 0, userauth, passwdauth);
  if (status) throw *status;
}

eyedb::Status sysclsDatabase::open(eyedb::Connection *conn, eyedb::Database::OpenFlag flag, const char *userauth, const char *passwdauth)
{
  return open(conn, flag, 0, userauth, passwdauth);
}

eyedb::Status sysclsDatabase::open(eyedb::Connection *conn, eyedb::Database::OpenFlag flag, const eyedb::OpenHints *hints, const char *userauth, const char *passwdauth)
{
  eyedb::Status status = eyedb::Database::open(conn, flag, hints, userauth, passwdauth);
  if (status) return status;
  transactionBegin();
  status = sysclsDatabase::checkSchema(getSchema());
  transactionCommit();

  if (!status) add(hash, constructors_x);

  return status;
}

void sysclsDatabase::setConsApp(eyedb::Database *_db)
{
  _db->add(hash, constructors_x);
}

static void append(char *&s, const char *m1, const char *m2)
{
  if (!s) {s = (char *)malloc(strlen(m1)+strlen(m2)+2); *s = 0;}
  else s = (char *)realloc(s, strlen(s)+strlen(m1)+strlen(m2)+2);
  strcat(s, m1);
  strcat(s, m2);
  strcat(s, "\n");
}

eyedb::Bool sysclsDatabase::getDynamicGetErrorPolicy() {
   throw *eyedb::Exception::make(eyedb::IDB_ERROR, "getDynamicGetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

eyedb::Bool sysclsDatabase::getDynamicSetErrorPolicy() {
   throw *eyedb::Exception::make(eyedb::IDB_ERROR, "getDynamicSetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

void sysclsDatabase::setDynamicGetErrorPolicy(eyedb::Bool policy) {
   throw *eyedb::Exception::make(eyedb::IDB_ERROR, "setDynamicGetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

void sysclsDatabase::setDynamicSetErrorPolicy(eyedb::Bool policy) {
   throw *eyedb::Exception::make(eyedb::IDB_ERROR, "setDynamicSetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

eyedb::Status sysclsDatabase::checkSchema(eyedb::Schema *m)
{
  eyedb::Class *cl;
  char *s = 0;

  if (!(cl = m->getClass("index_type")))
    append(s, "'index_type' ", not_exit_msg);
  else if (!IndexType_Class->compare(cl))
    append(s, "'IndexType' ", differ_msg);
  if (!(cl = m->getClass("executable_lang")))
    append(s, "'executable_lang' ", not_exit_msg);
  else if (!ExecutableLang_Class->compare(cl))
    append(s, "'ExecutableLang' ", differ_msg);
  if (!(cl = m->getClass("argtype_type")))
    append(s, "'argtype_type' ", not_exit_msg);
  else if (!ArgType_Type_Class->compare(cl))
    append(s, "'ArgType_Type' ", differ_msg);
  if (!(cl = m->getClass("executable_localisation")))
    append(s, "'executable_localisation' ", not_exit_msg);
  else if (!ExecutableLocalisation_Class->compare(cl))
    append(s, "'ExecutableLocalisation' ", differ_msg);
  if (!(cl = m->getClass("executable_type")))
    append(s, "'executable_type' ", not_exit_msg);
  else if (!ExecutableType_Class->compare(cl))
    append(s, "'ExecutableType' ", differ_msg);
  if (!(cl = m->getClass("trigger_type")))
    append(s, "'trigger_type' ", not_exit_msg);
  else if (!TriggerType_Class->compare(cl))
    append(s, "'TriggerType' ", differ_msg);
  if (!(cl = m->getClass("protection_mode")))
    append(s, "'protection_mode' ", not_exit_msg);
  else if (!ProtectionMode_Class->compare(cl))
    append(s, "'ProtectionMode' ", differ_msg);
  if (!(cl = m->getClass("class_update_type")))
    append(s, "'class_update_type' ", not_exit_msg);
  else if (!ClassUpdateType_Class->compare(cl))
    append(s, "'ClassUpdateType' ", differ_msg);
  if (!(cl = m->getClass("attribute_convert_type")))
    append(s, "'attribute_convert_type' ", not_exit_msg);
  else if (!AttributeConvertType_Class->compare(cl))
    append(s, "'AttributeConvertType' ", differ_msg);
  if (!(cl = m->getClass("attribute_component")))
    append(s, "'attribute_component' ", not_exit_msg);
  else if (!AttributeComponent_Class->compare(cl))
    append(s, "'AttributeComponent' ", differ_msg);
  if (!(cl = m->getClass("attribute_component_set")))
    append(s, "'attribute_component_set' ", not_exit_msg);
  else if (!AttributeComponentSet_Class->compare(cl))
    append(s, "'AttributeComponentSet' ", differ_msg);
  if (!(cl = m->getClass("class_component")))
    append(s, "'class_component' ", not_exit_msg);
  else if (!ClassComponent_Class->compare(cl))
    append(s, "'ClassComponent' ", differ_msg);
  if (!(cl = m->getClass("agregat_class_component")))
    append(s, "'agregat_class_component' ", not_exit_msg);
  else if (!AgregatClassComponent_Class->compare(cl))
    append(s, "'AgregatClassComponent' ", differ_msg);
  if (!(cl = m->getClass("class_variable")))
    append(s, "'class_variable' ", not_exit_msg);
  else if (!ClassVariable_Class->compare(cl))
    append(s, "'ClassVariable' ", differ_msg);
  if (!(cl = m->getClass("index")))
    append(s, "'index' ", not_exit_msg);
  else if (!Index_Class->compare(cl))
    append(s, "'Index' ", differ_msg);
  if (!(cl = m->getClass("hashindex")))
    append(s, "'hashindex' ", not_exit_msg);
  else if (!HashIndex_Class->compare(cl))
    append(s, "'HashIndex' ", differ_msg);
  if (!(cl = m->getClass("btreeindex")))
    append(s, "'btreeindex' ", not_exit_msg);
  else if (!BTreeIndex_Class->compare(cl))
    append(s, "'BTreeIndex' ", differ_msg);
  if (!(cl = m->getClass("collection_attribute_implementation")))
    append(s, "'collection_attribute_implementation' ", not_exit_msg);
  else if (!CollAttrImpl_Class->compare(cl))
    append(s, "'CollAttrImpl' ", differ_msg);
  if (!(cl = m->getClass("argtype")))
    append(s, "'argtype' ", not_exit_msg);
  else if (!ArgType_Class->compare(cl))
    append(s, "'ArgType' ", differ_msg);
  if (!(cl = m->getClass("signature")))
    append(s, "'signature' ", not_exit_msg);
  else if (!Signature_Class->compare(cl))
    append(s, "'Signature' ", differ_msg);
  if (!(cl = m->getClass("executable")))
    append(s, "'executable' ", not_exit_msg);
  else if (!Executable_Class->compare(cl))
    append(s, "'Executable' ", differ_msg);
  if (!(cl = m->getClass("agregat_class_executable")))
    append(s, "'agregat_class_executable' ", not_exit_msg);
  else if (!AgregatClassExecutable_Class->compare(cl))
    append(s, "'AgregatClassExecutable' ", differ_msg);
  if (!(cl = m->getClass("method")))
    append(s, "'method' ", not_exit_msg);
  else if (!Method_Class->compare(cl))
    append(s, "'Method' ", differ_msg);
  if (!(cl = m->getClass("fe_method")))
    append(s, "'fe_method' ", not_exit_msg);
  else if (!FEMethod_Class->compare(cl))
    append(s, "'FEMethod' ", differ_msg);
  if (!(cl = m->getClass("fe_method_C")))
    append(s, "'fe_method_C' ", not_exit_msg);
  else if (!FEMethod_C_Class->compare(cl))
    append(s, "'FEMethod_C' ", differ_msg);
  if (!(cl = m->getClass("be_method")))
    append(s, "'be_method' ", not_exit_msg);
  else if (!BEMethod_Class->compare(cl))
    append(s, "'BEMethod' ", differ_msg);
  if (!(cl = m->getClass("be_method_C")))
    append(s, "'be_method_C' ", not_exit_msg);
  else if (!BEMethod_C_Class->compare(cl))
    append(s, "'BEMethod_C' ", differ_msg);
  if (!(cl = m->getClass("be_method_OQL")))
    append(s, "'be_method_OQL' ", not_exit_msg);
  else if (!BEMethod_OQL_Class->compare(cl))
    append(s, "'BEMethod_OQL' ", differ_msg);
  if (!(cl = m->getClass("trigger")))
    append(s, "'trigger' ", not_exit_msg);
  else if (!Trigger_Class->compare(cl))
    append(s, "'Trigger' ", differ_msg);
  if (!(cl = m->getClass("unique_constraint")))
    append(s, "'unique_constraint' ", not_exit_msg);
  else if (!UniqueConstraint_Class->compare(cl))
    append(s, "'UniqueConstraint' ", differ_msg);
  if (!(cl = m->getClass("notnull_constraint")))
    append(s, "'notnull_constraint' ", not_exit_msg);
  else if (!NotNullConstraint_Class->compare(cl))
    append(s, "'NotNullConstraint' ", differ_msg);
  if (!(cl = m->getClass("cardinality_description")))
    append(s, "'cardinality_description' ", not_exit_msg);
  else if (!CardinalityDescription_Class->compare(cl))
    append(s, "'CardinalityDescription' ", differ_msg);
  if (!(cl = m->getClass("cardinality_constraint")))
    append(s, "'cardinality_constraint' ", not_exit_msg);
  else if (!CardinalityConstraint_Class->compare(cl))
    append(s, "'CardinalityConstraint' ", differ_msg);
  if (!(cl = m->getClass("cardinality_constraint_test")))
    append(s, "'cardinality_constraint_test' ", not_exit_msg);
  else if (!CardinalityConstraint_Test_Class->compare(cl))
    append(s, "'CardinalityConstraint_Test' ", differ_msg);
  if (!(cl = m->getClass("protection_user")))
    append(s, "'protection_user' ", not_exit_msg);
  else if (!ProtectionUser_Class->compare(cl))
    append(s, "'ProtectionUser' ", differ_msg);
  if (!(cl = m->getClass("protection")))
    append(s, "'protection' ", not_exit_msg);
  else if (!Protection_Class->compare(cl))
    append(s, "'Protection' ", differ_msg);
  if (!(cl = m->getClass("unreadable_object")))
    append(s, "'unreadable_object' ", not_exit_msg);
  else if (!UnreadableObject_Class->compare(cl))
    append(s, "'UnreadableObject' ", differ_msg);
  if (!(cl = m->getClass("class_conversion")))
    append(s, "'class_conversion' ", not_exit_msg);
  else if (!ClassConversion_Class->compare(cl))
    append(s, "'ClassConversion' ", differ_msg);
  if (s) {eyedb::Status status = eyedb::Exception::make(s); free(s); return status;}
  return eyedb::Success;
}

eyedb::Bool syscls_set_oid_check(eyedb::Bool _oid_check)
{
  eyedb::Bool old = oid_check;
  oid_check = _oid_check;
  return old;
}

eyedb::Bool syscls_get_oid_check()
{
  return oid_check;
}

}
