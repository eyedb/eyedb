\input{start}
\input{version}
\newcommand{\mantitle}{\textsc{Object Query Language}}
\input{title}

\tableofcontents

\chapter*{The Object Query Language}
\newcommand{\ex}{\emph{expr} }
\newcommand{\oqlsect}[1]{Section \ref{#1}}
\newcommand{\bin}[1]{\ex\texttt{#1} \ex}
\newcommand{\ass}[1]{\emph{lvalue} \texttt{#1} \ex}
\newcommand{\una}[1]{\texttt{#1} \ex}
\newcommand{\unar}[1]{\ex \texttt{#1}}
\newcommand{\ide}{\emph{identifier} }
\newcommand{\unide}[1]{\texttt{#1} \emph{identifier}}

\newcommand{\xtab}{longtable}
%\newcommand{\btab}{\\\begin{tabular}}
%\newcommand{\etab}{\end{tabular}}
\newcommand{\btab}{\\\begin{longtable}}
\newcommand{\etab}{\end{longtable}}
\newcommand{\dimtab}{|p{3cm}|p{4cm}|}
\newcommand{\dimtabx}{|p{3cm}|p{5cm}|}

\newcommand{\rerr}{\emph{raises an error}}
\newcommand{\Cidem}{expression syntax, semantics, associativity
and precedence are quite identical to the corresponding C and C++ expressions}.
\newcommand{\geninfo}{\hline \multicolumn{2}{|c|}{\emph{General Information}}}
\newcommand{\expex}[1]{\hline \multicolumn{#1}{|c|}{\emph{Expression Examples}}}
\newcommand{\poscomb}[1]{\hline \multicolumn{#1}{|c|}{\emph{Possible Operand Combinations}}}
\newcommand{\bettabx}{\mbox{ }\\\\\mbox{ }\\}
\newcommand{\bettab}{\mbox{}}

\sect{Introduction}
In this chapter, we present the \eyedb Object Query Language which supports
the \eyedb object model. It is based on the ODMG 3 Object Query Language
OQL.
\\
\\
We first describe the design principles of the language in
\oqlsect{principles}, then
we present in \oqlsect{diffoql} the main differences between \eyedb
OQL and ODMG OQL.
The language concepts are presented in \oqlsect{lconcepts}.
In \oqlsect{lsyntax}, we introduced the language syntax.
%The general language definition is presented in \oqlsect{lconcepts}.
%In \oqlsect{} we introduce all the expression forms including the
%query expressions. We present the selection statements in \oqlsect{6}.
%In \oqlsect{7} we describe the iteration statements.
%We introduce the function statements in \oqlsect{8}, the builtin and
%library functions in \oqlsect{9} and finally the \texttt{eyedboql} tool
%in \oqlsect{10}.
A quick reference manual of OQL is given in \oqlsect{qref}.
\\
\\
In this chapter, OQL denotes the \eyedb Object Query Language while
the standard ODMG 3 Object Query Language will be denoted as ODMG OQL.

\sect{Principles}
\label{principles}
The principles of OQL are close to the principles of ODMG OQL introduced
in the book \emph{Object Database Standard, ODMG 3} by Rick Cattell and al.
\\
\\
Our design is based on the following principles and assumptions:
\bi
\item OQL relies on the \eyedb Object Model.
\item OQL is based on ODMG OQL close to SQL 92. Extensions to SQL 92
concern object-oriented notions, like complex objects, object identify,
path expressions, polymorphim, operation invocation and late binding.
Extensions to ODMG OQL concern function definitions, selection statements,
iteration statement, assignment operator (see \oqlsect{diffoql}).
\item OQL provides high level primitives to deal with sets of objects,
structures, lists and arrays.
\item OQL is a functional language where operators can freely be composed as
long as the operands respect the type system.
\item OQL is computationally complete.
\item OQL can be invoked from within programming languages for which an
\eyedb binding is defined (currently C++ and Java).
Conversely, OQL can invoke operations programmed in this language.
\ei

\sect{OQL vs. ODMG 3 OQL}
\label{diffoql}
OQL implements all the ODMG OQL functionalities with a few exceptions
concerning the \texttt{select} clause.
In order to accept the whole DML (Data Manipulation Language) query part of
SQL as a valid syntax for ODMG OQL, ad-hoc constructions have been
added to ODMG OQL each time SQL introduces a syntax that cannot be
considered in the category of true operators.
\\
\\
For instance, the following construct is a valid ODMG OQL construct:
\verbsize
\begin{verbatim}
select p.name, salary from Professors p
\end{verbatim}
\normalsize
This construct is not currently a valid OQL construct. The alternate valid
OQL form is:
\verbsize
\begin{verbatim}
select struct(name: p.name, salary: p.salary) from Professors p
\end{verbatim}
\normalsize
In the same way, ODMG OQL accepts SQL forms of the agregate operators
\texttt{min, max, count, sum} and \texttt{avg}, for instance:
\verbsize
\begin{verbatim}
select count(*) from Persons
select max(e.salary) from Employees e
\end{verbatim}
\normalsize
These constructs are not currently valid OQL constructs. The alternate valid
OQL forms are:
\begin{verbatim}
count(select p from Persons p)
max(select e.salary from Employees e)
\end{verbatim}
\normalsize
In the same way, the \texttt{select *} clause is not currently implemented
in OQL, neither the implicit \texttt{select} clause (i.e. without explicit
identifier). For instance, the following constructs are not OQL valid
constructs, although there are valid ODMG OQL constructs:
\begin{verbatim}
select * from Person
select name from Person
\end{verbatim}
\normalsize
There is no alternate OQL valid form for the first construct.
The alternate OQL valid forms for the second construct is:
\begin{verbatim}
select Person.name
select p.name from Person p
select p.name from Person as p
select p.name from p in Person
\end{verbatim}
\normalsize
On the other hand, OQL provides a few extensions to ODMG OQL:
\\
\\
\ixy - assignment operators,\\
\ixy - four regular expression operators,\\
\ixy - selection statements, \texttt{if/else},\\
\ixy - iteration statements, \texttt{while}, \texttt{do/while}, two forms
of \texttt{for}, \\
\ixy - function definition statements, \texttt{function},\\
\ixy - the \texttt{eval} and \texttt{unval} operators,\\
\ixy - identifier operators, \texttt{isset}, \texttt{unset},
\texttt{refof}, \texttt{valof}, \texttt{\&}, \texttt{*}, \texttt{push},
\texttt{pop}, \\
\ixy - exception management operators, \texttt{throw},\\
\ixy - type information operators, \texttt{classof}, \texttt{typeof}\\
\ixy - miscellaneous operators, \texttt{structof}, \texttt{bodyof}\\
\ixy - builtin and library functions.\\
\\
For instance, the following constructs are valid OQL constructs:
\begin{verbatim}
for (x in l)
{
  if (classof x != "Person")
    throw "Person type expected";
  if (x->name ~ "^john")
  {
     ok := true;
     break;
  }
}

function fib(n) {
  if (n < 2)
     return n;
  return fib(n-1) + fib(n-2);
}

for (n := 0, v := 0; n < 15; n++)
  v += fib(n);

function swap(x, y) {
   v := *x;
   *x := *y;
   *y := v;
}

i := "ii"; j := "jj";
swap(&i, &j);

function get_from(classname, attrname) {
   return eval "select x." + attrname + " from " + classname + " x";
}

names := get_from("Person", "name");
\end{verbatim}
\normalsize
These extensions make OQL computationally complete. 
\\
\\
Some of the ODMG OQL functionnalities or specificities are not yet implemented:
\be
\item the \texttt{group by/having} operator,
\item the \texttt{order by} operator is more restrictive than in the
ODMG specifications,
\item contrary to ODMG OQL, it is necessary to put parenthesis to call
a function or method with takes no arguments,
\item contrary to ODMG OQL, the \texttt{||} operator does means string
concatenation. It is the logical or operator. This will be changed
in a future version.
\ee
\sect{Language Concepts}
\label{lconcepts}
The basic entity in OQL is the atom. An atom is the result of the
evaluation of any expression. Atoms are manipulated through expressions.
\\
\\
Although OQL is not fully an expression language as some valid constructs, such
as flow controls, are not expressions, the expression is the basic
concept of OQL.
The non-expression constructs, such as selection and iteration statements,
control the flow (or evaluation) of expressions.
An expression is built from typed operands composed recursively by operators.
\\
\\
OQL is a typed language: each atom has a type. This type
can be an OQL builtin type or can be derived from the schema type
declarations.
\\
\\
OQL binds the \eyedb object model by providing a mapping between OQL builtin
types and the \eyedb object model types. As in the \eyedb object model,
OQL supports both object entities (with a unique object identifier)
and literal entities (with no identifier).
The concept of object/literal is orthogonal to the concept of type, this
means that any type may have object instances and literal instances.
For instance, one can have literal or object integers, literal or
object collections.
%Some atoms are generated by the query language interpreter, others are
%produced from the database.
For instance, the following constructs produces a literal integer:
\verbsize
\begin{verbatim}
1; // OQL interpreter generates a literal integer
first(select x.age from Person x); // database produces a literal integer
                                   // bound to an atom of type integer
\end{verbatim}
\normalsize
while the followings produce respectively a \texttt{Person} object and
a literal collection of \texttt{Person} objects:
\verbsize
\begin{verbatim}
first(select x from Person x);
select x from Person x;
\end{verbatim}
\normalsize
An \eyedb object is always bound
in OQL to an atom of type \texttt{oid} or of type \texttt{object}.
A literal is bound to the corresponding direct type in OQL using a trivial
mapping. For instance, a literal entity of the \eyedb type \texttt{integer}
is bound to an OQL atom of the OQL type \texttt{integer}; while an
object entity of the \eyedb type \texttt{Person} is bound to an OQL atom
of type \texttt{oid} or \texttt{object}.
\\
\\
We introduce now the OQL builtin types and the way that they are generated.
%As introduced previously, each atom has a type.
OQL includes 15 builtin types as follows:\\
\ixy - \texttt{integer}\\
\ixy - \texttt{string}\\
\ixy - \texttt{float}\\
\ixy - \texttt{char}\\
\ixy - \texttt{boolean}\\
\ixy - \texttt{identifier}\\
\ixy - \texttt{set}\\
\ixy - \texttt{bag}\\
\ixy - \texttt{array}\\
\ixy - \texttt{list}\\
\ixy - \texttt{struct}\\
\ixy - \texttt{oid}\\
\ixy - \texttt{object}\\
\ixy - \texttt{null}\\
\ixy - \texttt{nil}\\
\\
Some of these atoms can be expressed as terminals of the OQL grammar - for
instance \texttt{integer}, \texttt{float}, \texttt{string} - others are
generated using syntaxic constructions such as function calls or specific
constructions - for instance \texttt{list}, \texttt{bag}, \texttt{struct}.
\\
\\
We will introduced first the syntax of the atoms which can be expressed
as terminals, then the way to produce non terminal atoms.

\sect{Language Syntax}
\label{lsyntax}
\subsect{Terminal Atom Syntax}
\label{termatoms}
To express the syntax of terminal atoms, we use the standard
regular expression notation.
\subsubsect{Integer Atom}
Integers are coded on 64 bits.\\
The syntax for the integer type is one of the followings:
\begin{tabbing}
\texttt{0x[0-9a-fA-F]+} \mbox{ } \= \emph{hexadecimal} \kill
\texttt{[0-9]+} \> \emph{decimal base}\\
\texttt{0x[0-9a-fA-F]+} \> \emph{hexadecimal}\\
\texttt{0[0-7]+} \> \emph{octal}\\
\end{tabbing}
The domain for the integer type is as follows:
\btab[l]{|p{4cm}|p{4cm}|}
\hline  \emph{Minimal Value} & \emph{Maximal Value}\\
\hline -9223372036854775808 & 9223372036854775807\\
\hline
\etab
A few examples:
\verbsize
\begin{verbatim}
13940     // integer expressed in the decimal base
0x273f1   // integer expressed in the hexadecimal base
0x273F1   // integer expressed in the hexadecimal base
0100      // integer expressed in the octal base
\end{verbatim}
\normalsize
\subsubsect{Float Atom}
The syntax for floating point atoms is one of the following regular
expressions:\\\\
\texttt{[0-9]+{\textbackslash}.[0-9]+?}\\
\texttt{[0-9]+?{\textbackslash}.[0-9]+}\\
\texttt{[0-9]+\textbackslash.[0-9]+?(e|E)[+-]?[0-9]+([fF]|[lL])?}\\
\texttt{[0-9]+?\textbackslash.[0-9]+(e|E)[+-]?[0-9]+([fF]|[lL])?}\\
\\
The domain for the float type is as follows:
\btab[l]{|p{4cm}|p{4cm}|}
\hline  \emph{Minimal Value} & \emph{Maximal Value}\\
\hline 4.94065645841246544e-324 & 1.79769313486231570e+308\\
\hline
\etab
A few examples:
\verbsize
\begin{verbatim}
1.
1.23
.3
0.3039
1e+10
2.e+112
1.2e-100
.234e-200
.234e-200f
.234e-200F
\end{verbatim}
\normalsize
\subsubsect{String Atom}
The syntax for the string type is as follows:\\
\texttt{\textbackslash"([\^{}"]|\textbackslash\textbackslash\textbackslash")*\textbackslash"}\\
\\
The following escape sequences are interpreted:
\btab[l]{|p{2cm}|p{3cm}|p{3cm}|}
\hline \begin{center}\emph{Escape Sequence}\end{center} &
       \begin{center}\emph{Name}\end{center} &
       \begin{center}\emph{ASCII Name}\end{center}\\
\hline \texttt{{\textbackslash}a} & alert & BEL\\
\hline \texttt{{\textbackslash}b} & backspace & BS\\
\hline \texttt{{\textbackslash}f} & form feed & FF\\
%\hline
%\etab
%\btab[l]{|p{2cm}|p{3cm}|p{3cm}|}
\hline \texttt{{\textbackslash}n} & newline & NL (LF)\\
\hline \texttt{{\textbackslash}r} & carriage return & CR\\
\hline \texttt{{\textbackslash}t} & horizontal tab & HT\\
\hline \texttt{{\textbackslash}v} & vertical tab & VT\\
\hline \texttt{{\textbackslash}\textbackslash} & backslash & \textbackslash\\
\hline \texttt{{\textbackslash}"} & double quote & "\\
\hline \texttt{{\textbackslash}'} & single quote & '\\
\hline \texttt{{\textbackslash}ooo} & octal number & {\textbackslash}ooo\\
\hline
\etab
A few examples:
\verbsize
\begin{verbatim}
"hello"
"hello \"world\""
"this is a multi-lines\ntext\n"
"this text contains escape sequences: \007\v\f\n''
\end{verbatim}
\normalsize
\subsubsect{Char Atom}
The syntax for the char type is one of the followings:\\
\texttt{'}\emph{ascii character}\texttt{'}\\
\texttt{'\textbackslash[0-7+]'}\\
\texttt{'\textbackslash(x|X)[0-9a-fA-F+]'}\\
\texttt{'{\textbackslash}a'}\\
\texttt{'{\textbackslash}b'}\\
\texttt{'{\textbackslash}f'}\\
\texttt{'{\textbackslash}n'}\\
\texttt{'{\textbackslash}r'}\\
\texttt{'{\textbackslash}t'}\\
\texttt{'{\textbackslash}v'}\\
\\
A few examples:
\verbsize
\begin{verbatim}
'a'
'b'
'\n'
'\a'
'\007'
'\x50'
'\x5F'
\end{verbatim}
\normalsize

\subsubsect{Boolean Atom}
The syntax for a boolean atom is one of the followings:\\
\texttt{true}\\
\texttt{false}
\subsubsect{Identifier Atom}
The syntax for an identifier atom is as follows:\\
\texttt{[a-zA-Z{\textbackslash}\$\_\#][a-zA-Z{\textbackslash}\$\_0-9\#]*}\\
\\
This means that an identifier must start whith a letter, a ``\texttt{\_}'',
a ``\texttt{\$}'' or a ``\texttt{\#}'' which may be followed by letters, digits,
``\texttt{\_}'', ``\texttt{\$}'' and ``\texttt{\#}'' characters.\\
\\
For instance, the following words are some valid identifiers:
\verbsize
\begin{verbatim}
a
alpha
beta1
alpha_beta
$a
oql$maxint
oql#2
$
#
_1
\end{verbatim}
\normalsize
Note that identifiers beginning by \texttt{oql\$} or \texttt{oql\#} are
reserved for special used by the interpreter.
\subsubsect{Oid Atom}
The syntax for an \texttt{oid} is as following:\\
\texttt{[0-9]+:[0-9]+:[0-9]+:oid}\\
\\
Note that \texttt{oid} atoms are not typed directly by the user, but are produced
by the database via the OQL interpreter.
\\
The following words are some syntaxically valid atom \texttt{oid}s:
\verbsize
\begin{verbatim}
123.2.33373:oid
82727272.1.292828282:oid
\end{verbatim}
\normalsize
\subsubsect{Object Atom}
The syntax for an atom \texttt{object} is as following:\\
\texttt{[0-9a-fA-F]+:obj}\\
\\
Note that object atoms are not typed directly by the user, but are produced
by OQL interpreter.
\\
The following words are some syntaxically valid atom \texttt{object}s:
\verbsize
\begin{verbatim}
38383:obj
ea954:obj
\end{verbatim}
\normalsize
\subsubsect{Null Atom}
The \texttt{null} atom denotes an unitialized value. Its type depends on the context.
It can denote a unitialized integer, float, char, string or oid.
\\
\\
The syntax for a null atom is one of the followings:\\
\texttt{null}\\
\texttt{NULL}
\subsubsect{Nil Atom}
The \texttt{nil} atom denotes the empty atom.\\
The syntax for a nil atom is as follows:\\
\texttt{nil}
\subsect{Non Terminal Atom Production}
The other atoms - \texttt{set}s, \texttt{bag}s, \texttt{array}s,
\texttt{list}s and \texttt{struct}s - are non terminal
atoms. This means that they cannot be generated using a simple lexical
construct.

\subsubsect{List, Set, Bag and Array Atoms}
To construct a collection atom - \texttt{list}, \texttt{set}, \texttt{bag}
or \texttt{array} -, one may use the
function \emph{collection()} where \emph{collection} denotes the
collection type, for instance:
\verbsize
\begin{verbatim}
set(1, 2, 3)
list(1, "hello", "world")
array(2, 3, list(3893, -2, 'a'), 22)
bag(2, 2, 3, 4, 5, 12)
\end{verbatim}
\normalsize
This is the simple way to construct such atoms, but as any other atoms,
a collection atom may be produced by the OQL interpreter as the evaluation
of a complex expression, for instance:
\verbsize
\begin{verbatim}
select x from Person x
\end{verbatim}
\normalsize
produces an atom \texttt{bag} of objects.
\subsubsect{Struct Atom}
The most direct way to construct a \texttt{struct} atom is as follows:\\
\texttt{struct(}\{\emph{identifier}\texttt{:}\emph{expr}\}\texttt{)}\\
\\
For instance:
\verbsize
\begin{verbatim}
struct(a: 1)
struct(format: text, s: "this is the text")
struct(name: "john", age: 32, spouse: first(select Person))
\end{verbatim}
\normalsize
\subsect{Keywords}
Any programming language has its own set of reserved words (keywords)
that cannot be used as identifiers. For instance, the keyword ``\texttt{if}''
cannot be used as a variable in a C program.\\
OQL also has its own set of keywords.
But OQL is one part among others in
the information system: for instance, there are an Object Model,
an Object Definition Language (ODL) and Language bindings.
The Object Model does not introduce
any keyword, while ODL has its own set of keywords which are different
from the OQL keywords. For instance, a class can include an
attribute whose name is ``\texttt{if}'' as it is not a ODL keyword.
If one wants to access this attribute in OQL, using for instance
the path expression ``\texttt{x.if}'', we will get a syntax error.
This is not acceptable.\\
We introduce in OQL (and in ODL) a way to neutralize any keyword:
the token ``\texttt{@}'' used as a prefix keyword neutralizes
the keyword and makes it a valid identifier. For instance, ``\texttt{x.@if}'',
denotes the attribute ``\texttt{if}'' of the instance ``\texttt{x}''.\\
More generaly, ``\texttt{@}\emph{identifier}'' denotes the identifier
``\emph{identifier}'' whether ``\emph{identifier}'' is a keyword or not.
\\
\\
OQL introduces the following keywords:
\btab[l]{|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|}
\hline \texttt{add} & \texttt{all} & \texttt{append} & \texttt{array} & \texttt{as}\\
\hline \texttt{asc} & \texttt{bag} & \texttt{bodyof} & \texttt{break} & \texttt{by}\\
\hline \texttt{char} & \texttt{classof} & \texttt{contents} & \texttt{define} & \texttt{delete}\\
\hline \texttt{desc} & \texttt{distinct} & \texttt{do} & \texttt{element} & \texttt{else}\\
\hline \texttt{empty} & \texttt{eval} & \texttt{except} & \texttt{exists} & \texttt{false}\\
\hline \texttt{float} & \texttt{for} & \texttt{from} & \texttt{function} & \texttt{group}\\
\hline \texttt{having} & \texttt{ident} & \texttt{if} & \texttt{import} & \texttt{in}\\
\hline \texttt{int} & \texttt{intersect} & \texttt{is} & \texttt{isset} & \texttt{like}\\
\hline \texttt{list} & \texttt{mod} & \texttt{new} & \texttt{nil} & \texttt{not}\\
\hline \texttt{oid} & \texttt{order} & \texttt{pop} & \texttt{print} & \texttt{push}\\
\hline \texttt{refof} & \texttt{return} & \texttt{scopeof} & \texttt{select} & \texttt{set}\\
\hline \texttt{string} & \texttt{struct} & \texttt{structof} & \texttt{suppress} & \texttt{then}\\
\hline \texttt{throw} & \texttt{to} & \texttt{true} & \texttt{typeof} & \texttt{union}\\
\hline \texttt{unset} & \texttt{unval} & \texttt{valof} & \texttt{where} & \texttt{while}\\
\hline
\etab

\subsect{Comments}
In OQL, comments are identical to the C++:
\bi
\item all characters after the token \texttt{//} until the end of the current
line are ignored by the interpreter,
\item all characters between the tokens \texttt{/*} and \texttt{*/} are
ignored.
\ei
For instance:
\verbsize
\begin{verbatim}
1 + 2;        // this is a comment
a := "hello"; /* this is another
                 comment */
\end{verbatim}
\normalsize
\subsect{Statements}
A valid OQL construct is composed of a sequence of statements. Main of
the statements are expression statements.
\\
\\
A statement can be one of the following:\\
\ixy - an expression statement,\\
\ixy - a selection statement, \texttt{if/else},\\
\ixy - an iteration statement, \texttt{while}, \texttt{do/while}, \texttt{for},\\
\ixy - a function definition statement, \texttt{function}\\
\ixy - a jump statement, \texttt{break}, \texttt{return}\\
\ixy - a compound statement,\\
\ixy - an empty statement.\\
\\
The OQL expression sub-grammar is very close from the C grammar. The
OQL grammar for the flow controls statement - \texttt{if/else}, 
\texttt{while}, \texttt{do/while}, \texttt{for} - is identical to the C
grammar. The common operators of OQL and C have the same associativity
and precedence.

\subsect{Expression Statements}
An expression statement is an expression following by a semicolon.
Expressions are built from typed operands composed recursively by operators.
\\
\\
The syntax of an expression statement is as follows:\\
\ex \texttt{;}\\
where \ex denotes any expression.\\
\\
There are three main kinds of expressions: atomic expressions,
unary expressions and binary expressions.
Atomic expressions are composed of one terminal atom and no operators,
unary expressions are composed
of one operand and one operator, binary expressions are composed
of two operands and one operator.
\\
\\
We divide the OQL expression family into several semantical sub-families
according to their operators as follows:\\\\
\mbox{ } - atomic expressions,\\
\mbox{ } - arithmetic expressions,\\
\mbox{ } - assignment expressions,\\
\mbox{ } - auto increment \& decrement expressions,\\
\mbox{ } - comparison expressions,\\
\mbox{ } - logical expressions,\\
\mbox{ } - conditional lists,\\
\mbox{ } - expression sequences,\\
\mbox{ } - array deferencing,\\
\mbox{ } - identifier expressions,\\
\mbox{ } - path expressions,\\
\mbox{ } - function call,\\
\mbox{ } - method invocation,\\
\mbox{ } - eval/unval operators,\\
\mbox{ } - set expressions,\\
\mbox{ } - object creation,\\
\mbox{ } - object deletion,\\
\mbox{ } - collection expressions,\\
\mbox{ } - exception expressions,\\
\mbox{ } - function definition expressions,\\
\mbox{ } - conversion expressions,\\
\mbox{ } - type information expressions\\
\mbox{ } - query expressions,\\
\mbox{ } - miscellenaous expressions\\
\\
In the following sub-sections, we introduce all the OQL expression types
using the following template presentation:\\
\be
\item we present first, in an unformal way, the syntax and the semantics
of the operators,
\item general formal information is presented in a first table:\\
\mbox{ } - operator(s)\\
\mbox{ } - type\\
\mbox{ } - syntax\\
\mbox{ } - operand types\\
\mbox{ } - functions
\item in an optionnal second table, we present all the valid operand combination
and their result type. A comment about the function performed is added
if necessary. This table is skipped in case of the operand type combination
is unique or trivial.
\item in a last table, we introduce a few examples. The examples
manipulating database objects use the schema that can be found in
the directory\\
\texttt{\$EYEDBROOT/examples/common}:
\verbsize
\begin{verbatim}
// person.odl

enum CivilState {
  Lady = 0x10,
  Sir  = 0x20,
  Miss = 0x40
};

class Address {
  attribute string street;
  attribute string<32> town;
  attribute string country;
};

class Person {
  attribute string name;
  attribute int age;
  attribute Address addr;
  attribute Address other_addrs[];
  attribute CivilState cstate;
  attribute Person * spouse inverse Person::spouse;
  attribute set<Car *> cars inverse owner;
  attribute array<Person *> children;

  int change_address(in string street, in string town,
                     out string oldstreet, out string oldtown);

  static int getPersonCount();
  index on name;
};

class Car {
  attribute string brand;
  attribute int num;
  Person *owner inverse cars;
};

class Employee extends Person {
  attribute long salary;
};
\end{verbatim}
\normalsize
\ee
Expression types are gathered so to minimize the number of tables in this
document.
\subsect{Atomic Literal Expressions}
Atomic literal expressions are expressions composed of a single terminal
(or token or lexical unit) without any operator. They are also called
primary expressions. These expressions have already been introduced in
\oqlsect{termatoms}.
\btab[l]{\dimtab}
\geninfo\\
\hline Operator & \emph{no operator}\\
\hline Type & unary\\
\hline Syntax & \emph{terminal atom}\\
\hline Operand Types & \texttt{integer, float, char, string, boolean, identifier, null, nil, oid,}\\
\hline Result Type & same type as the operand\\
\hline
\etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{1} & \texttt{1}\\
\hline \texttt{2.} & \texttt1{2.}\\
\hline \texttt{'a'} & \texttt{'a'}\\
\hline \texttt{"hello"} & \texttt{"hello"}\\
\hline \texttt{alpha} & \emph{value of} \texttt{alpha}\\
\hline \texttt{true} & \texttt{true}\\
\hline \texttt{83283.1.29292:oid} & \emph{an error is raised} in case
of the oid is invalid.\\
& Otherwise the result is the input oid: \texttt{83283.1.29292:oid}\\
\hline
\etab

\subsect{Arithmetic Expressions}
Arithmetic expressions gather the expressions used for any arithmetic
computation: addition, multiplication, substraction, division, modulo, shift
left and right,
bitwise or, bitwise exclusive, bitwise and, bitwise complement.
This Section introduced these operators with a special focus on the
additive operator which is a multi-purpose operator.
\subsubsect{Additive Expression}
The additive operator (i.e. \texttt{+}) is used for arithmetic
addition of integers, floating point numbers and characters, and is
also used for string concatenation,
list or array concatenation and set or bag union. Its functionality
depends on the type of its operands: it is a polymorphic operator.
Note that the choice of its functionality is done at evaluation time, not
at compile time. That means that the functionality of an expression such as
\texttt{x + y} is unknown until the evaluation time. Depending on the
dynamic type of the operands \texttt{x} and \texttt{y}, it can be a
simple arithmetic addition, a string or list or array concatenation,
a set or bag union or it can raise an error.\\
When used as a arithmetic operator and when the two
operands have not the same type, one of the operands can be
automatically promote to the type of the second one.
The \emph{promotion} mechanism is the same as in the C or C++ languages:
\texttt{integer} may be promoted to \texttt{float}, \texttt{char} may be promoted to
\texttt{float} or \texttt{integer}.
\btab[l]{|p{3cm}|p{6cm}|}
\geninfo\\
\hline Operator & \texttt{+}\\
\hline Type & binary\\
\hline Syntax & \bin{+} \\
\hline Commutative & yes\\
\hline Operand Types & \texttt{integer, float, char, string, list, bag, set, array}\\
\hline Result Type & see following table\\
\hline Function & multi functions according to operands: arithmetic addition,
string concatenation, list or array concatenation, set or bag union.\\
\hline
 \etab
%The following table presents all the possible operand combinations. Any other
%operand combination raises an error.
%As the additive operator is commutative, only half of the non symetrical
%combinations are shown:\\
%\\
\bettab
\btab[l]{|p{3cm}|p{3cm}|p{3cm}|p{3cm}|}
\poscomb{4}\\
\hline \emph{first operand type} &\emph{second operand type} & \emph{result type} & \\
\hline \texttt{integer} &  \texttt{integer} & \texttt{integer} & \\
\hline \texttt{integer} &  \texttt{float} & \texttt{float} & \\
\hline \texttt{char} &  \texttt{char} & \texttt{integer} & \\
\hline \texttt{char} &  \texttt{integer} & \texttt{integer} & \\
\hline \texttt{char} &  \texttt{float} & \texttt{float} & \\
\hline \texttt{float} &  \texttt{float} & \texttt{float} & \\
\hline \texttt{string} &  \texttt{string} & \texttt{string} &
\emph{string concatenation}\\
\hline \texttt{list} &  \texttt{list} & \texttt{list} &
\emph{list concatenation}\\
\hline \texttt{array} &  \texttt{array} & \texttt{array} &
\emph{array concatenation}\\
\hline \texttt{set} &  \texttt{set} & \texttt{set} &
\emph{set union}\\
\hline \texttt{bag} &  \texttt{bag} & \texttt{bag} &
\emph{bag union} \\
\hline
\etab
\bettab
\btab[l]{|p{3cm}|p{4cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{1 + 2} & \texttt{3}\\
\hline \texttt{1 + 2.} & \texttt{3.}\\
\hline \texttt{2 + 2.3} & \texttt{4.3}\\
\hline \texttt{'a' + 'b'} & \texttt{195}\\
\hline \texttt{'a' + 1.2} & \texttt{98.200}\\
\hline \texttt{"hello" + "world"} & \texttt{"helloworld"}\\
\hline \texttt{list(1, 2, 3) + list(2, 3, 4)} & \texttt{list(1, 2, 3, 2, 3, 4)}\\
\hline \texttt{set(1, 2, 3) + set(2, 3, 4)} & \texttt{set(1, 2, 3, 4)}\\
\hline \texttt{1 + "hello"} & \rerr\\
\hline \texttt{set(1, 2, 3) + list(2, 3, 4)} & \rerr\\
\hline
\etab
\subsubsect{Multiplicative, Division and Minus Expressions}
Multiplicative, division and minus \Cidem.
When operands have different types, promotionnal mechanisms are the
same as for the additive operator.
\btab[l]{\dimtab}
\geninfo\\
\hline Operators & \texttt{-} \\
& \texttt{*} \\
& \texttt{/} \\
\hline Type & binary\\
\hline Syntaxes & \bin{-}\\
& \bin{*} \\
& \bin{/} \\
\hline Commutative & \texttt{-} : no\\
& \texttt{*} : yes\\
& \texttt{/} : no\\
\hline Operand Types & \texttt{integer, float, char}\\
\hline Result Type & see following table\\
\hline Functions & \texttt{-} : substract\\
& \texttt{*} : multiply\\
& \texttt{/} : divide\\
\hline
 \etab
%The following table presents all the possible operand combinations. Any other
%operand combination raises an error.
\bettab
\btab[l]{|p{3cm}|p{3cm}|p{3cm}|}
\poscomb{3}\\
\hline \emph{first operand type} &\emph{second operand type} & \emph{result type}\\
\hline \texttt{integer} &  \texttt{integer} & \texttt{integer}\\
\hline \texttt{integer} &  \texttt{float} & \texttt{float}\\
\hline \texttt{integer} &  \texttt{char} & \texttt{integer}\\
\hline \texttt{char} &  \texttt{char} & \texttt{integer}\\
\hline \texttt{char} &  \texttt{integer} & \texttt{integer}\\
\hline \texttt{char} &  \texttt{float} & \texttt{float}\\
\hline \texttt{float} &  \texttt{float} & \texttt{float}\\
\hline \texttt{float} &  \texttt{integer} & \texttt{float}\\
\hline \texttt{float} &  \texttt{char} & \texttt{float}\\
\hline
\etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{1 - 2} & \texttt{-1}\\
\hline \texttt{3 * 2.} & \texttt{6.}\\
\hline \texttt{2 * 'a'} & \texttt{194}\\
\hline \texttt{'a' * 'b'} & \texttt{9506}\\
\hline \texttt{1 / 2} & \texttt{0}\\
\hline \texttt{1 / 2.} & \texttt{.5000}\\
\hline \texttt{1. / 2} & \texttt{.5000}\\
\hline \texttt{1. / 2} & \texttt{.5000}\\
\hline \texttt{"hello" * "world"} & \rerr\\
\hline \texttt{1 - "hello"} & \rerr\\
\hline
\etab
\subsubsect{Shift, Mod, And, Or, XOr Expressions}
Shift, modulo, and, or and xor \Cidem.
Operand types must be \texttt{integer} or \texttt{char} and the only
possible type promotion is from \texttt{char} to \texttt{integer}.
\btab[l]{\dimtab}
\geninfo\\
\hline Operators & \texttt{<<} \\
& \texttt{>>} \\
& \texttt{\%} \\
& \texttt{\&} \\
& \texttt{|} \\
& \texttt{\^{}} \\
\hline Type & binary\\
\hline Syntaxes & \bin{<<}\\
& \bin{>>} \\
& \bin{\%} \\
& \bin{\&} \\
& \bin{|} \\
& \bin{\^{}} \\
\hline Commutative & \texttt{<<} : no \\
& \texttt{>>} : no \\
& \texttt{\% } : no \\
& \texttt{\& } : yes \\
& \texttt{| } : yes \\
& \texttt{\^{} } : yes \\
\hline Operand Types & \texttt{integer, char}\\
\hline Result Type & \texttt{integer}\\
\hline Functions & \texttt{<<} : left shift\\
& \texttt{>>} : right shift \\
& \texttt{\% } : modulo\\
& \texttt{\& } : bitwise and\\
& \texttt{| } : bitwise or \\
& \texttt{\^{} } : bitwise exclusive or\\
\hline
 \etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{1 << 4} & \texttt{16}\\
\hline \texttt{100 >> 2} & \texttt{25}\\
\hline \texttt{100 \% 13} & \texttt{9}\\
\hline \texttt{0xf12 \& 0xf} & \texttt{2}\\
\hline \texttt{0xf12 | 0xf} & \texttt{3871}\\
\hline \texttt{0xf12 \^{} 0xf} & \texttt{3869}\\
\hline \texttt{'b' \% '9'} & \texttt{8}\\
\hline \texttt{2 << 1.2} & \rerr\\
\hline \texttt{2 \% 3.4} & \rerr\\
\hline \texttt{2.1 \% 3} & \rerr\\
\hline
\etab

\subsubsect{Sign Expressions}
Sign expressions are the expressions using the unary operators \texttt{+}
or \texttt{-}. 
The \Cidem.
These unary operators accept only \texttt{integer},
\texttt{char} and \texttt{float} operands.
\btab[l]{\dimtab}
\geninfo\\
\hline Operators & \texttt{+} \\
& \texttt{-} \\
\hline Type & unary\\
\hline Syntaxes & \una{+}\\
& \una{-} \\
\hline Operand Types & \texttt{integer, char, float}\\
\hline Result Type & see following table\\
\hline Functions & sign operator\\
\hline
 \etab
%The following table presents all the possible operand combinations:\\
\bettab
\btab[l]{\dimtab}
\poscomb{2}\\
\hline \emph{operand type} & \emph{result type}\\
\hline \texttt{integer} & \texttt{integer}\\
\hline \texttt{float} & \texttt{float}\\
\hline \texttt{char} & \texttt{integer}\\
\hline
\etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{+12} & \texttt{12}\\
\hline \texttt{-100} & \texttt{-100}\\
\hline \texttt{-123.4} & \texttt{-123.4}\\
\hline \texttt{+'a'} & \texttt{97}\\
\hline \texttt{-'a'} & \texttt{-97}\\
\hline \texttt{+"hello"} & \rerr\\
\hline \texttt{-null"} & \rerr\\
\hline
\etab

\subsubsect{Complement Expressions}
The complement operator performs a bitwise complement on its operand.
The \Cidem.
This operator accepts only \texttt{integer} and \texttt{char} operands.
\btab[l]{\dimtab}
\geninfo\\
\hline Operator & \texttt{\~{}} \\
\hline Type & unary\\
\hline Syntax & \una{\~{}}\\
\hline Operand Types & \texttt{integer}, \texttt{char}\\
\hline Result Type & \texttt{integer}\\
\hline Functions & bitwise complement\\
\hline
 \etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{\~{}112} & \texttt{-113}\\
\hline \texttt{\~{}0} & \texttt{-1}\\
\hline \texttt{\~{}'a'} & \texttt{-98}\\
\hline \texttt{\~{}2.3} & \rerr\\
\hline \texttt{\~{}"hello"} & \rerr\\
\hline
\etab

\subsect{Assignment Expressions}
The {\Cidem } except that the simple assignment operator in OQL is \texttt{:=}
instead of \texttt{=} in C or C++. The left operand must be a left value.
A left value is an OQL entity which is assignable: for instance any
identifier or a valid path expression.\\
When the assignment is simple and when the left value is an identifier,
no type checking on the right operand is done. For instance, \texttt{x := 10}
and \texttt{x := "hello"} are always valid expressions. In the case
of the left value is a path expression, the OQL interpreter checks that
the type of the second operand matches the expected type of the first one.
For instance if \texttt{p} denotes a \texttt{Person} instance,
\texttt{p->age := 32} is certainly valid while \texttt{p->age := "hello"}
raises a type check error.\\
When the assignment is combined with another operation (for instance,
the \texttt{-=} operator), the left operand must be initialized and
the interpreter checks that the left and right
operand can be combined through the other operator.\\
\\
For instance, the following constructs are valid:
\begin{verbatim}
a := 10;
a -= 20;

a := "hello";
a += " world";

p := first(select Person);
p.name := "johnny";

first(select Person.age = 0).name := "baby";
\end{verbatim}
while these ones produce errors:
\begin{verbatim}
a := "hello";
a -= 20; // raises the error: operation 'string + integer' is not valid

a := list(1, 2);
a *= 2; // raises the error: operation 'list * integer' is not valid

unset b;
b += 20; // raises the error: uninitialized identifier 'b'

p := first(select Person);
p.age := "baby"; // raises the error: integer expected, got string
\end{verbatim}
\mbox{}
\btab[l]{\dimtab}
\geninfo\\
\hline Operators & \texttt{:=} \\
& \texttt{*=} \\
& \texttt{/=} \\
& \texttt{\%=} \\
& \texttt{+=} \\
& \texttt{-=} \\
& \texttt{<<=} \\
& \texttt{>>=} \\
& \texttt{\&=} \\
& \texttt{|=} \\
& \texttt{\^{}=} \\
\hline Type & binary\\
\hline Syntaxes
& \ass{:=}\\
& \ass{*=} \\
& \ass{/=} \\
& \ass{\%=} \\
& \ass{+=} \\
& \ass{-=} \\
& \ass{<<=} \\
& \ass{>>=} \\
& \ass{\&=} \\
& \ass{|=} \\
& \ass{\^{}=} \\
\hline Commutative & no \\
\hline Operand Types & \emph{leftvalue} on the left side and \emph{any type}
on the right side\\
\hline Result Type & the type of the right operand\\
\hline Functions & perform an operation and assignment\\
\hline
 \etab
\bettab
\btab[l]{|p{3cm}|p{6cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{a := 24} & \texttt{24}\\
\hline \texttt{a += 12} & \texttt{36}\\
\hline \texttt{a /= 2} & \texttt{18}\\
\hline \texttt{a \^{}= 100} & \texttt{118}\\
\hline \texttt{first(select Person).age := 38} & \texttt{38}\\
\hline \texttt{"hello" := 4} & {\rerr } (i.e. \texttt{"hello"} is not a leftvalue)\\
\hline \texttt{8 := 5} & {\rerr } (i.e. \texttt{8} is not a leftvalue)\\
\hline \texttt{unset a; a += 20} & {\rerr } (i.e. uninitialized identifier)\\
\hline
\etab

\subsect{Auto Increment \& Decrement Expressions}
The {\Cidem }. The operand must be an initialized left value of type
\texttt{integer}, \texttt{char} or \texttt{float}. In case of the
operand is a \texttt{char} atom, the result type is an \texttt{integer}.
Otherwise, the result type is the type of the operand.
\btab[l]{\dimtabx}
\geninfo\\
\hline Operators & \texttt{++} \\
& \texttt{--} \\
\hline Type & unary\\
\hline Syntaxes
& {\ex}\texttt{--}\\
& {\ex}\texttt{++}\\
& \texttt{++}{\ex}\\
& \texttt{--}{\ex}\\
\hline Operand Type & \emph{leftvalue} of type \texttt{integer}, \texttt{char} or \texttt{float}.\\
\hline Result Type & see following table\\
\hline Functions
& {\ex}\texttt{--} : post-decrementation \\
& {\ex}\texttt{++} : post-incrementation\\
& \texttt{++}{\ex} : pre-incrementation\\
& \texttt{--}{\ex} : pre-incrementation\\
\hline
 \etab
%The following table presents all the possible operand combinations:\\
\bettab
\btab[l]{\dimtab}
\poscomb{2}\\
\hline \emph{operand type} & \emph{result type}\\
\hline \texttt{integer} & \texttt{integer}\\
\hline \texttt{float} & \texttt{float}\\
\hline \texttt{char} & \texttt{integer}\\
\hline
\etab
\bettab
\btab[l]{|p{2cm}|p{2cm}|p{5cm}|}
\expex{3}\\
\hline \emph{expression} & \emph{result} &\\
\hline \texttt{a := 1; a++} & \texttt{1} & \emph{initially} \texttt{a} equals \texttt{1}; the result of the evaluation is \texttt{1} but after the evaluation,
\texttt{a} equals 2\\
\hline \texttt{--a} & \texttt{0} & \\
\hline \texttt{a++} & \texttt{0} & \texttt{a} equals \texttt{1} after the
evaluation\\
\hline
\etab

\subsect{Comparison Expressions}
The {\Cidem } except that the equal operator could be either \texttt{==} or
\texttt{=}.
\subsubsect{Equal and NotEqual Expressions}
Operands may have any type at all. If the type of the operands differ (modulo
the type promotion mechanisms for numbers), the
result of the expression \emph{operand1} \texttt{==} \emph{operand2} is
always \texttt{false} while the result of \emph{operand1} \texttt{!=}
\emph{operand2} is always \texttt{true}.
\btab[l]{\dimtab}
\geninfo\\
\hline Operators & \texttt{==} \\
& \texttt{!=}\\
\hline Type & binary\\
\hline Syntaxes
& \bin{==}\\
& \bin{!=}\\
\hline Commutative & yes\\
\hline Operand Types & \emph{any type} \\
\hline Result Type & \texttt{boolean}\\
\hline Functions & equal\\
& not equal\\
\hline
 \etab
When operands are number of different types, an automatic promotion is
done to the more precise type.
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{1 == 1} & \texttt{true} \\
\hline \texttt{1 == 1.0} & \texttt{true} \\
\hline \texttt{1 != 2} & \texttt{true} \\
\hline \texttt{1 == 2} & \texttt{false} \\
\hline \texttt{1 == "hello"} & \texttt{false} \\
\hline \texttt{"hello" == "hello"} & \texttt{true} \\
\hline \texttt{list(1, 2, 3) == list(1, 2, 3)} & \texttt{true} \\
\hline \texttt{set(1, 3, 2) == set(1, 2, 3)} & \texttt{true} \\
\hline
\etab
\subsubsect{Less and Greater Expressions}
The comparison operators \texttt{<, <=, >} and \texttt{>=} are multi-purpose
operators: they are used for
integer, floating point number and character comparison, but also
for list or array term-to-term comparison and for set or bag inclusion.
Their functionality
depends on the type of its operands: they are polymorphic operators.
Note that the choice of the functionality is done at evaluation time, not
at compile time. That means that the functionality of an expression such as
\texttt{x < y} is unknown until the evaluation time. Depending on the
dynamic type of the operands \texttt{x} and \texttt{y}, it can be an
arithmetic comparison (if \texttt{x} and \texttt{y} are numbers),
a alpha-numeric comparison (if \texttt{x} and \texttt{y} are strings),
a term-to-term ordered collection comparison (if \texttt{x} and \texttt{y} are lists or
arrays) or a set or bag inclusion comparison
(if \texttt{x} and \texttt{y} are sets or bags).
\\
\\
While arithmetic and alpha-numeric comparisons are trivial and do not
need any suplementary explanations,
the term-to-term ordered collection comparisons needs to be detailed.
\\
\\
The general algorithm for this functionnality is as follows:\\
\be
\item let \emph{l1} and \emph{l2} two OQL ordered collections, containing
respectively \emph{l1\_cnt} and \emph{l1\_cnt} atoms.
\item let \emph{op} one of the following polymorphic comparison operators: 
 \texttt{< <= > >=},
\item \emph{l1} \emph{op} \emph{l2} is \texttt{true} if and only if all the
following conditions are realized:
\be
\item \emph{l1} and \emph{l2} must be of the same collection type,
\item \emph{l1\_cnt} \emph{op} \emph{l2\_cnt} or \emph{l1\_cnt} equals
\emph{l2\_cnt}
\item for each atom \emph{l1[i]} with \emph{i} in \texttt{[}\emph{i}\texttt{,}\emph{l1\_cnt}\texttt{]}, \emph{l1[i]} \emph{op} \emph{l2[i]}
\ee
\ee
For instance:\\
\texttt{list(1, 2) <= list(0, 2)} is \texttt{true}\\
\texttt{list(1, 2) <= list(3)} is \texttt{false}\\
\texttt{list(1, 2) <= list(3)} is \texttt{false}\\
\texttt{list("aaa", 4) < list("bbbb", 8)} is \texttt{true}\\
\texttt{list("aaa", 4, list(1, 2)) < list("b", 8, list(2, 3))} is \texttt{true}\\
\texttt{list(set(2, 4), 3) < list(set(4, 2, 3), 4)} is \texttt{true}\\
\texttt{list(2, 3) < list("hello", 2)} raises an error\\
\texttt{list(2, 3) < array(2, 4)} raises an error\\
\\
Note that the fact that \emph{l1} \texttt{<=} \emph{l2} is \texttt{false}
does not implie that \emph{l1} \texttt{>} \emph{l2} is \texttt{true}.
Indeed, \texttt{list(2, 3) < list(1, 3, 2)} and
\texttt{list(1, 3, 2) >= list(2, 3)} are \texttt{false}.
\btab[l]{\dimtab}
\geninfo\\
\hline Operators & \texttt{<} \\
& \texttt{<=}\\
& \texttt{>}\\
& \texttt{>=}\\
\hline Type & binary\\
\hline Syntaxes
& \bin{<}\\
& \bin{<=}\\
& \bin{>}\\
& \bin{>=}\\
\hline Commutative & no\\
\hline Operand Types & \texttt{integer, float, char, string, list, array, set,
bag} \\
\hline Result Type & \texttt{boolean}\\
\hline Functions & the function depends on the operands:\\
& \texttt{< } : less than \emph{or} is included in\\
& \texttt{<=} : less than or equal \emph{or} is included in or equal\\
& \texttt{> } : greater than \emph{or} contains\\
& \texttt{>=} : greater than or equal \emph{or} contains or equal\\
\hline
 \etab
\bettab
\btab[l]{|p{3cm}|p{3cm}|p{2cm}|p{5cm}|}
\poscomb{4}\\
\hline \emph{first operand type} & \emph{second operand type} & \emph{result type} & \emph{comments}\\
\hline \texttt{integer}, \texttt{char}, \texttt{float} &\texttt{integer},
\texttt{char}, \texttt{float} & \texttt{boolean} & performs an arithmetic
comparison\\
\hline \texttt{string} & \texttt{string} & \texttt{boolean} &
performs an alpha-numeric comparison\\
\hline \texttt{set} & \texttt{set} & \texttt{boolean} &
performs an inclusion comparison\\
\hline \texttt{bag} & \texttt{bag} & \texttt{boolean} &
performs an inclusion comparison\\
\hline \texttt{set} & \texttt{bag} & \texttt{boolean} &
performs an inclusion comparison: the \texttt{set} operand is converted to a
\texttt{bag}\\
\hline \texttt{bag} & \texttt{set} & \texttt{boolean} &
performs an inclusion comparison: the \texttt{set} operand is converted to a
\texttt{bag}\\
\hline \texttt{list} & \texttt{list} & \texttt{boolean} &
performs a term-to-term polymorphic (i.e. numeric, alpha-numeric or inclusion)
comparison\\
\hline \texttt{array} & \texttt{array} & \texttt{boolean} &
performs a term-to-term polymorphic comparison\\
\hline
\etab
Note that in case of different operand types, an automatic promotion is
done to the more precise type.
\btab[l]{|p{6cm}|p{6cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{1 < 2} & \texttt{true} \\
\hline \texttt{1 >= 2} & \texttt{false} \\
\hline \texttt{2. <= 2} & \texttt{true} \\
\hline \texttt{"hello" < "world"} & \texttt{true} \\
\hline \texttt{"hello" >= "world"} & \texttt{false} \\
\hline \texttt{list(1, 2) < list(2, 3)} & \texttt{true} \\
\hline \texttt{list(1, 2) < list(0, 3)} & \texttt{false} \\
\hline \texttt{list(1, 2) < list(0, 3, 2)} & \texttt{false} \\
\hline \texttt{list(0, 3, 2) >= list(1, 2)} & \texttt{false} \\
\hline \texttt{list(1, 2) < list(2, 3, 3)} & \texttt{true} \\
\hline \texttt{list(1, 2) < list(0)} & \texttt{false} \\
\hline \texttt{set(1, 2) < set(2, 4, 44)} & \texttt{false} \\
\hline \texttt{set(1, 2) < set(2, 1, 44)} & \texttt{true} \\
\hline \texttt{"hello" >= 3} & \rerr\\
\hline \texttt{list(1, 2) < array(2, 4, 44)} & \rerr\\
\hline \texttt{set(1, 2) < bag(2, 1, 44)} & \rerr\\
\hline
\etab
\subsubsect{Regular Expression Operators}
OQL provides the ODMG OQL regular expression operator \texttt{like}
plus four other ones. These four extra operators are based on the regular
expression UNIX library. So, the syntax of the regular expression are
the same as that used by the well known UNIX tools \texttt{grep}, \texttt{sed},
and so on. All the regular expression operators takes two string operands:
the first one is the string to compare, the second one is the regular
expression. So, these operators are not commutative.
These operators provide the following functionalities:\\
\begin{tabbing}
\texttt{likeli} \= : \= \kill
\texttt{like} \> : ODMG OQL operator. Returns \texttt{true} if the first
operand matches the regular expression.\\
\> \> Otherwise \texttt{false} is returned. The regular expression is am SQL regular expression where,\\
\> \> for instance, \texttt{\%} and \texttt{\_} are wilcard characters.\\
\texttt{\~{}} \> : This operator has
the same functionnality as the \texttt{like} operator but the
regular expression\\
\> \> has the UNIX syntax.\\
\texttt{\~~{}} \> : Returns \texttt{true} if the first
operand matches the regular expression in a case insensitive way.\\
\> \> Otherwise \texttt{false} is returned.\\
\texttt{!\~{}} \> : Returns \texttt{true} if the first
operand does not match the regular expression.\\
\> \> Otherwise \texttt{false} is returned.\\
\texttt{!\~{}\~{}} \> : Returns \texttt{true} if the first
operand does not match the regular expression in a case insensitive\\
\> \> way. Otherwise \texttt{false} is returned.
\end{tabbing}
\emph{Note that the operator} \texttt{like} \emph{uses currently the
UNIX form of regular expressions instead of the SQL form. It will become
ODMG/SQL compliant in a next version}.
\btab[l]{|p{3cm}|p{9cm}|}
\geninfo\\
\hline Operators &
\texttt{\~{}} \\
& \texttt{\~{}\~{}}\\
& \texttt{!\~{}}\\
& \texttt{!\~{}\~{}}\\
& \texttt{like}\\
\hline Type & binary\\
\hline Syntaxes
& \bin{\~{}} \\
& \bin{\~{}\~{}}\\
& \bin{!\~{}}\\
& \bin{!\~{}\~{}}\\
& \bin{like}\\
\hline Commutative & no\\
\hline Operand Types & \texttt{string}\\
\hline Result Type & \texttt{boolean}\\
\hline Functions & 
\begin{tabular}{p{2cm}p{5cm}}
%\texttt{like} \= : matches the regular expression \kill
\texttt{\~{}} : &  matches the regular expression\\
\texttt{\~~{}} : & matches the regular expression, case insensitive\\
\texttt{!\~{}} : & does not match the regular expression\\
\texttt{!\~{}\~{}} : & does not match the regular expression, case insensitive\\
\texttt{like} : &matches the regular expression\\
%\end{tabbing}\\
\end{tabular}\\
\hline
\etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{"hello" \~{} "LL"} & \texttt{false} \\
\hline \texttt{"hello" \~{}\~{} "LL"} & \texttt{true} \\
\hline \texttt{"hello" \~{} "\^{}LL"} & \texttt{false} \\
\hline \texttt{"hello" \~{} "\^{}h"} & \texttt{true} \\
\hline \texttt{"hello" !\~{} "\^{}h"} & \texttt{false} \\
\hline \texttt{"hello" \~{} ".*ll.*" } & \texttt{true} \\
\hline \texttt{".*ll.*" \~{} "hello"} & \texttt{false} \emph{because regular
expression should be on the right}\\
\hline
\etab

\subsect{Logical Expressions}
OQL provide three logical expressions which can take two form each.
The logical or operator is \texttt{||} or \texttt{or}.
The logical and operator is \texttt{\&\&} or \texttt{and}.
The logical not operator is \texttt{!} or \texttt{not}.
\\
\\
The \Cidem. Note that the ODMG operator ``\texttt{||}'' denotes the string concatenation.
\\
As for \texttt{C} and \texttt{C++}, the OQL interpreter
performs a lazy evaluation:
\bi
\item \emph{expr1} \texttt{||} \emph{expr2}\\
\emph{expr2} is not evaluated if \emph{expr1} is evaluated to \texttt{true}.
\item \emph{expr1} \texttt{\&\&} \emph{expr2}\\
\emph{expr2} is not evaluated if \emph{expr1} is evaluated to \texttt{false}.
\ei
\mbox{ }
\btab[l]{\dimtab}
\geninfo\\
\hline Operators & \texttt{||} \\
& \texttt{\&\&} \\
\hline Type & unary, binary\\
\hline Syntaxes
& \bin{||}\\
& \bin{or}\\
& \bin{\&\&}\\
& \bin{and}\\
& \una{!}\\
& \una{not}\\
\hline Operand Type & \texttt{boolean} \\
\hline Result Type & \texttt{boolean} \\
\hline Functions & logical or\\
& logical and\\
& logical not\\
\hline
 \etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{true || false} & \texttt{true} \\
\hline \texttt{false || false} & \texttt{false} \\
\hline \texttt{true \&\& false} & \texttt{false} \\
\hline \texttt{1 == 2 || 3 == 4} & \texttt{false} \\
\hline \texttt{1 == 2 || 3 == 3} & \texttt{true} \\
\hline \texttt{1 == 2 or 3 == 3} & \texttt{true} \\
\hline \texttt{1 == 2 || "hello" == "hello"} & \texttt{true} \\
\hline \texttt{(1 == 2 || 2 == 2) \&\& (a = "hello")} & returns \texttt{true}
if \texttt{a} equals "hello". \texttt{false} otherwise \\
\hline \texttt{1 || 3 == 3} & \rerr : boolean expected got integer\\
\hline \texttt{!3} & \rerr : boolean expected got integer\\
\hline \texttt{!(1 == 1)} & \texttt{false}\\
\hline \texttt{not(1 == 1)} & \texttt{false}\\
\hline
\etab
\subsect{Conditional Expression}
The unique conditional expression operator is \texttt{?:}.
The \Cidem. The first operand must be an boolean and the two others
may be of any type. Contrary to \texttt{C} and \texttt{C++}, the two
last operands does not need to be of the same type.
\btab[l]{\dimtab}
\geninfo\\
\hline Operator & \texttt{?:} \\
\hline Type & ternary\\
\hline Syntaxe
& \ex \texttt{?} \ex \texttt{:} \ex\\
\hline Operand Types & first operand is boolean, others are any type\\
\hline Result Type & type of the evaluated operand\\
\hline Functions & conditional evaluation: evaluates and returns the second operand if
the first operand is true; otherwise evaluates and returns the second operand\\
\hline
 \etab
\bettab
\btab[l]{|p{7cm}|p{3cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{true ? "hello" : "world"} & \texttt{"hello"} \\
\hline \texttt{true ? 2.3 : "world"} & \texttt{2.3} \\
\hline \texttt{1+1 == 2 ? (a := 3.1415926535) : nil} & \texttt{3.1515926535} \\
\hline \texttt{1 ? 3 : nil} & \rerr : boolean expected, got integer.\\
\hline
\etab
\subsect{Expression Sequences}
The expression sequence operator - also called comma sequencing - \Cidem.
This operator \texttt{,} takes two operands: it evaluates both of them
and returns the second one.
\btab[l]{|p{3cm}|p{6cm}|}
\geninfo\\
\hline Operator & \texttt{,} \\
\hline Type & binary\\
\hline Syntaxe
& \bin{,}\\
\hline Commutative & no\\
\hline Operand Types & \emph{any type}\\
\hline Result Type & type of the second operand\\
\hline Functions & evaluates the first operand, then the second one.
Returns the evaluation of the second one.\\
\hline
\etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{true, "hello"} & \texttt{"hello"} \\
\hline \texttt{a := 2, 4} & \texttt{4} (\emph{note that} \texttt{a} equals
\texttt{2})\\
\hline \texttt{b := 10, a := b+1} & \texttt{11} \\
\hline
\etab

\subsect{Array Deferencing}
\label{arraydef}
OQL provides polymorphic single and range deferencing. The single deferencing
is used to get one element in an ordered collection or a character in a string
or one element in a non-collection array. The range deferencing is used to
get several elements.\\
The deferencing of ordered collections is introduced in more details
in Section \ref{collexp}.
\subsubsect{Single Deferencing}
The single deferencing operator takes as its first operand an atom of type
\texttt{string}, an indexed 
(or ordered) collection (\texttt{list} or \texttt{array})
or a non-collection array. The second operand must be of type \texttt{integer}.
Depending on the type of the first operand, the returned atom
is as follows:
\be
\item if the first operand is a string,
the returned atom is the \texttt{\#}\emph{expr} character of the string
where \emph{expr} denotes the second operand.
If \emph{expr} is equal to the length to the string the character
\texttt{'{\textbackslash}000'} is returned. If it greater than the length the
string an \emph{out of bounds} error is raised.
\item for an ordered collection, the returned atom is the
\texttt{\#}\emph{expr} item of the collection. If \emph{expr} is greater
than or is equal to the size of the collection, an
\emph{out of bounds} error is raised.
\item if the first operand is an non-collection array, the returned atom is the
\texttt{\#}\emph{expr} item of the array. If \emph{expr} is greater
than or is equal to the size of the array, an
\emph{out of bounds} error is raised.
\ee
The single deferencing operator may be used as a left value, that means that a single
deferencing expression is assignable. For instance the sequence of
statements:
\verbsize
\begin{verbatim}
s := "hello";
s[1] := 'E';
s[4] := 'O';
\end{verbatim}
\normalsize
set the variable \texttt{s} to \texttt{"hEllO"}.
\\
\\
The single deferencing operator may be used everywhere in a path expression.
For instance, \texttt{first(select Person).other\_addrs[2].street[3]},
denotes the character \texttt{\#3} of the \texttt{street} attribute
in the \texttt{\#2} \texttt{other\_addrs} non-collection array attribute of
the first \texttt{Person} instance.
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operator & \texttt{[]} \\
\hline Syntaxe
& \ex\texttt{[}\ex\texttt{]}\\
\hline Type & binary\\
\hline Commutative & no\\
\hline Operand Types & first operand: \texttt{string}, indexed collection
(\texttt{list} or \texttt{array}) or non-collection array,
 second operand: \texttt{integer} \\
\hline Result Type & \texttt{char} if first operand is a string,
otherwise type of the returned item in the indexed collection or non-collection
array.\\
\hline Functions
& \texttt{[}\ex\texttt{]} : returns the character (or item in the
indexed collection or in the non-collection array) number \ex\\
\hline Note & this operator may be used in the composition of a left value.\\
\hline
 \etab
\bettab
\btab[l]{|p{4.5cm}|p{2cm}|p{3cm}|}
\expex{3}\\
\hline \emph{expression} & \emph{result} & \\
\hline \texttt{"hello"[0]} & \texttt{'h'} & \\
\hline \texttt{a := "hello"; a[1]} & \texttt{'e'} & \\
\hline \texttt{a[3]} & \texttt{l} &\\
\hline \texttt{a[6]} & \rerr & \\
\hline \texttt{a[0] := 'H'} & \texttt{'H'} & \texttt{a} equals
 \texttt{"Hello"}\\
\hline \texttt{list(1, 2, "hello", 4)[3]} & \texttt{"hello"} & \\
\hline \texttt{list(1, 2, "hello", 4)[4]} & \rerr &\\
\hline \texttt{first(select Person).name[2] := 'X'} & \texttt{'X'} &\\
\hline
\etab

\subsubsect{Range Deferencing}
The range deferencing operators, \texttt{[:]} and \texttt{[?]},
takes as their first operand an atom of type
\texttt{string}, an indexed 
(or ordered) collection (\texttt{list} or \texttt{array})
or a non-collection array. The other operands must be of type \texttt{integer}.
The \texttt{[?]} may have also an unordered collection (\texttt{set}
or \texttt{bag} as its first operand.\\
\\
The operator syntax and semantics are as follows:
\bi
\item \ex\texttt{[}\emph{expr1}\texttt{:}\emph{expr2}\texttt{]}
\be
\item if the first operand is a string,
the returned atom is a list composed of the characters between
the \texttt{\#}\emph{expr1} and the \texttt{\#}\emph{expr2} characters
of the string.
If \emph{expr1} is less than zero or or if \emph{expr2} is greater than the
length of the string an \emph{out of bounds} error is raised.
\item for an ordered collection, the returned atom is a list composed
of the items between the \texttt{\#}\emph{expr1} and the
\texttt{\#}\emph{expr2} items
of the collection. If \emph{expr1} is less than zero or if
i \emph{expr2} iss greater than or is equal to the size of the collection, an
\emph{out of bounds} error is raised.
\item if the first operand is an non-collection array, the returned atom
is a list composed of the items between the \texttt{\#}\emph{expr1} and the
\texttt{\#}\emph{expr2} items of the array.
If \emph{expr1} is less than zero or if
i \emph{expr2} iss greater than or is equal to the size of the collection, an
\emph{out of bounds} error is raised.
\ee
\item \ex\texttt{[?]}
\be
\item if the first operand is a string,
the returned atom is a list composed of all the characters of the
string, including the last character \texttt{'{\textbackslash}000'}.
\item for an ordered or an unordered collection, the returned atom is a list composed
of all the items of the collection. If the collection is a list, the
list itself is returned. If the collection is an array, this operator
has the same functionnality as the \texttt{listtoarray} library function.
\item if the first operand is an non-collection array, the returned atom
is a list composed of the all the items of the array.
\ee
\ei
Contrary to the single deferencing operator,
the range deferencing operator cannot be used as a left value.\\
\\
The range deferencing operators may be used everywhere in a path expression.
For instance, \texttt{first(select Person).children[?].name[?]},
denotes the list of all characters of the \texttt{name} attribute
in all the \texttt{children} of the first \texttt{Person} instance.
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operators
 & \texttt{[:]} \\
 & \texttt{[?]} \\
\hline Syntaxes
& \ex\texttt{[}\ex\texttt{:}\ex\texttt{]}\\
& \ex\texttt{[?]}\\
\hline Type & ternary or unary\\
\hline Operand Types & first operand: \texttt{string} or indexed collections
(\texttt{list} or \texttt{array}), second operand and third operand:
\texttt{integer} \\
\hline Result Type & a list of \texttt{char} if first operand is a string,
otherwise a list of returned items in the indexed collection or
non-collection array.\\
\hline Functions
& \texttt{[}\emph{expr1}\texttt{:}\emph{expr2}\texttt{]} :
returns a lits of characters (or items in collection) indexed
from \emph{expr1} to \emph{expr2}\\
& \texttt{[?]} :
returns a list of all characters (or items in collection)\\
\hline
 \etab
\bettab
\btab[l]{|p{5.5cm}|p{5cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{"hello"[0:2]} & \texttt{list('h', 'e', 'l')} \\
\hline \texttt{"hello"[?]} & \texttt{list('h', 'e', 'l', 'l', 'o', '{\textbackslash}000')} \\
\hline \texttt{list(1, 2, "hello", 4)[2:3]} & \texttt{list("hello", 4)} \\
\hline \texttt{array(1, 2, "hello", 4)[?]} & \texttt{list(1, 2, "hello", 4)}\\
\hline \texttt{first(select Person).name[?]} & \texttt{list('j', 'o', 'h', 'n', '{\textbackslash}000')} \\
\hline \texttt{list(select class.type = "user")[0:4].name} &
\texttt{list("Employee", "Address", "Person")}\\
\hline
\etab

%
%\subsubsect{Multi-Dimensional Arrays}
% Presenter le multi-dimensional arrays:
% - features
% - limites (notamment concernant le range deferencing)
% - bugs
%

\subsect{Identifier Expressions}
We call an identifier expression an unary or binary expression whose operands
must be identifiers. There are height identifier operators: \texttt{::},
\texttt{isset}, \texttt{unset},  \texttt{\&} (identical to \texttt{refof}),
 \texttt{*} (identical to \texttt{valof}), \texttt{scopeof}, \texttt{push}
and \texttt{pop}.
\\
\\
As all these operators take identifiers as their operands,
we skip the second table (operand combinations) while introducing these
operators.
\subsubsect{\texttt{::} Operator}
The \texttt{::} unary/binary operator (called scope operator) is used to
define a global or particular scope for a variable.
\\
The unary version of this operator denotes a global scope.
For instance, \texttt{::alpha} denotes the global variable \texttt{alpha}.
In the body of a function, identifiers denote local variables; outside
the body of a function identifiers denote global variables, that means
that, in this context, the global scope operator is not mandatory.
If one wants to use a global variable in the body of a function, the
global scope operator is mandatory.
Refer to the Function Definition Statement Section for more information
about local function variables.\\
\\
The binary version of this operator denotes a particular scope.
For instance, \texttt{Person::checkName} denotes the class attribute
or method of the class \texttt{Person}.
\\
\\
\emph{note}: class (or static) attributes are not currently well supported
by the OQL interpreter. Class attributes are only supported in some
specific query expressions (refer to the Query Expression Section).
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operator
& \texttt{::} \\
\hline Syntax
& \unide{::} \\
& \texttt{identifier::identifier} \\
\hline Type & unary and binary\\
\hline Operand Types & \texttt{identifier }\\
\hline Result Type & value of the identifier if used as a right value;
identifier reference if used as a left value \\
\hline Function
& defines a global or particular scope for the identifier.\\
\hline
 \etab
\bettab
\btab[l]{|p{4.2cm}|p{4cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result} \\
\hline \texttt{::a} & the value of the global variable \texttt{a}\\
\hline \texttt{::alpha := 1} & sets the value of the global variable
\texttt{alpha} to \texttt{1}, returns \texttt{1}\\
\hline \texttt{Person::checkName("wayne")} & calls the class method
\texttt{checkName} in the class \texttt{Person}\\
\hline \texttt{2::alpha} & \rerr\\
\hline
\etab

\subsubsect{\texttt{isset} Operator}
The \texttt{isset} operator is used to check whether a variable
is already set or not. It returns \texttt{true} is the variable is
set, \texttt{false} otherwise.
\btab[l]{|p{3.2cm}|p{7cm}|}
\geninfo\\
\hline Operator
& \texttt{isset} \\
\hline Syntax
& \unide{isset} \\
\hline Type & unary\\
\hline Operand Type & \texttt{identifier }\\
\hline Result Type & \texttt{boolean}\\
\hline Function
& evaluated to \texttt{true} if the identifier is set, \texttt{false} otherwise\\
\hline
 \etab
\bettab
\btab[l]{|p{3.2cm}|p{4cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result} \\
\hline \texttt{isset oql\$variables} & \texttt{true} \\
\hline \texttt{isset a} & returns \texttt{true} if \texttt{a} is set, \texttt{false} otherwise\\
\hline \texttt{isset 1} & \rerr\\
\hline
\etab

\subsubsect{\texttt{unset} Operator}
The \texttt{unset} operator is used to unset an variable. It returns the
\texttt{nil} atom.
\btab[l]{\dimtab}
\geninfo\\
\hline Operator
& \texttt{unset} \\
\hline Syntax
& \unide{unset} \\
\hline Type & unary\\
\hline Operand Type & \texttt{identifier }\\
\hline Result Type & \texttt{nil}\\
\hline Function
& unset the identifier\\
\hline
 \etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result} \\
\hline \texttt{unset a} & \texttt{nil}\\
\hline \texttt{unset ::a} & \texttt{nil}\\
\hline \texttt{unset 2} & \rerr\\
\hline
\etab

\subsubsect{\texttt{refof} Operator}
The \texttt{\&} (identical to \texttt{refof}) operator is used to get the 
reference of an identifier. This operator is essentially used when
one calls a function or method which updates one or more given parameters.
For instance, let the function \texttt{swap(x, y)} which swaps the value
of its two parameters. One needs to give the references of the
variables that one wants to swap. For instance:
\verbsize
\begin{verbatim}
i := "ii";
j := "jj";

swap(&i, &j);
\end{verbatim}
\normalsize
After the call to \texttt{swap}, the variable \texttt{i} equals
\texttt{jj} while the variable \texttt{j} equals \texttt{ii}.\\
The reverse operator \texttt{*} (described following section) is used in
the swap function.
\btab[l]{|p{3cm}|p{5cm}|}
\geninfo\\
\hline Operator
& \texttt{refof} \\
& \texttt{\&} \\
\hline Syntax
& \unide{refof} \\
& \unide{\&} \\
\hline Type & unary\\
\hline Operand Type & \texttt{identifier }\\
\hline Result Type & \texttt{identifier}\\
\hline Function
& evaluates the expression to the identifier reference; returned an
identifier atom\\
\hline
 \etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result} \\
\hline \texttt{\&alpha} & \texttt{alpha} \\
\hline \texttt{refof alpha} & \texttt{alpha} \\
\hline
\etab

\subsubsect{\texttt{valof} Operator}
The \texttt{*} (identical to \texttt{valof}) operator is used to get
the value of the identifier pointed by a reference.
For instance, after the two following expressions:
\verbsize
\begin{verbatim}
alpha := 1;
ralpha := &alpha;
\end{verbatim}
\normalsize
\texttt{*ralpha} equals \texttt{1}.\\\\
This operator may be used in the composition of a left value, for instance:
\verbsize
\begin{verbatim}
alpha := 1;
ralpha := &alpha;
*ralpha := 2; // now, alpha equals 2
*ralpha += 8; // now, alpha equals 10
\end{verbatim}
\normalsize
But this operator is essentially used in the body of functions or methods which
update one or more given parameters, for instance, the function \texttt{swap}
described in the previous section is as follows:
\verbsize
\begin{verbatim}
function swap(x, y) {
    v := *x;
   *x := *y;
   *y := v;
}
\end{verbatim}
\normalsize
\mbox{}
\btab[l]{|p{3cm}|p{5cm}|}
\geninfo\\
\hline Operator
& \texttt{valof} \\
& \texttt{*} \\
\hline Syntax
& \unide{valof} \\
& \unide{*} \\
\hline Type & unary\\
\hline Operand Type & \texttt{identifier }\\
\hline Result Type & value of the identifier\\
\hline Function
& returns the value of the identifier denotes by the operand\\
\hline
 \etab\bettab\btab[l]{|p{4cm}|p{4cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result} \\
\hline \texttt{*alpha} & if \texttt{alpha} value is an atom identifier \emph{x},
returns the value of \emph{x}, otherwise an error is thrown\\
\hline \texttt{x := 12; alpha := \&x; *x} & \texttt{*x} returns \texttt{12}\\
\hline
\etab

\subsubsect{\texttt{scopeof} Operator}
The \texttt{scopeof} operator returns the string \texttt{"global"} or
\texttt{"local"} depending whether the identifier is global or local.
\btab[l]{|p{3cm}|p{5cm}|}
\geninfo\\
\hline Operator
& \texttt{scopeof} \\
\hline Syntax
& \unide{scopeof} \\
\hline Type & unary\\
\hline Operand Type & \texttt{identifier }\\
\hline Result Type & \texttt{string}\\
\hline Function
& returns the scope of the identifier.\\
\hline
 \etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result} \\
\hline \texttt{scopeof ::alpha} & returns \texttt{"global"} for any \texttt{alpha} if
it set; otherwise an error is thrown\\
\hline \texttt{scopeof alpha} & returns \texttt{"global"} or \texttt{"local"}
depending on the context.\\
\hline
\etab

\subsubsect{\texttt{push} Operator}
The \texttt{push} operator is used to push an identifier on a new local
table. This operator is rarely used.
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operator
& \texttt{push} \\
\hline Syntax
& \unide{push} \\
& \unide{push} \texttt{:=} \ex\\
\hline Type & unary and binary\\
\hline Operand Types & first operand \texttt{identifier}, optionnal second operand:
\emph{any type} \\
\hline Result Type & identifier or any type in case of an assignment\\
\hline Function
& push the identifier on to the symbol table stack. An assignment
can be performed at the same time. Returns the identifier or the
value of the expression assignment.\\
\hline
 \etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result} \\
\hline \texttt{push a} & pushes \texttt{a} on a new local symbol table.\\
\hline \texttt{push a := 10} & pushes \texttt{a} on a new local symbol table
and assigns its value to \texttt{10}\\
\hline
\etab

\subsubsect{\texttt{pop} Operator}
The \texttt{pop} operator is used to pop an identifier from a local table.
It is used after a push. For instance:
\verbsize
\begin{verbatim}
a := "hello";
a;             // a equals "hello"

push a := 10;
a;             // a equals 10

pop a;
a;             // a equals "hello"
\end{verbatim}
\normalsize
\mbox{}
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operator
& \texttt{pop} \\
\hline Syntax
& \unide{pop} \\
\hline Type & unary\\
\hline Operand Type & \texttt{identifier }\\
\hline Result Type & the type of the value of the identifier\\
\hline Function
& pop the identifier from the symbol table stack\\
\hline
 \etab
\bettab
\btab[l]{\dimtab}
\expex{2}\\
\hline \emph{expression} & \emph{result} \\
\hline \texttt{pop a} & returns the value of \texttt{a} if it is set; otherwise
an error is returned\\
\hline
\etab

\subsect{Path Expressions}
The path expression operator \texttt{->} (identical to \texttt{.}) is used
to \emph{navigate} from an object
and read the right data one needs. This operator enables us to go
inside complex objects, as well as to follow simple relationships.
For instance, if \texttt{p} denotes a \texttt{Person} instance,
\texttt{p.spouse} denotes the \texttt{spouse} attribute of this person.\\
The more complex expression \texttt{p.spouse.address.street} denotes
the \texttt{street} in the \texttt{address} of \texttt{spouse} of the
person \texttt{p}. This notation is very intuitive because it looks like the
well known \texttt{C}, \texttt{C++} and \texttt{Java} syntaxes.\\
\\
The path expression operator may composed a left value, for instance:
\begin{verbatim}
p.spouse.name := "mary";
\end{verbatim}
set the \texttt{name} of the \texttt{spouse} of the person \texttt{p}
to \texttt{mary}.\\
\\
This operator may be combined with the array deferencing operators, for
instance:
\begin{verbatim}
p.spouse.name[2];
p.spouse.name[2] := 'A';
p.spouse.other_addrs[2].street[3] := 'C';
p.spouse.children[?];
p.spouse.children[?].name;
\end{verbatim}
The path expression operator may be also used to navigate through
\texttt{struct} atom, for instance:
\texttt{(struct(a : 1, b : "hello")).b} returns \texttt{"hello"}. Note
that because of the precedence of operators, parenthesis are necessary
around the literal \texttt{struct} construct.\\
Finally, the path operator may be applied to a collection; in this
case a collection of the same type of this operand is returned.
For instance:\\
\texttt{(select Person).name} returns a \texttt{bag} of \texttt{string}.\\
\texttt{(select distinct Person).age} returns a \texttt{set} of
\texttt{int}.\\
Note that the path expression operator is used frequently in the query
expressions as shown in a next section.
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operators
 & \texttt{.} \\
 & \texttt{->} \\
\hline Syntaxes
& \bin{.}\\
& \bin{->}\\
\hline Type & binary\\
\hline Operand Types & first operand: \texttt{oid} or \texttt{object},
second operand: identifier \\
\hline Result Type & type of the attribute denoted by the second operand\\
\hline Functions
& returns the attribute value denoted by second operand of the object
denoted by the first operand\\
& The first operand must denote an \eyedb instance (object or literal) of
an agregat including the attribute denoted by the second operand.\\
\hline Note & these two operators are identical\\
\hline
 \etab\bettab\btab[l]{|p{5cm}|p{3cm}|p{3cm}|}
\expex{3}\\
\hline \emph{expression} & \emph{result} & \emph{comments}\\
\hline \texttt{p->name} & \emph{the value of attribute}
\texttt{name} \emph{in the object denoted by} \texttt{p} &
\texttt{p} must denote an \eyedb instance (object or literal) of
an agregat including the attribute \texttt{name}\\
\hline \texttt{first(select x Person x from x.lastname = "wayne")->lastname} & \texttt{"wayne"} & \\
\hline
\etab

\subsect{Function Call}
OQL allows one to call an OQL function with or without parameters.
The operator for function call is \texttt{()}.\\
A function call may be the first term of a path expression, for instance:
\texttt{first(select Person)->name}.\\
Contrary to the method invocation, there are no function overloading
mechanisms: that means, that one cannot have differents functions with
the same name and a different signature.
To take benefit of the overloading mechanisms, one must use methods.
\\
\emph{Note}: contrary to the ODMG 3 specifications, one currently needs
to use parenthesis to invoke a method even if the method has no arguments.
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operator & \texttt{()} \\
\hline Syntaxe
& \ex \texttt{(}\emph{expr\_list}\texttt{)}\\
\hline Type & n-ary\\
\hline Operand Types & first operand: \texttt{identifier},
other operands: \emph{any type}\\
\hline Returned type & type of the returned atom by the function call\\
\hline Functions
& calls the OQL function denoted by the first operand using the other operands
as arguments. The number of operands must be equal to the number of
arguments of the OQL function plus one\\
\hline
 \etab\bettab\btab[l]{|p{5cm}|p{3cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{fact(10)} & \texttt{3628800}\\
\hline \texttt{fact(fact(3))} & \texttt{720}\\
\hline \texttt{toUpper("hello world")} & \texttt{"HELLO WORLD"}\\
\hline \texttt{toUpper("hello") + "world"} & \texttt{"HELLOworld"}\\
\hline \texttt{interval(1, 5)} & \texttt{list(1, 2, 3, 4, 5)}\\
\hline \texttt{swap(\&i, \&j)} & \texttt{nil}\\
\hline \texttt{first(select Person).spouse.name} & \texttt{"mary"}\\
\hline
\etab

\subsect{Method Invocation}
\subsubsect{Instance Method Invocation}
OQL allows one to call a instance method with or without parameters.
The method can be written in C++ or in OQL.
As in C++, method calls use a combination of the path expression operator and
the function call operator.\\\\
As in \texttt{C++} or \texttt{Java}, methods can be overloaded: that
means that one can have differents methods with the same name and a
different signature or differents methods with the same name
and the same signature in a class hierarchy.
The choice of the method to invoke
is done at evaluation time not at compile time.
For instance let two
methods \texttt{Person Person::f(in int, in int)} and \texttt{int Person::f(in float, in string)},
the method to be invoked in the expression \texttt{p->f(x, y)} is decided
at evaluation time according to the true types of \texttt{x} and \texttt{y}:
\verbsize
\begin{verbatim}
p := first(select Person);

x := 1; y := 2;

p->f(x, y); // X::f(in int, in int) is invoked
p->f(x, y)->name; // this is valid because p->f(x, y) returns a Person

x := 1.3; y := "hello";

p->f(x, y); // X::f(in float, in string) is invoked
p->f(x, y)->name; // this is not valid because p->f(x, y) returns an integer
\end{verbatim}
\normalsize
A major contribution of object orientation is the possibility of manipulating
polymorphic objects and thanks to the late binding mechanism
to carry out generic actions on the elements of these objects.\\
For instance, let the two
methods \texttt{void Person::doit(in int)}
and \texttt{void Employee::doit(in int)},
the method to be invoked in the expression \texttt{p->doit(x)} is decided
at evaluation time according to the true type of \texttt{p}:
\verbsize
\begin{verbatim}
p := new Person();
p->doit(1); // Person::doit(in int) is invoked

p := new Employee();
p->doit(1); // Employee::doit(in int) is invoked
\end{verbatim}
\normalsize
To invoke a method, the following conditions must be realize:
\be
\item the object or oid on which the method is applied must be
an instance of a class, for instance \texttt{X}.
\item the name of the invoked method, the number and the type of arguments
must be compatible with an existing method in the class \texttt{X},
\item the result type must match the expected type in the expression.
\ee
For instance, let the methods \texttt{int compute(in int, int float)} and
\texttt{int compute(in int, in float, in int[], out string)}
in the class \texttt{X}.
To invoke the first method on an instance of \texttt{X}, one needs to
apply the method \texttt{compute} to an instance of \texttt{X}
with one integer and one float, for instance:
\verbsize
\begin{verbatim}
x := new X();

x.compute(1, 2.3);
x.compute(a := fact(10), float(fib(10)));
\end{verbatim}
\normalsize
To invoke the second method on an instance of \texttt{X}, one needs to
apply the method \texttt{compute} to an instance of \texttt{X}
with an integer, a float, an ordered collection of integer and a reference
to a variable, for instance:
\verbsize
\begin{verbatim}
x.compute(1, 23.4, list(1, 2, 3, 4), &a);
\end{verbatim}
\normalsize
The following table shows the mapping (which defines the compatibility)
between the ODL and the OQL types.
\\
\\
\newcommand{\odlbind}[3]{\hline\hline\texttt{in} #1 & #2\\
\hline \texttt{out} #1 & \texttt{identifier}\\
\hline \texttt{inout} #1 & \texttt{identifier} initialized to a\emph{#3} #2}
\newcommand{\denote}{(\texttt{X} \emph{denotes a class instance})}
\newcommand{\denotex}{(\texttt{X} \emph{denotes any ODL type})}
\begin{longtable}{|p{6cm}|p{6cm}|}
%\tablehead{\hline}
%\tabletail{\hline}
\hline \multicolumn{2}{|c|}{\emph{ODL/OQL Mapping}}\\
\hline ODL Type & OQL Type\\
 \odlbind{\texttt{int16}}{\texttt{integer}}{n}\\

 \odlbind{\texttt{int32}}{\texttt{integer}}{n}\\

 \odlbind{\texttt{int64}}{\texttt{integer}}{n}\\

 \odlbind{\texttt{byte}}{\texttt{char}}{}\\

 \odlbind{\texttt{char}}{\texttt{char}}{}\\

 \odlbind{\texttt{string}}{\texttt{string}}{}\\

 \odlbind{\texttt{float}}{\texttt{float}}{}\\

 \odlbind{\texttt{oid}}{\texttt{oid}}{}\\

 \odlbind{\texttt{object *}}{\texttt{oid} of any class}{n}\\

 \odlbind{\texttt{X *} \denote}{\texttt{oid} of class \texttt{X}}{}\\

 \odlbind{\texttt{X *[]} \denote}{ordered collection of \texttt{oid} of class \texttt{X}}{n}\\

 \odlbind{\texttt{X[]} \denotex}{\emph{ordered collection} of atoms bound to \texttt{X}}{n}\\
\hline
\end{longtable}
\emph{Note}: contrary to the ODMG 3 specifications, one currently needs
to use parenthesis to invoke a method even if the method has no arguments.
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operators
 & \texttt{.} \\
 & \texttt{->} \\
\hline Syntaxes
& \bin{.}\texttt{(}\emph{expr\_list}\texttt{)}\\
& \bin{->}\texttt{(}\emph{expr\_list}\texttt{)}\\
\hline Type & n-ary\\
\hline Operand Types & first operand: \texttt{oid} or \texttt{object},
second operand: identifier, other operands: any type\\
\hline Result Type & 
type of the atom returned by the method call\\
\hline Functions
& invokes the method denoted by the second operand applied to the
object denoted by the first operand, using the other operands as arguments.\\
& The first operand must denote an \eyedb instance (object or literal) of
an agregat including the method whose name is the second operand.
The number of arguments and the type of arguments must match one of
the methods included in the class of the object denoted by the first operand.\\

\hline Note & these two operators are identical\\
\hline
\etab\bettab\btab[l]{|p{4cm}|p{3cm}|p{3cm}|}
\expex{3}\\
\hline \emph{expression} & \emph{result} & \emph{comments}\\
\hline \texttt{p->getOid()} & \emph{the value of the oid of object denoted by}
\texttt{p} & as \texttt{getOid()} is a native method of the class
\texttt{object}, each object can call
this method\\
\hline \texttt{img->compute(1, 2.3)} & \emph{the value returned by the method call} & 
the first operand must denote an \eyedb instance (object or literal) of
an agregat including the method whose name is \texttt{compute}\\
\hline \texttt{first(select Person.name = "wayne").getSpouse()} & \emph{the value returned by the method call} &\\
\hline
\etab
\subsubsect{Class Method Invocation}
OQL allows one to call a class method with or without parameters.
The method can be written in C++ or in OQL.
As in C++, method calls use a combination of the scope operator and
the function call operator.
To invoke a class method, the following conditions must be realize:
\be
\item the name of the invoked method, the number and the type of arguments
must be compatible with an existing method in the class \texttt{X},
\item the result type must match the expected type in the expression.
\ee
The overloading and the late binding mechanisms are the same as for
the instance method invocations.
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operator
 & \texttt{::} \\
\hline Syntaxe
& \texttt{identifier::identifier(}\emph{expr\_list}\texttt{)}\\
\hline Type & n-ary\\
\hline Operand Types & first operand: \texttt{identifier},
second operand: \texttt{identifier},
other operands: \emph{any type}\\
\hline Result Type & type of the atom returned by the method call\\
\hline Functions
& invokes the class method denoted by the second operand applied to the
class denoted by the first operand, using the other operands as arguments.\\
& The first operand must denote an \eyedb class of
an agregat including the class method whose name is the second operand.
The number of arguments and the type of arguments must match one of
the class methods included in the class denoted by the first operand.\\
\hline
 \etab\bettab\btab[l]{|p{4.5cm}|p{3cm}|p{3cm}|}
\expex{3}\\
\hline \emph{expression} & \emph{result} & \emph{comments}\\
\hline \texttt{EyeDB::getVersion()} & \texttt{\eyedbversion} &
\texttt{getVersion()} is a native static method of the class \texttt{EyeDB}\\
\hline \texttt{Person::checkName("johnny")} & \emph{the value returned by the method call} & 
the class method \texttt{checkName} must exist in the class \texttt{Person}
and must take one and only one input string argument.\\
\hline
\etab

\subsect{Eval/Unval Operators}
\subsubsect{\texttt{eval} Operator}
One major feature of OQL is that one can invoke its evaluator using
the \texttt{eval} operator. This allows us to build OQL constructs at
runtime and perform their evaluation. This is very useful, for instance,
when we want to build a query expression where the projection or
the \texttt{from} reference sets are is unknown. For instance, the following
function allows us to retrieve the values of the attribute \emph{attrname}
in the class \emph{classname}:
\verbsize
\begin{verbatim}
function getValues(classname, attrname) {
  cmd := "select x." + attrname + " from " + classname + " x";
  return (eval cmd);
}
\end{verbatim}
\normalsize
\mbox{}
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operator & \texttt{eval} \\
\hline Syntaxe
& \texttt{eval string}\\
\hline Type & unary\\
\hline Operand Types & \texttt{string }\\
\hline Functions
& calls the OQL evaluator on the string operand. The string operand
can contain any OQL valid construct: an expression, a statement or a
sequence of statements.\\
\hline
 \etab\bettab\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{eval "10"} & \texttt{10}\\
\hline \texttt{eval "a := 100"} & result is \texttt{100}; the variable \texttt{a}
is set to \texttt{100}\\
\hline \texttt{eval "a := {\textbackslash}"hello{\textbackslash}"; b := a + {\textbackslash}"world{\textbackslash}""} &result is \texttt{"hello world"}; the variable \texttt{a} is set to \texttt{"hello"}; the variable \texttt{b} is set to \texttt{"hello world"}\\
\hline
\etab

\subsubsect{\texttt{unval} Operator}
The \texttt{unval} is the inverse of the \texttt{unval} in the sense
that it takes any valid OQL expression and returns the string representation;
the comments and, when not necessary,
the spaces and tabulations are skipped.
For instance, the construct \texttt{unval a := 10} returns
\texttt{"(a:=10)"}.\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operator & \texttt{unval} \\
\hline Syntax
& \texttt{unval} \ex\\
\hline Type & unary\\
\hline Operand Types & \emph{any type}\\
\hline Functions
& returns the string expression\\
\hline
 \etab\bettab\btab[l]{|p{5cm}|p{5cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{unval 10} & \texttt{"10"}\\
\hline \texttt{unval alpha += 10 - beta + 1} & \texttt{"(alpha:=(alpha+((10-beta)+1)))"}\\
\hline \texttt{eval unval alpha := "hello"} & returns \texttt{"hello"};
\texttt{alpha} is set to \texttt{"hello"}\\
\hline
\etab

\subsect{Set Expressions}
OQL allows us to perform the following operations on \texttt{set}s and
\texttt{bag}s: union, intersection,
difference and inclusion. The operands can be sets or bags.
For all these operators, when the operand's collection types are different
(\texttt{bag} and \texttt{set}), the set is first converted to a bag and
the result is a bag.
\subsubsection{\texttt{union} Operator}
The \texttt{union} operator performs the union of two \texttt{set}s or
\texttt{bag}s.
This operator has the same precedence as the logical or operator.
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operator & \texttt{union} \\
\hline Syntax
& \bin{union}\\
\hline Type & binary\\
\hline Operand Types & \texttt{set} or \texttt{bag}\\
\hline Result Type & \texttt{set} if both two operands are of type
\texttt{set}, \texttt{bag} otherwise\\
\hline Functions
& returns the union of the two operands.\\
\hline
 \etab\bettab\btab[l]{|p{5cm}|p{5cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{set(1, 2) union set(2, 3)} & \texttt{set(1, 2, 3)}\\
\hline \texttt{set(1, 2) union bag(2, 3)} & \texttt{bag(1, 2, 2, 3)}\\
\hline \texttt{list(1, 2) union bag(2, 3)} & \rerr\\
\hline
\etab
\subsubsection{\texttt{intersect} Operator}
The \texttt{intersect} operator performs the intersection of two
\texttt{set}s or \texttt{bag}s.
This operator has the same precedence as the logical and operator.
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operator & \texttt{intersect} \\
\hline Syntax
& \bin{intersect}\\
\hline Type & binary\\
\hline Operand Types & \texttt{set} or \texttt{bag}\\
\hline Result Type & \texttt{set} if both two operands are of type
\texttt{set}, \texttt{bag} otherwise\\
\hline Functions
& returns the intersection of the two operands.\\
\hline
 \etab\bettab\btab[l]{|p{6.5cm}|p{5cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{set(1, 2) intersect set(2, 3)} & \texttt{set(2)}\\
\hline \texttt{set(1, 2) intersect bag(2, 3)} & \texttt{bag(2)}\\
\hline \texttt{bag(1, 2, 2, 3) intersect bag(2, 3, 2)} & \texttt{bag(2, 2, 3)}\\
\hline \texttt{list(1, 2) intersect bag(2, 3)} & \rerr\\
\hline
\etab
\subsubsection{\texttt{except} Operator}
The \texttt{except} operator performs the difference between two
\texttt{set}s or \texttt{bag}s.
This operator has the same precedence as the logical or operator.
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operator & \texttt{except} \\
\hline Syntax
& \bin{except}\\
\hline Type & binary\\
\hline Operand Types & \texttt{set} or \texttt{bag}\\
\hline Result Type & \texttt{set} if both two operands are of type
\texttt{set}, \texttt{bag} otherwise\\
\hline Functions
& returns the difference of the two operands.\\
\hline
 \etab\bettab\btab[l]{|p{5cm}|p{5cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{set(1, 2) except set(2, 3)} & \texttt{set(1)}\\
\hline \texttt{set(1, 2) except bag(2, 3)} & \texttt{bag(1)}\\
\hline \texttt{set(1, 2, 10) except bag(12)} & \texttt{bag(1, 2, 10)}\\
\hline \texttt{list(1, 2) except bag(2, 3)} & \rerr\\
\hline
\etab
\subsubsection{Inclusion Operators}	
The inclusion operators for \texttt{set}s and \texttt{bag}s are
the comparison operators \emph{less than/greater than} introduced in a
previous section.
\btab[l]{|p{3cm}|p{7cm}|}
\geninfo\\
\hline Operator
& \texttt{<} \\
& \texttt{<=} \\
& \texttt{>} \\
& \texttt{>=} \\
\hline Syntax
& \bin{<}\\
& \bin{<=}\\
& \bin{>}\\
& \bin{>=}\\
\hline Type & binary\\
\hline Operand Types & \texttt{set} or \texttt{bag}\\
\hline Result Type & \texttt{boolean}\\
\hline Functions
& \emph{coll1} \texttt{<} \emph{coll2} : returns \texttt{true} if and only
if \emph{coll1} is included in \emph{coll2} but not equal to \emph{coll2}\\
& \emph{coll1} \texttt{>} \emph{coll2} : returns \texttt{true} if and only
if \emph{coll2} is included in \emph{coll1} and not equal to \emph{coll1}\\
& \emph{coll2} \texttt{<=} \emph{coll1} : returns \texttt{true} if and only
if \emph{coll1} is included in \emph{coll2} or equal to \emph{coll2}\\
& \emph{coll1} \texttt{>=} \emph{coll2} : returns \texttt{true} if and only
if \emph{coll2} is included in \emph{coll1} or equal to \emph{coll1}\\
\hline
 \etab\bettab\btab[l]{|p{5cm}|p{5cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{set(1, 2) < set(2, 3)} & \texttt{false}\\
\hline \texttt{set(1, 2) < set(2, 3, 1)} & \texttt{true}\\
\hline \texttt{set(1, 2) < bag(2, 3, 1)} & \texttt{true}\\
\hline \texttt{set(1, 2) <= bag(2, 1)} & \texttt{false}\\
\hline \texttt{set(1, 2) >= bag(2, 1)} & \texttt{false}\\
\hline
\etab

\subsect{Object Creation}
OQL allows us to create persistent or transient objects using the
\texttt{new} operator.
The general syntax for an object creation is as follows:\\
\mbox{ } [\texttt{new}] [\texttt{<}[\emph{expr}]\texttt{>}] 
\emph{class\_name}\texttt{(}\{\emph{path\_expression} \texttt{:} \ex\}\texttt{)}\\
\be
\item the operator \texttt{new} is optionnal: when the operator is missing,
the construct is called an implicit \texttt{new} construct. When
the optionnal following construct ``\texttt{<}[\emph{expr}]\texttt{>}'' is
not used, there is
no functionnal differences between using \texttt{new} or not.
\item the optionnal construct after the \texttt{new} operator indicates
the target location of the object to create:
\be
\item if this construct is omitted, the object will be a 
persistent object created in the current default database,
\item if this construct is under the form \texttt{<}\emph{expr}\texttt{>},
the OQL interpreter expects for a database object handle as the result
of the expression evaluation. This database will be used as the target
location. For instance:
\verbsize
\begin{verbatim}
new < oql$db > Person();
\end{verbatim}
\normalsize
will create a \texttt{Person} instance in the database pointed by
\texttt{oql\$db}, which is in fact the current database.
\item if this construct is under the form \texttt{<}\texttt{>},
the object will be a transient object.
\ee
\item the \emph{class\_name} indicates the name of a valid user
type in the context of the current database.
\item the \emph{path\_expression} indicates an attribute name or
a sequence of attributes using the optional array operator, for instance
the following path expressions are valid for an object construction:
\verbsize
\begin{verbatim}
name
lastname
addr.street
addr.town[3]
spouse.name
\end{verbatim}
\normalsize
\item the \emph{expr} behind \emph{path\_expression} is any OQL expression
as soon as its result type matches the expected type of the \emph{path\_expression}.
\item the order of evaluation of the expressions is in the
\{\emph{path\_expression} \texttt{:} \emph{expr}\} sequence is from left
to right.
\item the expression returns the oid of the created object.
\ee
For instance:
\bi
\item \texttt{new Person()} creates a person with all its attributes
unitialized,
\item \texttt{Person()} creates a person with all its attributes
unitialized,
\item \texttt{new Person(name : "john")} creates a person with its
attribute \texttt{name} initialized to \texttt{john},
\item \texttt{Person(name : "john")} creates a person with its
attribute \texttt{name} initialized to \texttt{john},
\item \texttt{new Person(name : "john", age : 32, spouse : new Person(name :
"mary"))} creates a person named \texttt{mary} and a person named
\texttt{john}, age \texttt{32} whose \texttt{spouse} is the person
\texttt{mary}.
\ei
The \texttt{new} operator can also be used to create basic type
object. Note that in this case, the operator is mandatory.
The syntax for basic type creation is as follows:\\
\mbox{ } \texttt{new} [\texttt{<}[\emph{expr}]\texttt{>}] \emph{basic\_type}
\texttt{(}\emph{value}\texttt{)}.
\be
\item where \emph{basic\_type} denotes an ODL basic type.
It may be one of the following type:
\texttt{int32}, \texttt{int16}, \texttt{int32},
\texttt{char}, \texttt{byte}, \texttt{float} or \texttt{oid}. Note
that the type \texttt{string} is not allowed here.
\item the \emph{value} must be an atomic value of an OQL type mapped
from the ODL basic type
\ee
For instance:
\bi
\item \texttt{new int(2)}
\item \texttt{new float(2.3)}
\item \texttt{new float(2)}
\item \texttt{new char('a')}
\item \texttt{new oid(first(select Person))}
\ei
Finally, the \texttt{new} operator can be also used to create collections.
The syntax for collection creation is as follows:\\
\mbox{ } [\texttt{new}] [\texttt{<}[\emph{expr}]\texttt{>}] \emph{coll\_type}\texttt{<}
\emph{class\_name} [, \emph{coll\_name]}\texttt{> (}[\emph{collection of elements}]\texttt{)}
\be
\item the \texttt{new} operator is optionnal,
\item where \emph{coll\_type} denotes type of the collection:
\texttt{set}, \texttt{bag}, \texttt{array} or \texttt{list},
\item the \emph{class\_name} denotes the name of the class
of the elements of the collection, for instance \texttt{Person*},
\texttt{Car*},
\item \emph{coll\_name} is an optionnal string which denotes the name
of the collection to create,
\item the optionnal \emph{collection of elements} within parenthesis
contains the elements (generally oids) to insert initially in
the created collection,
\item the expression returns the oid of the created collection.
\ee
For instance:
\bi
\item \texttt{new set<Person *>()} creates an empty \texttt{set} of persons,
\item \texttt{new set<Person *>(list(select Person))} creates a \texttt{set} containing
all the persons in the database,
\item \texttt{new set<Person *, "all babies">(list(select Person.age < 1))} creates a \texttt{set} named \texttt{all babies} containing
all the persons whose age is less than \texttt{1}.
\item \texttt{new array<Car *>()} creates an empty \texttt{array} of cars.
\item \texttt{new array<int>(list(1, 2, 3, 4)} creates an \texttt{array}
of integers initially containing \texttt{1, 2, 3, 4}.
\item \texttt{new set<int *> (list(new int(2), new int(10)))} creates
a \texttt{set} of integer objects containing initially two
integer objects.
\ei
\mbox{ }
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{new} \\
\hline Syntax
& \texttt{new} [\texttt{<}[\emph{expr}]\texttt{>}] 
\emph{class\_name}\texttt{(}\{\emph{path\_expression} \texttt{:} \ex\}\texttt{)}\\
\hline Type & n-ary\\
\hline Operand Types & \emph{any type}\\
\hline Result Type & \texttt{oid} or \texttt{object}\\
\hline Functions
& creates an persistent or transient object\\
\hline
\etab\bettab\btab[l]{|p{6cm}|p{5cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \begin{verbatim}
john := new Person(name: "john",
                   lastname: "wayne",
                   age : fib(10));
\end{verbatim}
& returns the oid of the created \texttt{Person} instance\\

\hline \begin{verbatim}
new Person(name: "mary",
           lastname: "poppins",
           addr.town : "jungle",
           addr.street[0] : 'a',
           addr.street[1] : 'b',
           spouse : john,
           spouse.age : 72
           );
\end{verbatim}
& returns the oid of the created \texttt{Person} instance\\
\hline
\etab

\subsect{Object Deletion}
The \texttt{delete} unary operator is used to delete persistent
objects.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{delete} \\
\hline Syntax
& \texttt{delete} \ex\\
\hline Type & unary\\
\hline Operand Types & \texttt{oid} or \texttt{object}\\
\hline Result Type & the operand type\\
\hline Functions
& delete a transient or persistent object\\
\hline
\etab\bettab\btab[l]{|p{6cm}|p{5cm}|}
\expex{2}\\
\hline \emph{expression} & \emph{result}\\
\hline \texttt{delete first(select Person)} & the oid of the deleted \texttt{Person} instance\\
\hline \texttt{delete new Person()} & the oid of the deleted \texttt{Person} instance\\
\hline \texttt{for (x in (select Person) delete x} &
the oids of the deleted \texttt{Person} instances\\
\hline
\etab

\subsect{Collection Expressions}
\label{collexp}
OQL introduces a few operators for object collection manipulation:
one of them is the array deferencing operator ``\texttt{[]}''
(\ref{arraydef}) that
is overloaded for ordered collection manipulation.\\
Some them are ODMG OQL compliant, the others are \eyedb extensions.
Object collections may be persistent or transient, orderered or not.
These operators allows us to make the following kind of operations:
\be
\item gets the contents of a collection: operator \texttt{contents},
\item get an element at a given position in an ordered collection:
operator \texttt{[]} (ODMG compliant),
\item get elements at some given positions in an ordered collection:
operators \texttt{[:]} (ODMG compliant) and \texttt{[?]},
\item checks if an element is in a collection: operator \texttt{in} (ODMG
compliant),
\item add an element in an unordered collection:
operator \texttt{add/to}
\item suppress an element from an unordered collection:
operator \texttt{suppress/from},
\item set or suppress an element in an ordered at a given position:
operator \texttt{[]},
\item set or suppress elements in an ordered at a given position:
operators \texttt{[:]} and \texttt{[?]},
\item append an element in an ordered collection:
operator \texttt{append/to},
\item checks if a given condition is realized for at least one
element in a collection: operator \texttt{in} (ODMG compliant),
\item checks if a given condition is realized for all
elements in a collection: operator \texttt{for/all} (ODMG compliant),
\item checks if a given condition is realized for a given
number range of elements in a collection: operator extended \texttt{for}.
\ee
In all the following examples, the OQL variables \texttt{p0} denotes
the first \texttt{Person} instance in the database:
\texttt{p0 := first(select Person)}.\\\\
{\bf Important Note}: although they are reference in the following
descriptions of collection operators,
the object collections \texttt{list} are not
implemented in the current version of \eyedbX. 
\subsubsect{\texttt{contents} Operator}
The \texttt{contents} unary operator is used to give the contents of
a given ordered or unordered object collection. It returned an OQL
collection of the same type of the object collection: \texttt{set},
\texttt{bag}, \texttt{array} or \texttt{list}.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{contents} \\
\hline Syntax
& \una{contents} \\
\hline Type & unary\\
\hline Operand Types & \texttt{oid} or \texttt{object} collection\\
\hline Result Type & a collection of objects\\
\hline Functions
& returns the contents of an object collection\\
\hline
\etab\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{contents(p0.children)} &
an \texttt{array} of \texttt{Person} \texttt{oid}s\\
\hline \texttt{select contents(x.children) from Person x} &
returns a \texttt{list} of \texttt{array}s of \texttt{Person} \texttt{oid}s.\\
\hline \texttt{contents(list(1, 2, 3))} & \rerr: 
\texttt{oid or object expected, got list}\\
\hline
\etab

\subsubsect{\texttt{in} Operator}
The \texttt{in} operator is used to check if a given element is
in ordered or unordered object collection.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{in} \\
\hline Syntax
& \bin{in} \\
\hline Type & binary\\
\hline Operand Types & first operand: \emph{any type},
second operand: \texttt{oid} or \texttt{object} collection\\
\hline Result Type & \texttt{boolean}\\
\hline Functions
& returns \texttt{true} if the first operand belongs to the collection
pointed by the second operand; \texttt{false} otherwise\\
\hline
\etab\bettab\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{first(select Person.name = NULL) in p0.children} &
returns true if the first \texttt{Person} instance
whose \texttt{name} is unitialized
is in the \texttt{array} of \texttt{children} of the first \texttt{Person}\\
\hline \texttt{first(select Car.brand = "renault") in p0.cars} &
returns true if the first \texttt{Car} instance whose
\texttt{brand} equals \texttt{renault}
is in the \texttt{set} of \texttt{cars} of the first \texttt{Person}\\
\hline
\etab

\subsubsect{\texttt{add/to} Operator}
The \texttt{add/to} operator is used to add an element in an
unordered collection (\texttt{set} or \texttt{bag}).
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{add/to} \\
\hline Syntaxes
& \texttt{add} \ex \texttt{to} \ex \\
\hline Type & binary\\
\hline Operand Types & first operand: \emph{any type},
second operand: \texttt{oid} or \texttt{object} unorderered collection
(\texttt{set} or \texttt{bag})\\
\hline Result Type & type of the first operand\\
\hline Functions
& adds the first operand to the non-indexed collection (i.e. bag or set)
pointed by the second operand; returns the first operand.\\
\hline
\etab\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{add new Car(num : 100) to
p0.cars} & returns the created \texttt{Car} oid\\
\hline \texttt{add new Person(name : "john") to
p0.children} &
\rerr: \texttt{cannot used non indexed insertion in an array}\\
\hline \texttt{add new Car() to new set<Car *>()} &
returns the just created car; but we have \emph{lost} the
oid of the just created \texttt{set} of cars!\\
\hline \texttt{add new Person() to (c := new bag<Person *>())} &
returns the just created person; the created bag has been kept in
the OQL variable \texttt{c}\\
\hline
\etab

\subsubsect{\texttt{[]} Operator}
The polymorphic \texttt{[]} operator is used to set or get an element in an
ordered collection (\texttt{array} or \texttt{list}) at a given position:
it can be used in a right or left value.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{[]} \\
\hline Syntaxes
& \ex \texttt{[} \ex \texttt{]} \\
\hline Type & binary\\
\hline Operand Types & first operand: collection \texttt{array} or
\texttt{list}, second operand: \texttt{integer}\\
\hline Result Type & the type of the element,\\
\hline Functions
& gets the element in the collection pointed by the first operand
at the position pointed by the second operarand. If used at a left
value, gets a reference to that element.\\
\hline
\etab\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{p0.children[0]} &
 returns the child at position \#0 in \texttt{p0.children} collection.
Returns \texttt{nil} if there is no child at this position\\
\hline \texttt{p0.children[0] := Person(name : "john")} &
 returns the created \texttt{Person} oid\\
\hline \texttt{p0.children[12039] := Person(name : "henry")} &
 returns the created \texttt{Person} oid. This expression is valid in
any cas as the collection \texttt{array}s automatically increased its
size\\
\hline \texttt{(array<Person *>())[0] := new Car(num : 100)} &
returns the just created person; but the created array has been ``\emph{lost}''
as it is not tied to any instance and as we did not bind it to any
OQL variable\\
\hline \texttt{(c := array<Person *>())[0] := new Car(num : 100)} &
returns the just created person; the created array has been kept in
the OQL variable \texttt{c}\\
\hline \texttt{p0.cars[1] := Car(num : 100)} &\rerr: \texttt{array expected, got set}\\
\hline
\etab

\subsubsect{\texttt{[:]} Operator}
The polymorphic \texttt{[:]} operator is used to set or get some elements in an
ordered collection (\texttt{array} or \texttt{list}) at some given positions:
it can be used in a right or left value.
When used in a right value, the returned atom is a \texttt{set} of
\texttt{struct} with the two attributes \texttt{index} and \texttt{value}.
In each \texttt{struct} element returned, the value of \texttt{index} is
the position of the element, the value of \texttt{value} is the element
value. Note the returned \texttt{struct} elements are not ordered according
to the element postions; it is why a \texttt{set} is returned.
When used as a left value, the returned atom is a \texttt{set} of
references on the elements .
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{[:]} \\
\hline Syntaxes
& \ex \texttt{[} \ex \texttt{:} \ex \texttt{]} \\
\hline Type & ternary\\
\hline Operand Types & first operand: collection \texttt{array} or
\texttt{list}, second and third operands: \texttt{integer}\\
\hline Result Type & the type of the element,\\
\hline Functions
& gets the elements in the collection pointed by the first operand
at the position range pointed by the second and third operarands.
If used at a left value, gets references to that elements.\\
\hline
\etab\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{p0.children[0:1]} &
 returns a set of \texttt{struct} including the children and the position
of the children position \#0 and \#1 in the \texttt{p0.children} collection.
For instance: \texttt{set(struct(index : 0, value : 3874.33.293847:oid),
struct(index : 1, value : 2938.33.1928394:oid))}\\
Returns \texttt{nil} if there is no child at these positions\\
\hline \texttt{p0.children[0:4] := Person(name : "john")} &
Sets all the children at the position \#0 to \#4 to a new \texttt{Person} instance.
\\
returns the created \texttt{Person} oid\\
\hline \texttt{p0.children[12000:12039] := Person(name : "henry")} &
 returns the created \texttt{Person} oid. This expression is valid in
any cas as the collection \texttt{array}s automatically increased its
size\\
\hline \texttt{(array<Person *>(list(Person())))[0]} &
returns the just created person within the just created array.
But the array is ``\emph{lost}''
as it is not tied to any instance and as we did not bind it to any
OQL variable\\
\hline \texttt{(x := array<Person *>(list(Person())))[0]} &
returns the just created person; the created array has been kept in
the OQL variable \texttt{c}\\
\hline
\etab

\subsubsect{\texttt{[?]} Operator}
The polymorphic \texttt{[?]} operator is used to set or get all the
elements in an ordered collection (\texttt{array} or \texttt{list}).
It can be used in a right or left value.
When used in a right value, the returned atom is a \texttt{set} of
\texttt{struct} with the two attributes \texttt{index} and \texttt{value}.
In each \texttt{struct} element returned, the value of \texttt{index} is
the position of the element, the value of \texttt{value} is the element
value. Note the returned \texttt{struct} elements are not ordered according
to the element postions; it is why a \texttt{set} is returned.\\
When used as a left value, the returned atom is a \texttt{set} of
references on the elements .
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{[?]} \\
\hline Syntaxes
& \ex \texttt{[?]}\\
\hline Type & unary\\
\hline Operand Type & collection \texttt{array} or
\texttt{list},\\
\hline Result Type & a set of \texttt{struct} or a set of references\\
\hline Functions
& gets all the elements in the collection pointed by the first operand
If used at a left value, gets references to that elements.\\
\hline
\etab\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{p0.children[?]} &
 returns a set of \texttt{struct} including the children and the position
of all the children in the \texttt{p0.children} collection.
For instance: \texttt{set(struct(index : 0, value : 3874.33.293847:oid),
struct(index : 1, value : 2938.33.1928394:oid))}\\
Returns \texttt{nil} if the collection is empty\\
\hline \texttt{p0.children[?] := Person(name : "john")} &
Sets all the children to a new \texttt{Person} instance.
\\
returns the created \texttt{Person} oid\\
\hline \texttt{(array<Person *>(list(Person(), Person())))[?]} &
returns a \texttt{set} of \texttt{struct} including 
the just created \texttt{Person} instances in the just created array.\\
\hline
\etab

\subsubsect{\texttt{append/to} Operator}
The \texttt{append/to} operator is used to append an element
to an ordered collection (\texttt{list} or \texttt{array}).
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{append} \\
\hline Syntaxes
& \texttt{append} \ex \texttt{to} \ex\\
\hline Type & binary\\
\hline Operand Types & first operand: \emph{any type},
second operand: \texttt{oid} or \texttt{object} denoting an ordered collection\\
\hline Result Type & \emph{any type}\\
\hline Functions
& appends the element denoted by the first operand
to the indexed collection (i.e. list or array)
denoted by the second operand.\\
\hline
\etab\bettab\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{append Person() to p0.children} &
the created \texttt{Person} instance\\
\hline \texttt{append Car()to p0.cars} &
\rerr: \texttt{array or list expected, got set<Person*>}\\
\hline
\etab

\subsubsect{\texttt{suppress/from} Operator}
The \texttt{suppress/from} operator is used to suppress an element from
an ordered collection (\texttt{set} or \texttt{bag}).
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{suppress/from} \\
\hline Syntaxes
& \texttt{suppress} \ex \texttt{from} \ex \\
\hline Type & binary\\
\hline Operand Types & first operand: \emph{any type}, second operand:
\texttt{oid} or \texttt{object} collection \\
\hline Result Type & type of the first operand\\
\hline Functions
& suppress the first operand from the non-indexed collection (i.e. bag or set)
pointed by the second operand; returns the first operand.\\
\hline
\etab\bettab\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{suppress (select Car.num = 1000) from p0.cars}
& the suppressed car if it was found in the collection; otherwise, \rerr\\
\hline \texttt{suppress new Car() from p.cars} &
\rerr: \texttt{item '71238.13.3959935:oid' not found in collection}\\
\hline \texttt{suppress p0 from p0.children} &
\rerr: \texttt{cannot used non indexed suppression in an array}\\
\hline
\etab

\subsubsect{\texttt{empty} Operator}
The \texttt{empty} operator is used to empty an ordered or an
unordered collection.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{empty} \\
\hline Syntax
& \una{empty} \\
\hline Type & unary\\
\hline Operand Types & \texttt{oid} or \texttt{object} collection\\
\hline Result Type & \texttt{nil}\\
\hline Functions
& empty the collection 
pointed by the operand\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{empty(first (select Person).children)} & \texttt{nil} \\
\hline \texttt{empty(first (select Person).cars)} & \texttt{nil} \\
\hline \texttt{empty new set<Car *>(list(new Car()))} &
\texttt{nil}; this expression creates a collection of \texttt{Car}
containing initially a new \texttt{Car}, and empty it!\\
\hline
\etab

\subsubsect{\texttt{in} Operator}
The \texttt{in} operator is used to check if a given condition is
realized for at least one element in an ordered or unordered collection.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{in} \\
\hline Syntax
& \ide \texttt{in} \ex \texttt{:} \ex \\
\hline Type & ternary\\
\hline Operand Types & first operand: \texttt{identifier}, second operand:
\texttt{oid} or \texttt{object} collection,
third operand: boolean\\
\hline Result Type & \texttt{boolean}\\
\hline Functions
& returns \texttt{true} if it exists in the collection pointed by
the second operand an element for which the third operand is 
evaluated to \texttt{true}.\\
\hline
\etab\bettab\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{x in p0.children: x.name = "mary"}
& \texttt{true} or \texttt{false}\\
\hline \texttt{x in p0.cars: x.num < 100 and
x.num >= 90} & \texttt{true} or \texttt{false}\\
\hline
\etab

\subsubsect{\texttt{for} Operator}
The \texttt{for/all} operator is used to check
if a given condition is realized for all
elements in an ordered or unordered collection.
This operator is ODMG compliant.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{for/all} \\
\hline Syntaxes
& \texttt{for} \texttt{all} \ide  \texttt{in} \ex \texttt{:} \ex \\
\hline Type & ternary\\
\hline Operand Types & first operand: \texttt{identifier}, second operand:
\texttt{oid} or \texttt{object} collection,
third operand: boolean\\
\hline Result Type & \texttt{boolean}\\
\hline Functions
& returns \texttt{true} if for all items contained in the collection pointed by
the second operand the third operand is evaluated to \texttt{true}.\\
\hline
\etab\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{for all x in p0.children: x.name == "john"}
& \texttt{true} or \texttt{false}\\
\hline \texttt{for all x in p0.cars: x.num \% 10}
& \texttt{true} or \texttt{false}\\
\hline
\etab
The \texttt{for}/\emph{cardinality} operator is used to check if
a given condition is realized for a given
number range of elements in an orderer or unordered collection.
Note that this operator is the generalisation of the \texttt{in}
and \texttt{for/all} operators:\\
\texttt{for <0:\$>} is equivalent to \texttt{in}\\
\texttt{for <\$>} is equivalent to \texttt{for all}\\
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{for}\emph{cardinality} \\
\hline Syntaxes
& \texttt{for} \texttt{<} \ex \texttt{:} \ex \texttt{>} \ide
  \texttt{in} \ex \texttt{:} \ex \\
& \texttt{for} \texttt{<} \ex \texttt{>} \ide
  \texttt{in} \ex \texttt{:} \ex \\
\hline Type & 5-ary\\
\hline Operand Types &
first and optional second operands: \texttt{integer} or \texttt{\$},
where \texttt{\$} denotes the collection cardinality,
third operand: \texttt{oid} or \texttt{object},
fourth operand: \texttt{identifier},
fifth operand: \texttt{boolean}\\
\hline Result Type & \texttt{boolean}\\
\hline Functions
& returns \texttt{true} if the number of items in the collection pointed by
the third operand for which the third operand is evaluated to \texttt{true}
is in the interval \texttt{[}first operand\texttt{,} second operand\texttt{]}.\\
\hline
\etab\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{for <0:4> x in p0.children: x.name == "john"} &
\texttt{true} if at most 4 children have their name equals to \texttt{john}\\
\hline \texttt{for <4> x in p0.children: x.name == "john"} &
\texttt{true} if one an only one children have its name equals to \texttt{john}\\
\hline \texttt{for <0:\$> x in p0.cars: x.num = 10} &
equivalent to \texttt{in}\\
\hline \texttt{for <\$> x in p0.cars: x.num = 10} &
equivalent to \texttt{for/all}\\
\hline
\etab
\subsect{Exception Expressions}
Currently, \eyedb OQL does not provide full support for exception
management as there is no \texttt{try/catch} operator.
Nevertheless, the \texttt{throw} operator allows us to raise
an error message, for instance:
\begin{verbatim}
if (!check(p))
  throw "variable p is not correct".
\end{verbatim}
The \texttt{throw} operator stops the current thread of statements
and returns the error message at the uppest level. In the following
code:
\begin{verbatim}
a := 1;
throw "this is an error";
b := 2;
\end{verbatim}
the variable \texttt{a} will be assigned to \texttt{1}, but the
variable \texttt{b} will not be assigned to \texttt{2} as the
\texttt{throw} expression deroutes the normal thread of statements.
The \texttt{throw} operator is often used in the body of functions,
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{throw}\\
\hline Syntax
& \texttt{throw} \ex \\
\hline Type & unary\\
\hline Operand Type & \texttt{string}\\
\hline Result Type & \texttt{nil}\\
\hline Functions & raises an error message\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{throw "error message"} & \texttt{nil}\\
\hline \texttt{throw "error \#1: " + msg} &
\texttt{nil}\\
\hline
\etab
\subsect{Function Definition Expressions}
\label{fundefexp}
As introduced previously, OQL supports functions. There are two types of
functions definition syntax:
function definition expression and function definition statements.
The first ones, exposed in this section, are more restrictive than the
second ones, as their definition can contain only one expression.
The second ones contain an unbounded sequence of statements.
\\
The function definition expressions are ODMG compatible and are called
\emph{Named Query Definition} in the ODMG standard.
To define such a function, one must use the operator \texttt{define/as}.
The general syntax for a definition function expression is:\\\\
\texttt{define} \ide[\texttt{(}\emph{arglist}\texttt{)}] \texttt{as} \emph{expr}.
\\\\
For instance:
\begin{verbatim}
define div2(x) as x/2;
div2(10); // returns 5

define pimul(x) as x * 3.1415926535;
pimul(23); // returns 72.256631

define getOnePerson(name) as first(select Person.name = name);
getOnePerson("john"); // returns an oid or nil
\end{verbatim}
As the last operand of the \texttt{define/as} operator is any OQL
expression, it can be a sequence of expressions by using the
comma sequencing operator. Therefore, the following construct is valid:
\begin{verbatim}
define getit(age) as ::getit_call++,
                     list_of_persons := select Person.age >= age,
                     (count(list_of_persons) > 0 ? list_of_persons[0] : nil);

getit(10); // returns the first Person whose age is greater or equal to
              10, or nil
getit_call; // equals 1
list_of_persons; // raises an error: uninitialized identifier 'list_of_persons

getit(20);
getit_call; // equals 2
\end{verbatim}
Several comments about this code:
\be
\item \texttt{::getit\_call} denotes a global variable, while
\texttt{list\_of\_persons} denotes a variable local to the function:
the variable scoping has previously been introduced in the identifier
expressions, and will be explained again in the function definition statements
Section.
\item as there are no iteration expression (for instance a \texttt{for} or
\texttt{while} expression) and as a function definition expression can
contain only one expression, one cannot use a function definition expression
with iteration statements.
To use an iteration statement, one needs to use a function definition
statement.
\item when one needs to define a function with a sequence
of expressions, it may be easier and more readable to use a
function definition statement instead of a function definition expression.
The \emph{statement} version of the previous function is:
\begin{verbatim}
function getit(age) {
  ::getit_call++;
  list_of_persons := select Person.age >= age;
  if (count(list_of_persons))
    return list_of_persons[0];
}
\end{verbatim}
which is - for \texttt{C}, \texttt{C++} or \texttt{Java} programmers -
a more natural construct.
\ee
Finally, the function definition allows us for recursive definitions,
for instance:
\begin{verbatim}
define fib(n) as (n < 2 ? n : fib(n-2) + fib(n-1));
fib(10); // returns 55
\end{verbatim}
\mbox{}
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{define/as}\\
\hline Syntax
& \texttt{define} \ide[\emph{arglist}] \texttt{as} \ex\\
\hline Type & n-ary\\
\hline Operand Type & first operand: \texttt{identifier},
last operand: \emph{any type}, other operands: \texttt{identifier}\\
\hline Result Type & \texttt{identifier}\\
\hline Functions & defines a function\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{define Persons as select Person} &
\texttt{Persons}\\
\hline \texttt{define fact(n) as (n < 2 ? n : n * fact(n-1))} &
\texttt{fact}\\
\hline
\etab

\subsect{Conversion Expressions}
The conversion unary operators \texttt{string},
\texttt{int}, \texttt{char}, \texttt{float}, \texttt{oid} and
\texttt{ident} allows us to make the following conversions:
\btab[l]{|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{6cm}|}
\hline \emph{Operator} & \emph{From} & \emph{To} & \emph{Returned Atom}\\
\hline \texttt{string}
  & \emph{any type} & \texttt{string} & the string representation
of the operand\\
\hline \texttt{int}
  & \texttt{int} & \texttt{int} & the \texttt{int} operand\\
  & \texttt{char} & \texttt{int} & the operand casted to an \texttt{int}\\
  & \texttt{float} & \texttt{int} & the operand casted to an \texttt{int}\\
  & \texttt{string} & \texttt{int}& the operand converted to an \texttt{int}\\
\hline \texttt{char}
  & \texttt{char} & \texttt{char} & the \texttt{char} operand\\
  & \texttt{int} & \texttt{char} & the operand casted to a \texttt{char}\\
  & \texttt{float} & texttt{char} & the operand casted to a \texttt{char}\\
  & \texttt{string} & \texttt{char} & the operand converted to a \texttt{char}\\
\hline \texttt{float}
  & \texttt{float} & \texttt{float} & the \texttt{float} operand\\
  & \texttt{char} & \texttt{float} & the operand casted to a \texttt{float}\\
  & \texttt{int} & \texttt{float} & the operand casted to a \texttt{float}\\
  & \texttt{string} &\texttt{float}& the operand converted to a \texttt{float}\\
\hline \texttt{oid}
& \texttt{oid} & \texttt{oid} & the \texttt{oid} operand\\
& \texttt{string} & \texttt{oid} & the \texttt{string} operand converted to an \texttt{oid}\\
\hline \texttt{ident}
  & \texttt{ident} & \texttt{ident} & the \texttt{ident} operand\\
  & \texttt{string} & \texttt{ident} & the \texttt{string} operand converted to an \texttt{ident} \\
\hline  
\etab
These operators are used to perform an explicit conversion such
as convert the string \texttt{"123"} to the integer \texttt{123},
or to perform an explicit cast for numbers such as
casting the integer \texttt{10} to the float \texttt{10.0}.
These operators evaluate first their operand before
performing the conversion.
If the operand type is valid, no error is raised even if its format
is not valid, for instance: \texttt{int "alpha"} returns \texttt{0},
while \texttt{oid "aoaoai"} returns \texttt{NULL}.
Note that because of the precedence of these operators, parenthesis
are necessary to make a conversion of a non-primary operand. For
instance, \texttt{string 1+2} is not valid: you should use
\texttt{string (1+2)}.
\subsubsect{\texttt{string} operator}
The \texttt{string} operator evaluates its operand and returns its string representation.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{string}\\
\hline Syntax
& \texttt{string} \ex\\
\hline Type & unary\\
\hline Operand Type & any type\\
\hline Result Type & \texttt{string}\\
\hline Function & returns the string representation of any atom\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{string 123.3} & \texttt{"1203.300000"}\\
\hline \texttt{string 'a'} & \texttt{"a"} \\
\hline \texttt{string first(select Person)} &
\texttt{"71211.13.1486847:oid"}\\
\hline \texttt{string \&alpha} & \texttt{"::alpha"}\\
\hline \texttt{string list(1, 2, 3+2)} & \texttt{"list(1, 2, 5)"}\\
\hline \texttt{string (list("hello", 30) + list(10))} & \texttt{"list("hello", 30, 10)"}\\
\hline \texttt{string (1+3)} & \texttt{"4"} \\
\hline \texttt{string 1+3} & \rerr\\
\hline
\etab
\subsubsect{\texttt{int} operator}
The \texttt{int} operator evaluates its operand and converts or
casts it to an integer.\\
If the operand is the string, it converts it using the \texttt{atoi} C
function. If the string is not a valid integer, it returns a \texttt{0}.\\
If the operand is a char or float, it casts it to an integer.\\
If the operand is an integer, it returns it.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{int}\\
\hline Syntax
& \texttt{int} \ex\\
\hline Type & unary\\\hline Operand Type & \texttt{int}, \texttt{char}, \texttt{float} or
\texttt{string}\\
\hline Result Type & \texttt{int}\\
\hline Function & returns the integer conversion or cast of the operand\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{int 123.3} & \texttt{123}\\
\hline \texttt{int 12} & \texttt{12} \\
\hline \texttt{int 'a'} & \texttt{97} \\
\hline \texttt{int "123"} & \texttt{123} \\
\hline \texttt{int ("123" + "12")} & \texttt{12312} \\
\hline \texttt{int alpha} & the value of \texttt{alpha} converted
or casted to an integer\\
\hline \texttt{int list(1, 2, 3)} & \rerr\\
\hline
\etab
\subsubsect{\texttt{char} operator}
The \texttt{char} operator evaluates its operand and converts or
casts it to a \texttt{char}.\\
If the operand is the string of length one, it returns the character of
this string. If the string has several characters, it returns a
\texttt{'{\textbackslash}000}.\\
If the operand is a integer or float, it casts it to a character.\\
If the operand is a character integer, it returns it.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{char}\\
\hline Syntax
& \texttt{char} \ex\\
\hline Type & unary\\\hline Operand Type & \texttt{int}, \texttt{char}, \texttt{float} or
\texttt{string}\\
\hline Result Type & \texttt{char}\\
\hline Function & returns the character conversion or cast of the operand\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{char 123.3} & \texttt{\{}\\
\hline \texttt{char 'a'} & \texttt{'a'} \\
\hline \texttt{char alpha} & the value of \texttt{alpha} converted
or casted to a character\\
\hline \texttt{char "a"} & \texttt{'a'}\\
\hline \texttt{char "hello"} & \texttt{'\^{}@'}\\
\hline \texttt{char list(1, 2, 3)} & \rerr\\
\hline
\etab
\subsubsect{\texttt{float} operator}
The \texttt{float} operator evaluates its operand and converts or
casts it to a float.\\
If the operand is the string, it converts it using the \texttt{atof} C
function. If the string is not a valid float, it returns a \texttt{0.0}.\\
If the operand is a integer or float, it casts it to a float.\\
If the operand is a float, it returns it.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{float}\\
\hline Syntax
& \texttt{float} \ex\\
\hline Type & unary\\\hline Operand Type & \texttt{int}, \texttt{char}, \texttt{float} or
\texttt{string}\\
\hline Result Type & \texttt{float}\\
\hline Function & returns the float conversion or cast of the operand\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{float 123.0} & \texttt{123.0}\\
\hline \texttt{float 123.3} & \texttt{123.3}\\
\hline \texttt{float 'a'} & \texttt{97.000} \\
\hline \texttt{float "123.0000000"} & \texttt{123.0} \\
\hline \texttt{float ("123." + "12")} & \texttt{123.12} \\
\hline \texttt{float "hello"} & \texttt{0.0} \\
\hline \texttt{float alpha} & the value of \texttt{alpha} converted
or casted to a float\\
\hline \texttt{float list(1, 2, 3)} & \rerr\\
\hline
\etab

\subsubsect{\texttt{oid} operator}
The \texttt{oid} operator evaluates its string operand and returns
the corresponding oid. If the string does not denote a valid oid,
the \texttt{NULL} oid is returned.\\
If the operand is an oid, it returns it.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{oid}\\
\hline Syntax
& \texttt{oid} \ex\\
\hline Type & unary\\
\hline Operand Type & \texttt{oid} or \texttt{string}\\
\hline Result Type & \texttt{oid}\\
\hline Function & returns the oid denoted by the string operand\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{oid "234.34.33:oid"} & \texttt{234.34.33:oid}\\
\hline \texttt{oid 234.34.33:oid} & \texttt{234.34.33:oid}\\
\hline \texttt{oid first(select Person)} & returns the first person oid\\
\hline \texttt{oid 'a'} & \rerr\\
\hline
\etab
\subsubsect{\texttt{ident} operator}
The \texttt{ident} operator evaluates its string operand and returns
the corresponding identifier.
If the operand is an identifier, it returns it.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{ident}\\
\hline Syntax
& \texttt{ident} \ex\\
\hline Type & unary\\
\hline Operand Type & \texttt{ident} or \texttt{string}\\
\hline Result Type & \texttt{string}\\
\hline Function & returns the identifier denoted by the string operand\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{ident "alpha"} & \texttt{alpha}\\
\hline \texttt{ident "alpha\#1x"} & \texttt{alpha\#1x}\\
\hline \texttt{ident "alpha" := 123} & \texttt{123}, \texttt{alpha} has been
assigned to \texttt{123}\\
\hline \texttt{valof \&(ident "alpha")} & \texttt{123}\\
\hline \texttt{ident 'a'} & \rerr\\
\hline
\etab

\subsect{Type Information Expressions}
OQL provides two type information unary operators: \texttt{typeof} and
\texttt{classof}. The first one takes any operand type, while the
second one takes an oid or an object operand.
Note that because of the precedence of these operators, parenthesis
are necessary to get type information about a non-primary operand. For
instance, \texttt{typeof 1+2} is not valid: you should use
\texttt{typeof (1+2)}.

\subsubsect{\texttt{typeof} operator}
The \texttt{typeof} operator is used to get the type of any OQL atom.
It evaluates its operand and returns the string type of its operand.
For instance: \texttt{typeof 1} returns \texttt{"int"} while
\texttt{typeof "hello"} returns \texttt{"string"}.\\
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{typeof}\\
\hline Syntax
& \texttt{typeof} \ex\\
\hline Type & unary\\
\hline Operand Type & any type\\
\hline Result Type & \texttt{string}\\
\hline Function & returns the type of the atom\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{typeof "alpha"} & \texttt{"string"}\\
\hline \texttt{typeof (1+20.)} & \texttt{"float"}\\
\hline \texttt{typeof list(1, 2, 3)} & \texttt{"list"}\\
\hline \texttt{typeof first(select Person)} & \texttt{"oid"}\\
\hline \texttt{typeof 1+3049} & \rerr\\
\hline \texttt{typeof alpha} & type of the value of \texttt{alpha}\\
\hline \texttt{typeof \&alpha} & \texttt{ident}\\
\hline
\etab

\subsubsect{\texttt{classof} operator}

\subsubsect{\texttt{typeof} operator}
The \texttt{classof} operator is used to get the class of any oid
or object.
It evaluates its operand and returns the string class of its operand.
For instance: \texttt{classof first(select Person)} returns \texttt{"Person"} while
\texttt{typeof new Car()} returns \texttt{"Car"}.\\
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{classof}\\
\hline Syntax
& \texttt{classof} \ex\\
\hline Type & unary\\
\hline Operand Type & \texttt{oid} or \texttt{object}\\
\hline Result Type & \texttt{string}\\
\hline Function & returns the class of the operand\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{5cm}|}
\expex{2}\\
\hline \texttt{classof first(select class)} & \texttt{"basic\_class"}\\
\hline \texttt{classof (c := new Car(num : 10))} & \texttt{"Car"}\\
\hline \texttt{classof NULL} & \texttt{""}\\
\hline \texttt{classof first(select Person).spouse} & \texttt{"Person"} or \texttt{NULL}\\
\hline \texttt{classof 1} & \rerr\\
\hline
\etab

\subsect{Query Expressions}
The \texttt{select} operator is used to perform queries in a database.
The general syntax of this operator is as follows:\\\\
\texttt{select} [\texttt{distinct}] \emph{projection} [\texttt{from} \emph{fromList} 
[\texttt{where} \emph{predicat}] [\texttt{order by} \emph{orderExprList}
[\texttt{asc}\texttt{|}\texttt{desc}]]
\be
\item \texttt{distinct} means that duplicates must be eliminated,
\item \emph{projection} is an expression using the variables
defined in the \emph{fromList},
\item \emph{fromList} is a sequence of comma-separated items
under one of the following forms:\\
\mbox{ } \emph{var} \texttt{in} \emph{expr}\\
\mbox{ } \emph{expr} \texttt{as} \emph{var}\\
\mbox{ } \emph{expr} \emph{var}\\
where \emph{expr} is an expression of type \texttt{collection} or
is a class name, and \emph{var} is the name of a variable.
\item \emph{predicat} is a boolean expression using the variables
defined in the \emph{fromList},
\item \emph{orderExprList} is a comma-separated list of sortable
expressions (i.e. atomic type).
\item \texttt{asc} means that the order should be performed in an ascendant
way (the default) and \texttt{desc} means the inverse.
\ee

% ----------------------------------------------------------------
\subsubsect{ODMG vs. \eyedb OQL Query Expressions}
As explained in the Section \emph{OQL vs. ODMG 3 OQL},
there are a few differences between ODMG OQL and \eyedb OQL query expressions:
\bi
\item the \texttt{having/group} clause is not
supported in the current implementation.
\item in the current implementation,
one cannot use implicit \texttt{from} clause (i.e. \texttt{from}
clause without variables). ODMG OQL supports constructs such as:
\texttt{from Person} without any variable. This implementation does not.
\item contrary to ODMG OQL, the \texttt{from} clause is optionnal,
A \texttt{select} expression which does not use the \texttt{from} is
called an implicit \texttt{select} expression.
\item in a \texttt{from} clause such as ``\texttt{x in expr}'', ``\texttt{expr}'' can
be the name of a class. In this case, the interpreter understand
this as the extent of this class. ODMG OQL does not support that.
\item the SQL specific agregate operators \texttt{min(*)},
\texttt{max(*)}, \texttt{count(*)}, \texttt{sum(*)} and \texttt{avg(*)}
are not supported
% ------------ TO ADD -----------
% select x, y, z is not supported
% -------------------------------
\item the \texttt{order by} clause is more restrictive than
in the ODMG OQL specifications (see below).
\item the \texttt{select *} is not supported in the current implementation.
\ei

% ----------------------------------------------------------------
\subsubsect{The general \texttt{select} syntax}
Rather than introducing the \texttt{select} operator in a formal way by
using a lot mathematical symbols, we introduce it first, in an unformal way,
and then, through query examples.\\
\\
The unformal description of the query process is as follows:
\be
\item The \texttt{from} clause
determine the sets of objects on which the query will be applied.
For instance, in the \texttt{from} clause,
``\texttt{x in Person, y in x.children}'', the sets on which
the query will be applied are
all the \texttt{Person} instances bound to the variable \texttt{x}
and the children of these instances, bound to the variable
\texttt{y}.
\item These sets of objects are filtered by retaining only the objects
that satisfy the predicat in the \texttt{where} clause. These result objects
are gathered into a \texttt{bag}. If no \texttt{where} clause is there, all objects are
retained.
\item If an \texttt{order by} clause is present, a sort is performed
using to the following process:
\be
\item each order expression must be of a sortable type: number (\texttt{int},
\texttt{char} or \texttt{float}) or \texttt{string}. If not, an
error is raised.
\item the \texttt{bag} is ordered into a \texttt{list} according to
the first order expression. Then identical atoms are ordered again using
the second order expression and so on.
\item there is a restriction in the current implementation:
each expression in the \emph{orderExprList} must be present
in the \emph{projection} expression. If not present, an
error is raised.
\ee
\item The \emph{projection} expression is evaluated for each
object in the \texttt{collection} and the results of these evaluations are gathered
into a \texttt{bag}.
\item If the keyword \texttt{distinct} is there, the eventual duplicates are
eliminated.
\item Finally, if the \texttt{order by} clause is present, the
result \texttt{bag} is converted to a \texttt{list};
if the \texttt{distinct} keyword is there without an \texttt{order by},
the \texttt{bag} is converted to a \texttt{set}; and if neither
\texttt{order by} nor \texttt{distinct} are used, we get a \texttt{bag}.
\ee
The following table presents several examples:
\newcommand{\exselect}[2]{\begin{tabular}{|p{11cm}|}
\hline \texttt{#1}\\
\hline #2\\
\hline
\end{tabular}
\bettabx
}
\renewcommand{\exselect}[2]{
\hline \hline \texttt{#1}\\#2\\
}
\renewcommand{\exselect}[2]{
\hline\texttt{#1}\\#2\\
}
\begin{longtable}[l]{|p{12cm}|}
\hline \begin{center}\emph{Simple \texttt{select/from} Examples}\end{center}\\
\exselect{select x from Person x}{returns a \texttt{bag} containing
all the \texttt{Person} \texttt{oid}s in the database}
\exselect{select x.name from Person x}{returns a \texttt{bag}
containing the name of every \texttt{Person} instance in the database}
\exselect{select struct(name: x.name, age: x.age) from Person x}{
returns a \texttt{bag}
containing \texttt{struct} elements including the name and age of every \texttt{Person} instance in the database}
\exselect{select list(x, x.name) from Person x where x.name \~{} "h"}{returns a \texttt{bag} of \texttt{list} elements
containing the \texttt{oid} and the name of every \texttt{Person} instances 
whose name matches the regular expression \texttt{"h"}}
\exselect{select list(x, x.name) from Person x where x.name \~{} "h" order by x.name}{same as previous example, but the result is a \texttt{list} ordered
by the name of the persons}
\exselect{select x from Person x where x.spouse.name = "john" or x.age < 10}{returns
a bag of \texttt{Person} instances whose spouse name is equal to \texttt{"john"} or
the age is less than \texttt{10}}
\exselect{select x from Person x order by x.name}{current implementation restriction: \rerr: \texttt{x.name not found in projection}}
\hline
\end{longtable}

% ----------------------------------------------------------------
\subsubsect{Arrays and collections in query expressions}
OQL provide supports for performing direct queries through non-collection array and
collection attributes without explicit joins.
To perform such queries, one must use the operators \texttt{[]},
\texttt{[?]} or \texttt{[:]}.
All the operators may be used for non-collection arrays. For
collections (\texttt{list}, \texttt{set}, \texttt{bag} and \texttt{array}),
only the operator \texttt{[?]} is valid.\\
The operator \texttt{[]} denotes an element in a non-collection array.\\
The operator \texttt{[:]} denotes a range of elements in a non-collection array.\\
The operator \texttt{[?]} denotes all elements in a non-collection array
or in a collection.
The following table presents several examples:
\begin{longtable}[l]{|p{12cm}|}
\hline \begin{center}\emph{Array and Collection based Query Examples}\end{center}\\
\exselect{select x.name from Person x where x.name[0] = 'j'}{returns all
the \texttt{Person} instances whose name begins with a \texttt{'j'}}
\exselect{select x from Person x where x.other\_addrs[0].street \~{}\~{} "par." }{returns all the \texttt{Person} instances whose first \texttt{other\_addrs}
street matches the regular expression \texttt{"par."}}
\exselect{select x from Person x where x.other\_addrs[?].street \~{}\~{} "par.." }{returns all the \texttt{Person} instances whose any \texttt{other\_addrs}
street matches the regular expression \texttt{"par.."}}
\exselect{select x from Person x where x.other\_addrs[1:3].street \~{}\~{} "par.." }{returns all the \texttt{Person} instances whose the first, second
or third \texttt{other\_addrs}
street matches the regular expression \texttt{"par.."}}
\exselect{select x from Person x where x.children[?].name = "johnny"}
{returns
all the persons whose one of its children is called \texttt{"johnny"}}
\exselect{select x from Person x where x.cars[?].num < 100 or x.children[?].name = "mary"}{returns all the persons whose one of its cars has a number less
than  \texttt{100} or a child called \texttt{"mary"}}
\exselect{select x from Person x where x.children[1].name = "johnny"}
{although the \texttt{children} is a collection array, an error is raised.
This is a current limitation of the implementation that will disapear
soon}
\hline
\end{longtable}

% ----------------------------------------------------------------
\subsubsect{The Implicit \texttt{select} syntax}
An implicit \texttt{select} expression is a \texttt{select} expression
with neither a \texttt{from} nor an explicit \texttt{where} clause.
In fact, the \texttt{where} clause may be included in the \emph{projection}
expression.\\
This particular syntax has the advantage
to be more compact and more simple than the general syntax, but
some queries cannot be performed:
\be
\item queries performing an explicit join,
\item queries having \texttt{or} or \texttt{and} in their \texttt{where}
clause.
\ee
The following table presents several examples:
\begin{longtable}[l]{|p{12cm}|}
\hline \begin{center}\emph{Simple Implicit \texttt{select} Examples}\end{center}\\
\exselect{select 1}{returns \texttt{1}}
\exselect{select Person}{returns a \texttt{bag} containing all \texttt{Person}
instances in the database}
\exselect{select Person.name}{returns a \texttt{bag}
containing the name of every \texttt{Person} instances in the database}
\exselect{select Person.name = "john"}{returns a \texttt{bag}
containing the \texttt{oid}s of every \texttt{Person} instances 
whose name is equal to \texttt{"john"}}
\exselect{(select distinct Person.name = "john").age}{returns a \texttt{set}
containing the age of every \texttt{Person} instances 
whose name is equal to \texttt{"john"}}
\exselect{select Person.name = "john" or Person.age = 10}
{\rerr: \texttt{use select/from/where clause}}
\exselect{select Person.name order by Person.name}
{returns a \texttt{list} containing of the sorted names of all \texttt{Person}
instances}
\hline
\end{longtable}

% ----------------------------------------------------------------
\subsubsect{Querying the schema}
As every abstraction is an object, one can perform queries on the schema
and classes. For instance, to get the \texttt{oid}s of all the
existing classes in a schema:\\
\texttt{select schema} which is equivalent to \texttt{select class}.\\
In the \eyedb object model, the class \texttt{class} has the following
native attributes (some are inherited from the \texttt{object} class):
\be
\item \texttt{class} (inherited from \texttt{object}) is the class
of this class,
\item \texttt{protection} (inherited from \texttt{object}) is the 
protection object of this class,
\item \texttt{type} is the type of the class: \texttt{"system"} or
\texttt{"user"}.
\item \texttt{name} is the name of this class,
\item \texttt{parent} is the parent class of this class,
\item \texttt{extent} is the extent collection of this class: contains
all the object instances of this class,
\item \texttt{components} is the collection of components of this class:
contains the constraints, the methods, the triggers, the index.
\ee
Queries can be performed according to one or more of the previous
attributes.
\begin{longtable}[l]{|p{12cm}|}
\hline \begin{center}\emph{Query Schema Examples}\end{center}\\
\exselect{select class.name = "Person"}
{returns a \texttt{bag} containing the class whose name is \texttt{"Person"}}
\exselect{select class.type = "user"}
{returns all the user classes}
\exselect{select x from class x where x.name \~{} "P" and
x.type = "user"}{returns the user classes whose name
matches the given regular expression}
\exselect{select class.parent.name = "Person"}
{returns a \texttt{bag} containing the sub-classes of the class \texttt{Person}}
\hline
\end{longtable}

% ----------------------------------------------------------------
\subsubsect{How queries are optimized?}
\eyedb queries implementation make an heavy use of index.
Index may be used as terminal index or as non-terminal index:
terminal index are those used at the end of a path expression, and
the other are those used inside a path expression.\\\\
For instance, assuming that each attribute in our schema is indexed,
the query \texttt{select Person.name = "john"} uses
the index on the attribute \texttt{name} as
a terminal index.\\\\
The query \texttt{select Person.spouse.age < 23} uses
the index on the attribute \texttt{age} as a terminal
index, and the index on the indirect attribute \texttt{spouse}
as a non-terminal index, while the query \texttt{select Person.spouse
= 6252.3.48474:oid} uses the index on the \texttt{spouse} attribute as a
terminal index.\\
\\
The query \texttt{select Person.children[?].spouse.name = "mary"}
uses the index of the attributes \texttt{name}, \texttt{spouse}
and of the literal collection attribute \texttt{children}.
\\
\\
The queries with a \texttt{where} clause containing logical \texttt{and}
constructs are optimized so to take advantage of the index. For instance,
assuming that there is an index on the \texttt{name} attribute and no
index on the \texttt{age} attribute, the query
\texttt{select x from Person x where x.age = 100 and x.name = "john"}
will perform first the query on the \texttt{name} attribute and then
filter the result according to the given predicat on the \texttt{age}
attribute.\\
If the two expressions around the logical \texttt{and} operator
have an index or if none of the two expression has a index,
the interpreter performs first the left part and then the second part.
So, in this case, the order of the two expressions around the \texttt{and}
is important.
\\
\\
Finally, the query \texttt{select Person.name} reads directly the index
of the \texttt{name} attribute, instead of reading the name of each
\texttt{Person} instance.
\\
\\
Nevertheless, currently, there are some constructs that the OQL interpreter
does not interpret cleverly and where index are not used.
This is unfortanely the case of the join constructs such as:\\
\texttt{select x from Person x, x.spouse y where y.name = "mary"}.\\
This construct will not make use of the index on the \texttt{spouse} attribute
(but it will use the index of the \texttt{name} attribute).
Fortunately, in a lot of cases, join queries may be replaced by a path expression query, for
instance:\\
\texttt{select x from Person x where x.spouse.name = "mary"} is the
alternate form the previous join query.\\\\
This alternate form (path-expression oriented) is the preferred one, because:\\
\mbox{ } - it is more intuitive,\\
\mbox{ } - it is more \emph{object oriented} (please forget relationnal!),\\
\mbox{ } - it is more compact,\\
\mbox{ } - it uses index properly.\\\\
Of course, the last reason is not a good reason as a proper query
implementation should use index whatever the used syntax.
The implementation will be improved in a next version.
\\
\\
Note that query optimisations are fragile and do not believe that
the OQL interpreter knows your data better than you. So, the two following
simple rules should be applied:
\be
\item when path expression oriented queries are enough, do not use
join constructs,
\item in a \texttt{and} expression within a \texttt{where} clause, put
the expression which denotes the most little set of instances on
the left side of the \texttt{and}. In some particular cases, the
OQL interpreter knows how to optimize the \texttt{and}, but in
most of the cases, it does not.
\ee
Some experimental hints can be added to an \texttt{and} expression
in the \texttt{where} clause to help the interpreter to do the
things better, but there are currentlty too much experimental to
be documented here.

\subsect{Miscellenaous Expressions}
A few OQL operators cannot be easily classified in one of the previous
categories. We choose to classify them in the miscellenaous operators.
These operators are: \texttt{bodyof}, \texttt{structof}, \texttt{[!]} and
\texttt{import}.

\subsubsect{\texttt{bodyof} operator}
The \texttt{bodyof} operaror is used to get the body of an OQL function.
For instance, let the function \texttt{fib}:
\texttt{define fib(n) as (n < 2 ? n : fib(n-2) + fib(n-1))}.
The expression \texttt{bodyof fib} will return:
\texttt{"fib(n) ((n<2)?n:(fib((n-2))+fib((n-1))))"}.
This operator could be applied to expression-functions (i.e. functions
defined with the \texttt{define/as} operator) or statement-functions (i.e.
functions defined with the \texttt{function} operator).
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{bodyof}\\
\hline Syntax
& \texttt{classof} \ex\\
\hline Type & unary\\
\hline Operand Type & \texttt{ident} denoting a function\\
\hline Result Type & \texttt{string}\\
\hline Function & returns the body of the function\\
\hline
\etab
\bettab
\btab[l]{|p{3cm}|p{9cm}|}
\expex{2}\\
\hline \texttt{bodyof is\_int} &
\texttt{"is\_int(x) ((typeof x)=="integer")"}\\
\hline \texttt{bodyof first}  &
\texttt{"first(l) \{ if (((!is\_list(l))\&\&(!is\_array(l)))) return l; start:=0; f:=nil; for (x in l) if ((start==0)) \{ start:=1; f:=x; break; \}; ; return f; \}"}\\
\hline \texttt{bodyof 1} & \rerr\\
\hline
\etab

\subsubsect{\texttt{structof} operator}
The \texttt{structof} is used to get the meta-type of a \texttt{struct} atom.
The meta-type of a \texttt{struct} atom is the list of the attributes
of this \texttt{struct}. For instance, the meta-type of 
\texttt{struct(a : 1, b : "hello")} is the list composed of the two
attribute \texttt{a} and \texttt{b}. The following expression
\texttt{structof struct(a : 1, b : "hello")} returns
\texttt{list("a", "b")}.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{structof}\\
\hline Syntax
& \texttt{structof} \ex\\
\hline Type & unary\\
\hline Operand Type & \texttt{struct}\\
\hline Result Type & a \texttt{list} of \texttt{string}s\\
\hline Function & returns the meta-type of the operand\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{4cm}|}
\expex{2}\\
\hline \texttt{structof struct(alpha : 1, beta : 2)} &
\texttt{list("alpha", "beta")}\\

\hline \texttt{structof first(select struct(x: x.firstname) from Person x)}
& \texttt{list("x")}\\
\hline \texttt{structof 1} & \rerr\\
\hline
\etab

\subsubsect{\texttt{[!]} operator}
The \texttt{[!]} is used to get the length (or size) of an ordered
or unordered collection, a string or a struct.
For instance, \texttt{"hello"[!]} returns \texttt{5},
while \texttt{list(1, 2, 3)[!]} returns \texttt{3}.
Note that this operator is far more efficient than the \texttt{strlen}
library function.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{[!]}\\
\hline Syntax
& \ex\texttt{[!]}\\
\hline Type & unary\\
\hline Operand Type & \texttt{string}, \texttt{collection} or
\texttt{struct}\\
\hline Result Type & a \texttt{int}\\
\hline Function & returns length of the operand\\
\hline
\etab
\bettab
\btab[l]{|p{7cm}|p{4cm}|}
\expex{2}\\
\hline \texttt{(select Person)[!]} & the number of person instances\\
\hline \texttt{(struct(a: 1, b:2, c: "hello"))[!]} & \texttt{3}\\
\hline \texttt{("hello"+"world")[!]} & \texttt{10}\\
\hline \texttt{"hello"+"world"[!]} & \rerr\\
\hline
\etab

\subsubsect{\texttt{import} operator}
The \texttt{import} operator is used to import an OQL file in the
current OQL session. Its operand is a string which denote the absolute
path (i.e. beginning with a \texttt{/}) or relative path
(i.e. not beginning with a \texttt{/}) 
 of the file to import. When the path is relative, the OQL interpreter
will look in every directories pointed by the \eyedb configuration variable
\texttt{oqlpath}. By default, \texttt{oqlpath} is equal to
\texttt{\%root\%/etc/oql}. If the file name has no \texttt{.oql} extension,
the OQL interpreter will automatically adds one.
\btab[l]{|p{2.3cm}|p{8cm}|}
\geninfo\\
\hline Operator & \texttt{import}\\
\hline Syntax
& \texttt{import} \ex\\
\hline Type & unary\\
\hline Operand Type & \texttt{string}\\
\hline Result Type & a \texttt{string}\\
\hline Function & import the file\\
\hline
\etab
\bettab
\btab[l]{|p{3cm}|p{8cm}|}
\expex{2}\\
\hline \texttt{import "stdlib"} &
\texttt{"/usr/local/eyedb/etc/so/stdlib.oql"}\\
\hline \texttt{import "roudoudou"} &
\rerr: \texttt{cannot find file 'roudoudou'}\\
\hline
\etab

\newcommand{\allstats}{an expression
statement, an iteration statement, a compound statement, a selection statement,
a function definition statement, a jump statement or an empty statement}

\subsect{Selection Statements}
The selection statement is based on the \texttt{if/else} constructs.\\\\
{\bf Syntax}: \texttt{if} \texttt{(} \emph{cond\_expr} \texttt{)} \emph{statement1} [\texttt{else} \emph{statement2}]\\
where \emph{cond\_expr} is a boolean expression, and \emph{statement1}
and \emph{statement2} may be any statement: {\allstats}.\\\\
{\bf Semantics}: if the boolean expression \emph{cond\_expr} is
evaluated to \texttt{true}, the statement \emph{statement1} is executed.
Otherwise, if an \texttt{else} part is there, the statement \emph{statement2}
is executed. The statements 1 and 2 may be any statement: an expression
statement, iteration statement, compound statement, selection statement,
function definition statement, jump statement or empty statement.\\
Note that a selection statement does not return any atom\\\\
The following table presents several examples of \texttt{if/else} statements:
\begin{longtable}[l]{|p{12cm}|}
\hline \begin{center}\emph{\texttt{if/else} Statement Examples}\end{center}\\
\exselect{if (true) a := 1;}
{the variable \texttt{a} is assigned to \texttt{1}}
\exselect{if (1) b := 2;}
{an error is raised: \texttt{boolean expected for condition}}
\exselect{if (check(10) > 54) \{a := 1; b := 2;\} else \{c := 2; d := 2\}}
{here compound statements are used, because several expression statements
need to be executed}
\exselect{if ((check(10) > 54 || alpha < 2) \&\& beta > 2.3 ) \{callme(2);\}}
{use of a composite conditional expression}
\exselect{if (a == 1) b := 2; else if (b == 3) \{c := 2; return 4;\} else if (check(1)) return 2; else return 3;}
{selection statements are combined}
\hline
\end{longtable}  

\subsect{Iteration Statements}
The iteration statements are based on the following constructs:
\bi
\item \texttt{while}
\item \texttt{do/while}
\item \texttt{for} C, C++, Java form
\item \texttt{for} collection form
\ei
\subsubsect{\texttt{while} statement}
{\bf Syntax}: \texttt{while} \texttt{(} \emph{cond\_expr} \texttt{)} \emph{statement}\\
where \emph{cond\_expr} is a boolean expression, and \emph{statement}
any statement: {\allstats}.\\\\
{\bf Semantics}: The statement is executed while the boolean expression
\texttt{cond\_expr} is evaluated to \texttt{true}.
Note that a \texttt{while} statement does not return any atom\\\\
The following table presents several examples of \texttt{while} statements:
\begin{longtable}[l]{|p{12cm}|}
\hline \begin{center}\emph{\texttt{while} Statement Examples}\end{center}\\
\exselect{while (true) a++;}
{\texttt{a} is increment definitively!}
\exselect{while (n--) a++;}
{an error is raised: \texttt{boolean expected, got integer}}
\exselect{while (n-- > 0) a++;}
{this is better}
\exselect{while (n++ <= 100 || stop) \{if (!perform(a++)) break; check(a);\}}
{note the usage of a compound statement and of the \texttt{break}}
\exselect{while (name != "john") \{l := (select Person.name = name); name := get\_name();\}}
{\emph{no comments}}
\hline
\end{longtable}  

\subsubsect{\texttt{do/while} statement}
{\bf Syntax}: \texttt{do} \emph{statement} \texttt{while} \texttt{(} \emph{cond\_expr} \texttt{)}\\
where \emph{cond\_expr} is a boolean expression, and \emph{statement}
any statement: {\allstats}.\\\\
{\bf Semantics}: The statement is executed at least once.
Then while the boolean expression
\texttt{cond\_expr} is evaluated to \texttt{true}, the statement is executed.
Note that a \texttt{do/while} statement does not return any atom\\\\
The following table presents several examples of \texttt{do/while} statements:
\begin{longtable}[l]{|p{12cm}|}
\hline \begin{center}\emph{\texttt{do/while} Statement Examples}\end{center}\\
\exselect{do a++; while (true);}
{\texttt{a} is increment definitively!}
\exselect{do a=+; while (n--);}
{an error is raised: \texttt{boolean expected, got integer}}
\exselect{do a++; while (n-- > 0);}
{this is better}
\exselect{do \{if (!perform(a++)) break; check(a);\} while (n++ <= 100 || stop);}
{note the usage of a compound statement and of the \texttt{break}}
\exselect{do \{l := (select Person.name = name); name := get\_name();\} while (name != "john");}
{\emph{no comments}}
\hline
\end{longtable}  

\subsubsect{C-\texttt{for} statement}
{\bf Syntax}: \texttt{for} \texttt{(} [\emph{expr1}] \texttt{;} [\emph{cond\_expr}] \texttt{;} [\emph{expr2}] \texttt{)} \emph{statement}\\
where \emph{cond\_expr} is a boolean expression, \emph{expr1} and
\emph{expr2} are any expressionss and \emph{statement}
any statement: {\allstats}.\\\\
{\bf Semantics}: The expression \emph{expr1} is evaluated.
While the boolean expression
\texttt{cond\_expr} is evaluated to \texttt{true}, the statement is
executed and the expression \emph{expr2} is evaluated.\\
Note that a C-\texttt{for} statement does not return any atom\\\\
The following table presents several examples of C-\texttt{for} statements:
\begin{longtable}[l]{|p{12cm}|}
\hline \begin{center}\emph{C-\texttt{for} Statement Examples}\end{center}\\
\exselect{for (x := 0; x < 100; x++) a++;}
{increment \texttt{a} an hundred times}
\exselect{for (x := 0, y := 1; x < 100 \&\& check(y); x++) \{y := get(y); if (y == 9999) break;\}}
{a more complex example}
\exselect{for (x := 100; x; x--) perform(x);}
{raises an error: \texttt{boolean expected, got integer}}
\exselect{for (x := 0;;) doit();}
{note that there is neither a conditionnal expression, nor a second expression}
\exselect{for (;;) doit();}
{same as \texttt{while(true)}}
\hline
\end{longtable}  

\subsubsect{collection-\texttt{for} statement}
{\bf Syntax}: \texttt{for} \texttt{(} \emph{var} \texttt{in} \emph{expr} \texttt{)} \emph{statement}\\
where \emph{cond\_expr} is a boolean expression, \emph{var} denotes
the name of a variable, \emph{expr} is an expression of type
collection and \emph{statement}
any statement: {\allstats}.\\\\
{\bf Semantics}: 
For each element in the collection denoted by \emph{expr}, the
variable \emph{var} is assigned to this element and the statement
is executed. 
Note that a collection-\texttt{for} statement does not return any atom\\\\
The following table presents several examples of collection-\texttt{for} statements:
\begin{longtable}[l]{|p{12cm}|}
\hline \begin{center}\emph{collection-\texttt{for} Statement Examples}\end{center}\\
\exselect{for (x in list(1, 2, 3)) a += x;}
{increments \texttt{a} with \texttt{1, 2} and \texttt{3}}
\exselect{for (x in (select Person)) names += x.name;}
{concatenates all the person names}
\exselect{for (x in (select Person.name = "john")) if (x.age < 10 || x.spouse.age < 10) throw "cannot mary children!!";}
{a moralistic example}
\exselect{for (x in 1) doit();} 
{raises an error: \texttt{boolean expected, got integer}}
\hline
\end{longtable}  

\subsect{Jump Statements}
There are two jump statements based on the keywords
\texttt{break} and \texttt{return}.

\subsubsect{\texttt{break} Statement}
The syntax for \texttt{break} statement is:\\
\texttt{break} \emph{statement}\\
where \emph{statement} is an optional integer expression statement
indicating the break level.
If not specified, the break level is \texttt{1}.
The \texttt{break} statement may appear only within an iteration statement:
\texttt{while}, \texttt{do/while}, \texttt{for} statements.
\btab[l]{|p{6cm}|p{6cm}|}
\hline \multicolumn{2}{|c|}{\texttt{break} \emph{Statement Examples}}\\
\hline \emph{Statement} & \emph{Comments}\\
\hline \texttt{break;}
& \rerr: \texttt{break operator <<break; >> : level 1 is too deep.}\\
\hline \texttt{break 3;}
& \rerr: \texttt{break operator <<break; >> : level 3 is too deep.}\\
\hline \texttt{for (x := 0; ; x++) if (x == 30) break;} &
break the loop when \texttt{x} is equal to \texttt{30}\\
\hline \texttt{while (true) \{x++; if (!check(x)) break;\}}
& break the loop when \texttt{check(x)} is not true\\
\hline \texttt{while (true) \{x++; if (!check(x)) break 2;\}}
& \rerr: \texttt{break operator <<break; >> : level 2 is too deep.}\\
\hline \texttt{while (true) \{x++; while (x < 100) if (!check(\&x)) break 2;\}}
& break the two loop when \texttt{check(\&x)} is not true\\
\hline
\etab

\subsubsect{\texttt{return} Statement}
The syntax for \texttt{return} statement is:
\texttt{return} [\emph{statement}]\\
where \emph{statement} is an optional expression statement
indicating the atom to return. The atom to return may be of any type.
If not specified, no atom is returned.
The \texttt{return} statement may appear only within a function definition statement.
\btab[l]{|p{6cm}|p{6cm}|}
\hline \multicolumn{2}{|c|}{\texttt{return} \emph{Statement Examples}}\\
\hline \emph{Statement} & \emph{Comments}\\
\hline \texttt{return;}
& \rerr: \texttt{return operator <<return; >> : return must be performed in a function}\\
\hline \texttt{function fact(n) \{return n * fact(n-1);\}}
& ok.\\
\hline \texttt{function f(x) \{if (g(x)) return x+1; return x+2;\}}
& ok.\\
\hline \texttt{function f(b) \{if (b) return list(1, 2, 3); return bag(1);\}}
& ok.\\
\hline \texttt{function f(b) \{if (b) return list(1, 2, 3); return bag(1);\}}
& ok.\\
\hline \texttt{define as f(x) (if (x) return x)} &
\rerr: \texttt{syntax error}\\
\hline
\etab


\subsect{Function Definition Statements}
As introduced previously, OQL supports functions. There are two sorts of
functions definition syntax:
function definition expression and function definition statements.
The first ones, exposed in \oqlsect{fundefexp} can contain only one
expressions. That means that they cannot include neither selection,
neither statements, neither jump statements.
Furthermore, as only one expression is allowed, functions that need
several expressions, one must use the comma sequencing operaot to
seperate the expressions, thus making this code not always readable.
\\
We introduce here the more general form of function definitions which 
overrides % NOT THE GOOD WORD!
the limitations of the previous form.
The general form of function defintion statements is:
\texttt{function} \emph{identifier} \texttt{(}[\emph{arglist}]\texttt{)}
\emph{compound\_statement}
\be
\item \emph{identifier} denotes any valid OQL identifier, except a keyword
\item \emph{arglist} is an optional comma-separated list
of identifiers
optionally followed, for default arguments, by a ``\texttt{?}''
and an \emph{expr}, for instance:\\
\texttt{(}\emph{var1}\texttt{,} \emph{var2}\texttt{,} \emph{var3}\texttt{?} 
\emph{expr}\texttt{,} \emph{var4}\texttt{?} \emph{expr}\texttt{)}
\item \emph{compound\_statement} is a optionnal semicolon-separated
list of statements surrounded by braces.
\ee
For instance:
\begin{verbatim}
function f(x, y, z ? oql$maxint) {
  if (x > y)
    throw "error #1";
  return x - y * 2 / z;
}
\end{verbatim}
\subsubsect{Argument Types/Return Type}
Functions are not typed. That means that neither the
return type nor the argument types may be given.
It is why there is no function overloading mechanisms. To take
benefit of the overloading mechanisms, one must use  methods.\\
%Typed functions are planned for a future of \eyedbX.
Nevertheless, it is possible to add type checking by using
library functions such as \texttt{is\_int}, \texttt{is\_string}...
combined with the \texttt{assert} or the \texttt{assert\_msg}
library functions.
For instance, to check that the first argument is an integer
and the second one a collection:
\begin{verbatim}
function doit(n, coll) {
   assert_msg(is_int(n), "doit: argument #1: integer expected");
   assert_msg(is_coll(coll), "doit: argument #2: collection expected");
   // body of the function
}
\end{verbatim}
The \texttt{assert\_msg} check that its first argument is equal to
\texttt{true}, otherwiser an exception containing the second argument
string is thrown:
\begin{verbatim}
doit(1, list(1, 2, 3)); // ok

doit(1.2, list(1)); // raises the error:
                    // assertion failed: 'doit: argument #1: integer expected'
\end{verbatim}

\subsubsect{Arguments \texttt{in}, \texttt{out} and \texttt{inout}}
Furthermore, one cannot specify that an argument is an input
argument (\texttt{in}), an output argument (\texttt{out}) or
an input/output argument (\texttt{inout}).
In a function call, expressions and variables are always passed
by value not by reference, this means that the call to
``\texttt{perform(x, y)}'' cannot modify neither \texttt{x} nor \texttt{y}.
(\emph{In fact, yes it can! It is explained below. But forget it for now}).\\
So, to modify variable through a function call, one needs to give the
reference (or address) of this variable, not its value.
In this case, the function must execute specific code dealing with
address variables instead of their values.\\
The \texttt{refof} operator, introduced in a previous section, gives
the reference of an identifier.
Remember that the expression \texttt{refof} \texttt{x} returns
the identifier \texttt{x}.
To make a function call using references one must do:
\texttt{swap(refof x, refof y)} or
the equivalent more compact form \texttt{swap(\&x, \&y)}.\\
Contrary to C++, reference manipulation is not transparent in OQL:
to access the value of a reference, one must use the \texttt{valof} operator
(i.e. \texttt{*} operator).
The \texttt{swap} function which swaps its two \texttt{inout} arguments
has already been introduced:
\begin{verbatim}
function swap(rx, ry) {
    v := *rx;
  *rx := *ry;
  *ry := v;
}
\end{verbatim}
The arguments have been prefixed by \texttt{r} to
indicate that they are references.
So, the function call \texttt{swap(\&x, \&y)} will swap properly
the variables \texttt{x} and \texttt{y}.\\
One can add type checking in the \texttt{swap} function, as follows:
\begin{verbatim}
function swap(rx, ry) {
  assert_msg(is_ident(rx), "swap: argument #1 identifier expected");
  assert_msg(is_ident(ry), "swap: argument #2 identifier expected");
    v := *rx;
  *rx := *ry;
  *ry := v;
}
\end{verbatim}

\subsubsect{Return Value}
By default, a statement-oriented function returns no atom. To make a
function returning an atom, one must use the \texttt{return} statement
previously introduced. As a function has no specified returned
type, it may contained several \texttt{return} statements returning
atom of different types:
\begin{verbatim}
function perform(x) {
  if (x == 1)
    return "hello";
  if (x == 2)
    return list(1, 2, 3) + list(4, 20);
  if (x == 3)
    return 2;
  if (x == 4)
    return 'a';
}

alpha := perform(1); // alpha is equal to "hello"
alpha := perform(3); // alpha is equal to 2
alpha := perform(8); // alpha is equal to nil
\end{verbatim}

\subsubsect{Default Arguments}
OQL provides support for default arguments in a function definition
statement.
The syntax for a default argument is: ``\texttt{var} \texttt{?} \emph{expr}''
or ``\texttt{var} \texttt{:=} \emph{expr}''.\\
As in C and C++, the arguments with a default value must not followed
by any argument with default values.
For instance, \texttt{function f(x, y, z := "alpha")} is valid
while \texttt{function f(x, y, z := "alpha", t)} is not valid.

\subsubsect{Unval Arguments}
Sometimes, it is interesting to prevent the evaluation of some input
arguments. For instance, let the function \texttt{if\_then\_else} which takes
three arguments:
\be
\item \texttt{cond}: a boolean expression,
\item \texttt{then\_expr}: expression of any type; is evaluated and returned
if and only if the condition is evaluated to \texttt{true}
\item \texttt{else\_expr}: expression of any type; is evaluated and returned
if and only if the condition is evaluated to \texttt{false}
\ee
It is clear that the following function definition:
\begin{verbatim}
function if_then_else(cond, then_expr, else_expr) {
   if (cond)
     return then_expr;
   return else_expr;
\end{verbatim}
is not correct as, although it returns the correct expression,
the \texttt{then\_expr} \emph{and} the \texttt{else\_expr} will be evaluated.
For instance, \texttt{if\_then\_else(x < 10, ::a := 2, ::b := 3)} will
return \texttt{2} if \texttt{x} is less than \texttt{10}, otherwise
it will return \texttt{3}, but in any case, \texttt{a} will be assigned
to \texttt{2} and \texttt{b} will be assigned to \texttt{3}.
\\
So, one needs a way to tell the interpreter that we do not want to evaluate
the second and the third argument. The special character \texttt{$|$}
before an argument means that this argument must not be evaluated.
In this case, this argument is substitued by the string representation of
the expression.
For instance, let the function \texttt{if\_then\_else}:
\begin{verbatim}
function if_then_else(cond, |then_expr, |else_expr) {
   // ...
}
\end{verbatim}
when performing the call ``\texttt{if\_then\_else(x < 10, ::a := 2, ::b := 3)}'':
\be
\item the value of \texttt{cond} in the body of the function will be
\texttt{true} or \texttt{false},
\item the value of \texttt{then\_expr} in the body of the function will be
\texttt{"::a:=2"}
\item the value of \texttt{else\_expr} in the body of the function will be
\texttt{"::b:=3"}
\ee
The correct implementation of this function is as follows:
\begin{verbatim}
function if_then_else(cond, |then_expr, |else_expr) {
   if (cond)
     return eval then_expr;
   return eval else_expr;
}
\end{verbatim}

\subsubsect{Scope of Variables}
In the body of a function defintion, every variable on the left side of an
assignment has a local scope except if this variable is prefixed by
the global scope operator \texttt{::}.
That means, that after the following statement sequence:
\begin{verbatim}
a := 2;

function doit() {
   a := 1;
}
\end{verbatim}
the variable \texttt{a} is still equal to \texttt{2}. While after:
\subsubsect{Recursivity}
\begin{verbatim}
a := 2;

function doit() {
   ::a := 1;
}
\end{verbatim}
the variable \texttt{a} is equal to \texttt{1}.

\subsubsect{Particularity}
One can define a statement-oriented function inside the body of
a statement-oriented function, for instance:
\begin{verbatim}
function compute(amount_in_euro, usdollar_per_euro) {

  function euro2usdollar(euro, usd ? usdollar_per_euro) {
      return euro * usd;
  }

  x := euro2usdollar(euro * 1.24);
  x += euro2usdollar(1000);

  return x * .120;
}
\end{verbatim}

Note that the function defined in the body of the function \texttt{compute}
has a global scope, that means that after one execution of \texttt{compute}
the function is available at the global level of the OQL session.
It is possible, that in a future version, the functions defined in
the body of a function definition will have a local scope.

\subsubsect{The \texttt{oql\$functions} Variable}
The \texttt{oql\$functions} value is a list whose elements are the name of all
the OQL functions
defined in the current OQL session. Each you add a user function,
this variable is updated.
At the beginning of a session,
the value of \\texttt{oql\$functions} is:
\begin{verbatim}
list(is_int, is_char, is_double, is_string, is_oid, is_num, is_bool, is_bag,
     is_set, is_array, is_list, is_coll, is_struct, is_empty, void, assert,
     assert_msg, min, max, first, last, cdr, count, interval, sum, avg, is_in,
     distinct, flatten, flatten1, tolower, toupper, tocap, toset, tolist,
     tobag, toarray, listtoset, bagtoset, arraytoset, listtobag, settobag,
     arraytobag, bagtolist, settolist, arraytolist, bagtoarray, settoarray,
     listtoarray, strlen, substring, forone, forall, delete_from, get_from,
     ifempty, null_ifempty, getone)
\end{verbatim}
For instance, to put the complete definition of all
these functions into the variable \texttt{functionString}:
\begin{verbatim}
 functionString := "";
 for (x in oql$functions)
   functionString += "FUNCTION " x + ": " +  bodyof x + "\n";
\end{verbatim}
The next section provides a few statement-oriented and
expression-oriented function definitions.

\newpage
\sect{Quick Reference Manual}
\label{qref}
This OQL quick reference manual presents consise information about
the builtin and library functions and methods, the special variables,
and the \texttt{eyedboql} tool. The standard library source code
is presented and it provides a quick reference card containing
all the language constructs.

\subsect{Builtin and Library Functions and Methods}
OQL provides a few builtin and library functions. The builtin functions
are written in C++ and cannot be overriden while the library functions
are written in OQL and may be redefined by the user.
The code for the library functions can be found in the section
\emph{The Standard Library Package}. The \eyedb system classes
\texttt{object}, \texttt{database}, \texttt{connection} and \texttt{EyeDB} contains
builtin class and instance methods that can be accessed from OQL.
Some of these methods are briefly introduced in this section.

\subsubsect{Type Predicat Functions}
\begin{tabbing}
\texttt{is\_intxxxxxx} \= \kill
\texttt{is\_int(x)}\>: returns \texttt{true} if \texttt{x} is an \texttt{int}\\
\texttt{is\_double(x)}\>: returns \texttt{true} if \texttt{x} is
a \texttt{double}; otherwise, returns \texttt{false}\\
\texttt{is\_string(x)}\>: returns \texttt{true} if \texttt{x} is
a \texttt{string}; otherwise, returns \texttt{false}\\
\texttt{is\_oid(x)}\>: returns \texttt{true} if \texttt{x} is
an \texttt{oid}; otherwise, returns \texttt{false}\\
\texttt{is\_num(x)}\>: returns \texttt{true} if \texttt{x} is
an number (\texttt{int}, \texttt{float} or \texttt{char});
otherwise, returns \texttt{false}\\
\texttt{is\_bool(x)}\>: returns \texttt{true} if \texttt{x} is
a \texttt{bool}; otherwise, returns \texttt{false}\\
\texttt{is\_bag(x)}\>: returns \texttt{true} if \texttt{x} is
a \texttt{bag}; otherwise, returns \texttt{false}\\
\texttt{is\_set(x)}\>: returns \texttt{true} if \texttt{x} is
a \texttt{set}; otherwise, returns \texttt{false}\\
\texttt{is\_array(x)}\>: returns \texttt{true} if \texttt{x} is
a \texttt{array}; otherwise, returns \texttt{false}\\
\texttt{is\_list(x)}\>: returns \texttt{true} if \texttt{x} is
a \texttt{list}; otherwise, returns \texttt{false}\\
\texttt{is\_coll(x)}\>: returns \texttt{true} if \texttt{x} is
a collection; otherwise, returns \texttt{false}\\
\texttt{is\_struct(x)}\>: returns \texttt{true} if \texttt{x} is
a \texttt{struct}; otherwise, returns \texttt{false}\\
\texttt{is\_empty(x)}\>: returns \texttt{true} if \texttt{x} is
\texttt{nil}; otherwise, returns \texttt{false}\\
\end{tabbing}

\subsubsection{Collection Conversion Functions}

The collection conversion functions take one collection argument and
convert this collection to another collection type and returns
the converted collection.

\newcommand{\checkcoll}[1]{checks that \texttt{coll} is a \texttt{#1} then }
\newcommand{\convcoll}[1]{converts \texttt{coll} to a \texttt{#1}}

\begin{tabbing}
\texttt{xxxxxxxxxxxxxxxxxxxxxx} \= : \=\kill
\texttt{toset(coll)}\>: \convcoll{set}\\
\texttt{tolist(coll)}\>: \convcoll{list}\\
\texttt{tobag(coll)}\>: \convcoll{bag}\\
\texttt{toarray(coll)}\>: \convcoll{array}\\
\texttt{listtoset(coll)}\>: \checkcoll{list} \convcoll{set}\\
\texttt{bagtoset(coll)}\>: \checkcoll{bag} \convcoll{set}\\
\texttt{arraytoset(coll)}\>: \checkcoll{array} \convcoll{set}\\
\texttt{listtobag(coll)}\>: \checkcoll{list} \convcoll{bag}\\
\texttt{settobag(coll)}\>: \checkcoll{set} \convcoll{bag}\\
\texttt{arraytobag(coll)}\>: \checkcoll{array} \convcoll{bag}\\
\texttt{bagtolist(coll)}\>: \checkcoll{bag} \convcoll{list}\\
\texttt{settolist(coll)}\>: \checkcoll{set} \convcoll{list}\\
\texttt{arraytolist(coll)}\>: \checkcoll{array} \convcoll{list}\\
\texttt{bagtoarray(coll)}\>: \checkcoll{bag} \convcoll{array}\\
\texttt{settoarray(coll)}\>: \checkcoll{set} \convcoll{array}\\
\texttt{listtoarray(coll)}\>: \checkcoll{set} \convcoll{array}\\
\end{tabbing}

\subsubsection{Sort Functions}

These functions are used to sort collection of sortable atom of homogeneous
types: \texttt{int}, \texttt{char}, \texttt{float} or \texttt{string}.
\begin{tabbing}
\texttt{xxxxxxxxxxxxxxxxxxxxxx} \= : \=\kill
\texttt{sort(coll)}\>: \texttt{coll} must a be a collection of homogeneous
sortable atoms;\\
\>\> sorts and returns this collection\\
\texttt{rsort(coll)}\>: \texttt{coll} must a be a collection of homogeneous
sortable atoms;\\
\>\> reverse sorts and returns this collection\\
\texttt{isort(coll, idx)}\>: \texttt{coll} must a be a collection of \texttt{list}
or \texttt{array}\\
                     \>\> of homogeneous sortable atoms;\\
                     \>\>\texttt{idx} must be of \texttt{int} type;\\
	\>\>sorts the collection of collections according to the\\
\>\> \#\texttt{idx} element
of the inner collection\\
\texttt{risort(coll, idx)}\>: same as previous function, but perform a reverse sort
\end{tabbing}

\subsubsection{Collection Miscelleanous Functions}

\begin{tabbing}
\texttt{xxxxxxxxxxxxxxxxxxxxxx} \= : \=\kill
\texttt{first(coll)}\>: returns the first element of \texttt{coll}\\
\texttt{car(coll)}\>: returns the first element of \texttt{coll}\\
\texttt{last(coll)}\>: returns the last element of \texttt{coll}\\
\texttt{cdr(coll)}\>: returns all elements of \texttt{coll} but the first\\
\texttt{getn(coll, n)}\>: returns at most n elements of \texttt{coll}\\
\texttt{count(coll)}\>: returns the count of elements of \texttt{coll}\\
\>\> identical to \texttt{coll[!]}, but less efficient\\
\texttt{sum(coll)}\>: returns the sum of the numbers of \texttt{coll}\\
\texttt{avg(coll)}\>: returns the float average of the numbers \texttt{coll}\\
\texttt{distinct(coll)}\>: eliminates duplicates of \texttt{coll}\\
\texttt{flatten(coll)}\>: recursive flattening of \texttt{coll}\\
\texttt{flatten1(coll)}\>: one level flattening of \texttt{coll}\\
\texttt{min(coll)}\>: returns the minimal number of \texttt{coll}\\
\texttt{max(coll)}\>: returns the maximal number of \texttt{coll}\\
\texttt{forone(coll, f, data)}\>: if \texttt{f(e, data)} for one element
\texttt{e}\\
\>\> of \texttt{coll}, returns \texttt{true};\\
\>\> otherwise returns \texttt{false};\\
\texttt{forall(coll, f, data)}\>: if \texttt{f(e, data)} for all element
\texttt{e}\\
\>\> of \texttt{coll}, returns \texttt{true};\\
\>\> otherwiser returns \texttt{false};\\
\end{tabbing}

\subsubsection{String Function Functions}
\begin{tabbing}
\texttt{xxxxxxxxxxxxxxxxxxxxxxxxx} \= : \=\kill
\texttt{tolower(str)}\>: converts (and returns) string \texttt{str} into lowercase\\
\texttt{toupper(str)}\>: converts (and returns) string \texttt{str} into uppercase\\
\texttt{tocap(str)}\>: converts the first character and each character
following\\
\>\>a \texttt{\_} of \texttt{str} into an uppercase\\
\texttt{strlen(str)}\>: returns the length of \texttt{str};\\
\>\> same as \texttt{str[!]}, but less efficient\\
\texttt{substring(str, from, len)}\>: returns the sub-string of \texttt{str}\\
\>\>from the \#\texttt{from} to the\\
\>\> \texttt{from+len} characters;\\
\>\>same as \texttt{str[from:from+len]} but less efficient
\end{tabbing}

\subsubsection{Query Functions}
\begin{tabbing}
\texttt{xxxxxxxxxxxxxxxxxxxxxx} \= \kill
\texttt{delete\_from(class)}\>: deletes all the instances of a given class\\
\texttt{get\_from(class)}\>: gets all the instances of a given class\\
\end{tabbing}

\subsubsection{Useful Functions}
\begin{tabbing}
\texttt{xxxxxxxxxxxxxxxxxxxxxx} \= \kill
\texttt{assert(cond)}\>: throws an exception is \texttt{cond} is not \texttt{true}\\
\texttt{assert\_msg(cond, msg)}\>: throws the exception message \texttt{msg} if \texttt{cond} is not \texttt{true}\\
\texttt{interval(from, to)}\>: returns a \texttt{list} composed of the number
from \texttt{from} to \texttt{to}
\end{tabbing}


\subsubsect{Native Methods of the Class \texttt{object}}
The native methods of the class \texttt{object} allows us to perform
a few action such as getting the oid of an instance \texttt{getOid()},
getting the database of an instance \texttt{getDatabase()} or
converts the instance to its string representation \texttt{toString()}.
For instance, to apply this last method to the first \texttt{Person} instance:
\texttt{first(select Person).toString()}.\\
\\
All the native methods of the class \texttt{object} are instance methods.
\begin{tabbing}
\texttt{void setDatabase(in database *) }\= : \kill
\texttt{oid getOid()}\> : returns the \texttt{oid} of the object\\
\texttt{string toString()}\> : returns the string representation of the object\\
\texttt{database *getDatabase()}\> : returns the \texttt{database} instance of
the object\\
\texttt{void setDatabase(in database *)}\> : changes the \texttt{database} of the object\\
\texttt{void store()}\> : stores the object in the database \\
\texttt{object *clone()}\> : clones the object; returns the clone \\
\texttt{int getCTime()}\> : returns the creation time of the object (seconds from \texttt{1/1/1970})\\
\texttt{int getMTime()}\> : returns the last modification time of the object\\
\texttt{string getStringCTime()}\> : returns the string representation of
the creation time of the object\\
\texttt{string getStringMTime()}\> : returns the string representation of
the creation time of the object\\
\texttt{bool isRemoved()}\> : returns \texttt{true} if the object is removed;
\texttt{false} otherwise\\
\texttt{bool isModify()}\> :  returns \texttt{true} if the object is modified;
\texttt{false} otherwise\\
\end{tabbing}

\subsubsect{Native Methods of the Class \texttt{connection}}
All the native methods of the class \texttt{connection} are instance methods.
an object obtained using the \texttt{new} operator,
They can be applied on a \texttt{database} object that can be either the
current connection
\texttt{oql\$db->getConnection()} either an object obtained using the \texttt{new} operator,
for instance: \texttt{new <> connection()}.
\begin{tabbing}
\texttt{xxxxxxxxxxxxxxxxxxxxxx} \= \kill
\texttt{void open()}\> : opens a new connection with default host and port\\
\texttt{void open(in string host, in string port)}\> : opens a new connection
using \texttt{host} and \texttt{port}\\
\texttt{void close()}\> : closes the connection \\
\end{tabbing}

\subsubsect{Native Methods of the Class \texttt{database}}
The following methods are the instance methods of the class \texttt{database}:
They can be applied on a \texttt{database} object that can be either
\texttt{oql\$db} either an object obtained using the \texttt{new} operator,
for instance: \texttt{new <> database(name : "foo")}.
\begin{tabbing}
\texttt{void trans}\=\texttt{actionBegin(in string mode)} \= : \= \kill
\texttt{void open(}\>\texttt{in connection *conn,}\\
                   \>\texttt{in int mode)}\> : opens a new database using the connection\\
                   \>\>\>\texttt{conn} and the open flag mode \texttt{mode}\\
\texttt{void open(}\>\texttt{in connection *conn,}\\
                   \>\texttt{in int mode,} \\
                   \>\texttt{in string userauth,}\\
                   \>\texttt{in string passwdauth)}\> :  opens a new database using the connection \texttt{conn},\\
                       \>\>\> the open flag mode \texttt{mode} and the authentication\\
                        \>\>\> \texttt{userauth}/\texttt{passwdauth}\\
\texttt{void close()}\>\> : closes the database\\
\texttt{connection *getConnection()}\>\>: returns the connection tied to
the database\\
\texttt{int getOpenMode()}\>\>: returns the open flag mode of the database
%\texttt{bool getCommitOnClose()}\>\> : \\
%\texttt{void setCommitOnClose(in bool)}\>\> : \\
 \\
\texttt{int getVersionNumber()}\>\> : returns the version number of the database\\
\texttt{string getVersion()}\>\> : returns the string version of the database\\
 \\
\texttt{void removeObject(in oid)}\>\> : removes the object whose oid is given\\
 \\
\texttt{void transactionBegin()}\>\> : begins a new transaction\\
\texttt{void transactionBegin(in string mode)}\>\> : begins a new transaction
in mode \texttt{mode}\\
\texttt{void transactionCommit()}\>\> : commits the current transaction\\
\texttt{void transactionAbort()}\>\> : abort the current transaction\\
  \\
\texttt{bool isInTransaction()}\>\> : returns \texttt{true} if
a transaction is in progress;\\
\>\>\> \texttt{false} otherwiser\\
 \\
\end{tabbing}

\subsubsect{Native Methods of the Class \texttt{EyeDB}}
All the native methods of the class \texttt{EyeDB} are class methods.

\begin{tabbing}
\texttt{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} \= \kill
\texttt{string getConfigValue(in string s)}\> : returns the
string value of the configuration variable \texttt{s}\\
\texttt{int getVersionNumber()}\> : returns the \eyedb current version number\\
\texttt{string getVersion()}\> : returns the \eyedb current stringversion\\
\texttt{string getArchitecture()}\> : returns the architecture of the current server\\
\texttt{string getDefaultCompiler()}\> : returns the C++ compiler used to
compile the current server\\
\end{tabbing}

\subsect{Special Variables}
The following variables are predefined or have a special meaning:
\begin{tabbing}
\texttt{xxxxxxxxxxxxxx} \= \kill
\texttt{oql\$variables}\> : list containing the name of all variables\\
\texttt{oql\$functions}\> : list containing the name of all functions\\
\texttt{oql\$result}\> : the result atom of the last statement\\
\texttt{oql\$db}\> : \texttt{object} atom instance of the class
\texttt{database} denoting the current database\\
\texttt{oql\$minint}\> : the minimal integer \texttt{0x8000000000000000}\\
\texttt{oql\$maxint}\> : the maximal integer \texttt{0x7FFFFFFFFFFFFFFF}\\
\texttt{oql\$minfloat}\> : the minimal float \texttt{4.94065645841246544e-324}\\
\texttt{oql\$maxfloat}\> : the maximal float \texttt{1.79769313486231570e+308}\\
\end{tabbing}
\subsect{The \texttt{eyedboql} Tool}

\texttt{eyedboql} is a tool that allows you to execute interactively OQL 
statements.
This tool is similar to the \texttt{Oracle} \texttt{sqlplus} and \texttt{Sybase}
\texttt{isql} well known tools.
\subsubsect{Running \texttt{eyedboql}}
The simplest way to run \texttt{eyedboql} is to type \texttt{eyedboql}
as follows (assuming that \texttt{\$} is your shell prompt):
\verbsize
\begin{verbatim}
$ eyedboql
Welcome to eyedboql.
  Type `\help' to display the command list.
  Type `\copyright' to display the copyright.
?
\end{verbatim}
\normalsize
The string ``\texttt{?} `` is the default prompt for \texttt{eyedboql}.
\\
\\
In an \texttt{eyedboql} session, anything you type is interpreted as an
OQL construct (or a part of an OQL construct),
\\
Nevertheless, if the first word of an input line begins with the escape
character ``\texttt{\\}'', this word is interpreted as an \texttt{eyedboql}
internal command.
There are about 30 internal commands, but you need to know only of few of them
to use \texttt{eyedboql}.\\
\\
The purpose of the main internal commands is:\\
\mbox{ } - to create or delete databases,\\
\mbox{ } - to open a database,\\
\mbox{ } - to begin, commit or abort a transaction,\\
\mbox{ } - to set the current user and password,\\
\mbox{ } - to execute the contents of a file,\\
\mbox{ } - to display the string representation of an object,\\
\mbox{ } - to display the HTML representation of an object in a WEB browser,\\
\mbox{ } - to change the prompts and the escape character.
\subsubsect{Executing Statements}
\texttt{eyedboql} allows us to execute OQL statements in an interactive way.
For instance, to perform the addition \texttt{1+3}:
\verbsize
\begin{verbatim}
$ eyedboql
Welcome to eyedboql.
  Type `\help' to display the command list.
  Type `\copyright' to display the copyright.
? 1+3;
= 4
?
\end{verbatim}
\normalsize
The string ``\texttt{=} '' preceedes the result atom (if any) of your statement;
in the current example, the result atom is the evaluation of the expression
statement \texttt{1+3;}.
\subsubsect{Execution Process}
Each complete statement typed is sent to the OQL interpreter,
A complete statement has a special meaning: it is any sequence of characters:\\
\mbox{ } \emph{a.} that end with a semi-colon and\\
\mbox{ } \emph{b.} which parenthesis are balanced and\\
\mbox{ } \emph{c.} which brakets are balanced and\\
\mbox{ } \emph{d.} which braces are balanced.\\
\\
While the statement is not complete, \texttt{eyedboql} prompts the
``second prompt'' (``\texttt{>> }'' by default) after each newline.\\
Once the statement is complete, it is sent to the OQL interpreter, then
the atom result is display (if any) after the string ``\texttt{=} ''
and the main prompt ``\texttt{?} '' is displayed again.\\\\
For instance, the input sequence of characters
``\texttt{1+}\emph{newline}\texttt{3}\emph{newline}\texttt{;}'' gives:
\verbsize
\begin{verbatim}
? 1+
>> 3
>> ;
= 4
\end{verbatim}
\normalsize
while the input sequence ``\texttt{\{ a := 1+3;}\emph{newline}\texttt{c := 2+94;}\emph{newline}\texttt{d := a+c\}}'' gives:
\verbsize
\begin{verbatim}
? { a := 1+3;
>> c := 2+94;
>> d := a+c}
?
\end{verbatim}
\normalsize
Note that no ``\texttt{=} \emph{result atom}'' is echoed because a compound
statement does not return any atom.
\\
\\
This last example:
\verbsize
\begin{verbatim}
? while (true) {
>>   a++;
>>   b++;
>> }
>>
>> ;
?
\end{verbatim}
\normalsize
shows the necessity of typing a semicolon after the \texttt{while} statement
although a \texttt{while} statement does not need to end by a semi-colom
in the OQL specifications.

\subsubsect{Getting Started}
By default in an \texttt{eyedboql} session, the database \texttt{EYEDBDBM} is opened in
read-only mode. To use another database, one must use either the command line
option \texttt{-db} either the \texttt{\\open} internal command.\\
\\
To start to play with \texttt{eyedboql} one needs to know the following
five internal commands:
\be
\item \texttt{\\open} \emph{database} [\texttt{rw}$|$\texttt{ro}] \texttt{local} \texttt{trsless}:
opens the \emph{database} in read-write (\texttt{rw}) or
read-only (\texttt{ro} or no option) mode. If \texttt{local} is there,
\emph{database} is opened in a local mode. If \texttt{trsless} is
there \emph{database} is opened in transaction-less mode.\\
For instance ``\texttt{\\open foo rw}'' opens the database \texttt{foo} is
read-write mode.
\item \texttt{\\print} [\emph{sequence of oids}] \emph{other options}: 	
if a sequence of oids is given: loads the object corresponding to each \texttt{oid}
and displays its string representation,\\
if no sequence of oids is given: loads the object corresponding to each \texttt{oid}
returned by the last statement and displays its string representation.\\
For instance, ``\texttt{select Person;}'' will return a \texttt{bag} containing
the \texttt{oid} of each \texttt{Person} instance.\\
The internal command ``\texttt{\\print}'' typed after that will loads and
displays of the corresponding \texttt{Person} instances.\\
The \emph{other options} are one or more space-separated of the followings:
\begin{tabbing}
xx\=xxxxxxxxx\=\kill
\>\texttt{full}\>: loads and displays object using the full recursive mode\\
\>\texttt{ctime}\>: displays the creation time of the object\\
\>\texttt{mtime}\>: displays the last modification time of the object\\
\>\texttt{contents}\>:  displays the contents of collections\\
\>\texttt{native}\>:  displays the native attributes\\
\>\texttt{all}\>: means ``\texttt{ctime mtime contents native}''
\end{tabbing}
For instance ``\texttt{\\print full contents}'' will load and display 
the objects and their collection contents in a full recursive mode.
\item \texttt{\\commit}: commits the current transaction
\item \texttt{\\abort}: aborts the current transaction
\item \texttt{\\quit} or \emph{\^{}D}: quits the current \texttt{eyedboql} session
\ee
Note that a transaction is started automatically before the first
complete statement of the sesssion of before the complete statement
immediately following \texttt{\\commit} or \texttt{\\abort} internal command.
\\
\\
Here is a commented example showing the use of these internal commands:\\
\\
\emph{run} \texttt{eyedboql}:
\begin{verbatim}
$ eyedboql
Welcome to eyedboql.
  Type `\help' to display the command list.
  Type `\copyright' to display the copyright.
\end{verbatim}
\emph{open the database} \texttt{person} \emph{in read-write mode}:
\begin{verbatim}
? \open person rw
\end{verbatim}
\emph{get the first person whose name is "john" and display it}:
\begin{verbatim}
? john := first(select Person.name = "john");
= 66373.12.4008447:oid
? \print
66373.12.4008447:oid Person = { 
        name = "john";
        age = 32;
        addr Address = { 
                street = "clichy";
                town = "Paris";
                country = NULL;
        };
        cstate = Sir;
        *spouse 66891.12.2738687:oid;
        cars set<Car*> = set { 
                name       = "";
                count      = 4;
                dimension  = 1;
                reference  = true;
                magorder   = 4;
        };
        children array<Person*> = array { 
                name       = "";
                count      = 0;
                range      = [0,0[;
                dimension  = 1;
                reference  = true;
                magorder   = 4;
        };
        x = NULL;
};
\end{verbatim}
\emph{change the name of john to "JOHNNY"}:
\begin{verbatim}
? john.name := "JOHNNY";
= "JOHNNY"
\end{verbatim}
\emph{retrieve the person whose name is "JOHNNY" and compares it to}
\texttt{john} \emph{using} \texttt{assert}
\emph{: all is fine, no error is raised!}
\begin{verbatim}
? assert(john = first(select Person.name = "JOHNNY"));
\end{verbatim}
\emph{abort the transaction and look for the person whose name is
"JOHNNY": no person is returned! this is ok as the transaction was aborted}:
\begin{verbatim}
? \abort
? select Person.name = "JOHNNY";
= list()
\end{verbatim}
\emph{change the name of john to "JOHNNY" again and commit the transaction}:
\begin{verbatim}
? john.name := "JOHNNY";
= "JOHNNY"
? \commit
\end{verbatim}
\emph{then retrieve again the person whose name is "JOHNNY" and compare
it to} \texttt{john} \emph{using}
\texttt{assert}\emph{: all is fine, no error is raised!}
\begin{verbatim}
? assert(john = first(select Person.name = "JOHNNY"));
\end{verbatim}
\emph{quit} \texttt{eyedboql} \emph{session}
\begin{verbatim}
? \quit
$
\end{verbatim}
We are going to conclude this section by this important note:\\
as introduced previously,
the current transaction will be committed (resp. aborted) by a \texttt{\\commit}
(resp. \texttt{\\abort}) command.
\\
If you quit \texttt{eyedboql} before committing (resp. aborting) the transaction,
it will be automatically aborted, so all your changes will be lost.
\\
This is the default behaviour. This behaviour can be changed by using the
\texttt{\\commitonclose} internal command.

\subsubsect{Command Line Options}
The \texttt{eyedboql} command line options are as follows:
\begin{tabbing}
xx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\>{\bf Program Options}:\\
\>  -d \texttt{<}name\texttt{>}, --database=\texttt{<}name>    \>  Database name\\
\>  -r, --read                     \>   Open database in read mode\\
\>  -w, --read-write               \>   Open database in read/write mode\\
\>  -s, --strict-read               \>  Open database in strict read mode\\
\>  -l, --local                \>       Open database in local mode\\
\>  -c \texttt{<}command\texttt{>}, --command=\texttt{<}command\texttt{>}\> OQL command to execute\\
\>  -p, --print                      \> Display all the objects loaded\\
\>  --full                          \>  Full recursive mode is used to display objects\\
\>  --commit                        \>  Commits the current transaction on close\\
\>  -i, --interact                  \>  Enter interpreter after executing file or commands\\
\>  -e, --echo                      \>  Echo each command\\
\>  --admin                         \>  Open database in admin mode\\
\>  -h, --help                      \>  Display this message\\
\>  {\texttt{<}file>}                        \>  File(s) to execute\\
\> \\
\>{\bf Common Options}:\\
\>  -U \texttt{<}user\texttt{>}\texttt{|}@, --user=\texttt{<}user\texttt{>}\texttt{|}@    \>    User name\\
\>  -P [\texttt{<}passwd\texttt{>}], --passwd[=\texttt{<}passwd\texttt{>}]\>  Password\\
\>  --host=\texttt{<}host\texttt{>}                \>       eyedbd host\\
\>  --port=\texttt{<}port\texttt{>}              \>         eyedbd port\\
\>  --inet                       \>       Use the tcp\_port variable if port is not set\\
\>  --dbm=\texttt{<}dbmfile\texttt{>}                \>     EYEDBDBM database file\\
\>  --conf=\texttt{<}conffile\texttt{>}               \>    Configuration file\\
\>  --logdev=\texttt{<}logfile\texttt{>}               \>   Output log file\\
\>  --logmask=\texttt{<}mask\texttt{>}                 \>   Output log mask\\
\>  --logdate=on\texttt{|}off                 \>   Control date display in output log\\
\>  --logtimer=on\texttt{|}off                \>   Control timer display in output log\\
\>  --logpid=on\texttt{|}off                  \>   Control pid display in output log\\
\>  --logprog=on\texttt{|}off                 \>   Control progname display in output log\\
\>  --error-policy=\texttt{<}value\texttt{>}            \>  Control error policy: status\texttt{|}exception\texttt{|}abort\texttt{|}stop\texttt{|}echo\\
\>  --trans-def-mag=\texttt{<}magorder\texttt{>}       \>   Default transaction magnitude order\\
\>  --arch                           \>   Display the client architecture\\
\>  -v, --version                    \>   Display the version\\
\>  --help-eyedb-options             \>   Display this message\\
\end{tabbing}
For instance, to execute the statement ``\texttt{delete\_from(Person)}''
on the database \texttt{person}:
\begin{verbatim}
$ eyedboql -d person -w -c "delete_from(Person)"
$
\end{verbatim}
To execute the command ``\texttt{persons := (select Person)}'' and then
enter the interactive mode of \texttt{eyedboql}:
\begin{verbatim}
$ eyedboql -d person -w -c "persons := (select Person)" -i
Welcome to eyedboql.
  Type `\help' to display the command list.
  Type `\copyright' to display the copyright.
?
\end{verbatim}
To execute the file \texttt{mylib.oql}:
\begin{verbatim}
$ eyedboql -d person -w mylib.oql
\end{verbatim}


\subsect{The Standard Library Package}
The \texttt{stdlib.oql} file contains a few basic library functions.
It can be found in the directory \emph{libdir}\texttt{/eyedb/oql}.
It is automatically imported when opening an OQL session.
The following code, extracted from this file, provides an interesting way to
understand OQL.
\begin{verbatim}
//
// minimal and maximal integer values
//

oql$maxint := 0x7FFFFFFFFFFFFFFF;
oql$minint := 0x8000000000000000;

nulloid := 0:0:0:oid;
NULLOID := 0:0:0:oid;

//
// type predicat functions
//

define is_int(x)    as (typeof x == "integer");
define is_char(x)   as (typeof x == "char");
define is_float(x)  as (typeof x == "float");
define is_string(x) as (typeof x == "string");
define is_oid(x)    as (typeof x == "oid");
define is_object(x) as (typeof x == "object");
define is_num(x)    as (is_int(x) || is_float(x) || is_char(x));
define is_bool(x)   as (typeof x == "bool");
define is_bag(x)    as (typeof x == "bag");
define is_set(x)    as (typeof x == "set");
define is_array(x)  as (typeof x == "array");
define is_list(x)   as (typeof x == "list");
define is_coll(x)   as (is_list(x) || is_array(x) || is_set(x) || is_bag(x));
define is_struct(x) as (typeof x == "struct");
define is_empty(x)  as (typeof x == "nil");

//
// void(x): evaluates argument and returns nil
//

define void(x) as (x, nil);

function assert(|cond) {
  r := eval cond;
  if (!r)
    throw "assertion failed: '" + cond + "'";
}

function assert_msg(|cond, msg) {
  r := eval cond;
  if (!r)
    throw "assertion failed: '" + msg + "'";
}

//
// min(l): returns the minimal integer in a collection
//

function min(l) {
  msg := "function min(" + (string l) + "): ";
  if (!is_coll(l))
    throw msg + "collection expected";

  m := oql$maxint;

  for (x in l) {
    if (x != null) {
      if (!is_num(x))
        throw (msg + "numeric expected");
      if (x < m) 
        m := x;
    }
  }

  return m;
}

//
// max(l): returns the maximal integer in a collection
//

function max(l) {
  msg := "function max(" + (string l) + "): ";
  if (!is_coll(l))
    throw msg + "collection expected";
  m := oql$minint;
  for (x in l) {
    if (x != null) {
      if (!is_num(x))
        throw (msg + "numeric expected");
      if (x > m)
        m := x;
    }
  }
  return m;
}

//
// first(l): returns the first element in a list or array
//

function first(l) {
  if (!is_coll(l)) // if (!is_list(l) && !is_array(l))
    throw "function first: collection expected";

  start := 0;
  f := nil;
  for (x in l)
    if (start == 0) {
      start := 1;
      f := x;
      break;
    }
  return f;
}

car := &first;

//
// last(l): returns the last element in a list or array
//

function last(l) {
  if (!is_coll(l)) // if (!is_list(l) && !is_array(l))
    throw "function last: list or array expected";

  f := nil;
  for (x in l)
    f := x;
  return f;
}

//
// cdr(l): returns all elements in a collection except the first one
//

function cdr(l) {
  if (!is_coll(l)) // if (!is_list(l) && !is_array(l))
    throw "function cdr: list or array expected";

  r := list();
  n := 0;
  for (x in l) {
    if (n != 0)
      r += x;
    n++;
  }
  return r;
}

//
// getn(l, n): returns all elements in a collection
//

function getn(l, n) {
   rl := list();
   cnt := 0;

   for (x in l) {
     if (cnt++ >= n)
       break;
     rl += x;
   }

   return rl;
}

//
// getrange(l, f, nb): returns all elements in a collection from element from
//
// identical to l[f:f+nb]
//

function getrange(l, f, nb) {
  if (!is_list(l) && !is_array(l))
    throw "function getrange: list or array expected";

   rl := list();
   cnt := 0;

   max := f + nb;

   for (x in l) {
     if (cnt >= max)
       break;

     if (cnt >= f)
       rl += x;

     cnt++;
   }

   return rl;
}

//
// count(l): returns element count of a collection
//

function count(l) {
  if (typeof l == "nil")
    return 0;
  if (!is_coll(l))
    throw "function count: collection expected, got " + typeof(l);
  return l[!];
}

//
// interval(x, y): constructs an integer list bounded by 'x' and 'y'
//

function interval(x, y) {
  n := x-1;
  l := list();
  while (n++ < y)
    l += n;
  return l;
}

//
// sum(l): returns the sum of collection elements
//

function sum(l) {
  if (!is_coll(l))
    throw "function sum: collection expected";
  n := 0;
  for (x in l)
    n += x;
  return n;
}

//
// avg(l): returns the average of collection elements
//

function avg(l) {
  if (!is_coll(l))
    throw "function avg: collection expected";
  return float(sum(l))/count(l);
}

//
// is_in(l, z): returns true in element 'z' is in collection 'l'
//

function is_in(l, z) {
  for (x in l)
    if (x == z)
      return true;

  return false;
}

//
// distinct(l): returns distinct elements in a collection
//

function distinct(l) {
  if (is_list(l)) ll := list();
  else if (is_bag(l)) ll := bag();
  else if (is_array(l)) ll := array();
  else if (is_set(l)) ll := set();
  else throw "function distinct: collection expected";

  for (x in l)
    if (!is_in(ll, x))
      ll += x;

  return ll;
}

//
// flatten(l): full recursive flatten function
//

function flatten(l) {
  if (!is_coll(l))
    return l;
  ll := list();
  for (x in l)
    if (is_coll(x))
      ll += flatten(x);
    else
      ll += x;

  return ll;
}

//
// flatten1(l): 1-level recursive flatten function
//

function flatten1(l) {
  if (!is_coll(l))
    return l;

  ll := list();
  for (x in l)
    ll += x;
  return ll;
}
            
//
// tolower(s): returns lower case string
//

function tolower(s) {

  n := 0;
  x := "";
  delta := 'a' - 'A';

  while (s[n] != '\000') {
    if (s[n] >= 'A' && s[n] <= 'Z')
      x += string(char(s[n] + delta));
    else
      x += string(s[n]);
    n++;
  }

  return x;
}

//
// toupper(s): returns upper cased string
//

function toupper(s) {

  n := 0;
  x := "";
  delta := 'A' - 'a';

  while (s[n] != '\000') {
    if (s[n] >= 'a' && s[n] <= 'z')
      x += string(char(s[n] + delta));
    else x += string(s[n]);
    n++;
  }

  return x;
}

//
// tocap(s): returns capitalized word string
//

function tocap(s) {

  n := 1;
  x := "";
  delta := 'A' - 'a';

  s := tolower(s);

  if (s[0] >= 'a' && s[0] <= 'z')
    x += string(char(s[0] + delta));

  while (s[n] != '\000') {
    if (s[n] == '_')
      x += string(char(s[++n] + delta));
    else
      x += string(s[n]);
    n++;
  }

  return x;
}

//
// Collection Conversion Functions
//

//
// General Conversion Functions
//

function toset(l) {
  if (!is_coll(l))
    throw ("function toset: collection expected, got " + typeof(l));

  if (!is_set(l)) {
    s := set();
    for (x in l)
      s += x;
    return s;
  }

  return l;
}

function tolist(l) {
  if (!is_coll(l))
    throw ("function tolist: collection expected, got " +  typeof(l));

  if (!is_list(l)) {
    s := list();
    for (x in l)
      s += x;
    return s;
  }

  return l;
}

function tobag(l) {
  if (!is_coll(l))
    throw ("function tobag: collection expected, got " +  typeof(l));

  if (!is_bag(l)) {
    s := bag();
    for (x in l)
      s += x;
    return s;
  }

  return l;
}

function toarray(l) {
  if (!is_coll(l))
    throw ("function toarray: collection expected, got " +  typeof(l));

  if (!is_array(l)) {
    s := array();
    for (x in l)
      s += x;
    return s;
  }

  return l;
}

//
// toset family Conversion Functions
//

function listtoset(l) {
  if (!is_list(l))
    throw ("function listtoset: list expected, got " + typeof(l));
  return toset(l);
}

function bagtoset(l) {
  if (!is_bag(l))
    throw ("function bagtoset: bag expected, got " + typeof(l));
  return toset(l);
}

function arraytoset(l) {
  if (!is_array(l))
    throw ("function arraytoset: array expected, got " + typeof(l));
  return toset(l);
}


//
// tobag family Conversion Functions
//

function listtobag(l) {
  if (!is_list(l))
    throw ("function listtobag: list expected, got " + typeof(l));
  return tobag(l);
}

function settobag(l) {
  if (!is_set(l))
    throw ("function settobag: set expected, got " + typeof(l));
  return tobag(l);
}

function arraytobag(l) {
  if (!is_array(l))
    throw ("function arraytobag: array expected, got " + typeof(l));
  return tobag(l);
}

//
// tolist family Conversion Functions
//

function bagtolist(l) {
  if (!is_bag(l))
    throw ("function bagtolist: bag expected, got " + typeof(l));
  return tolist(l);
}

function settolist(l) {
  if (!is_set(l))
    throw ("function settolist: set expected, got " + typeof(l));
  return tolist(l);
}

function arraytolist(l) {
  if (!is_array(l))
    throw ("function arraytolist: array expected, got " + typeof(l));
  return tolist(l);
}

//
// toarray family Conversion Functions
//

function bagtoarray(l) {
  if (!is_bag(l))
    throw ("function bagtoarray: bag expected, got " + typeof(l));
  return toarray(l);
}

function settoarray(l) {
  if (!is_set(l))
    throw ("function settoarray: set expected, got " + typeof(l));
  return toarray(l);
}

function listtoarray(l) {
  if (!is_list(l))
    throw ("function listtoarray: list expected, got " + typeof(l));
  return toarray(l);
}

//
// strlen(s): same as s[!]
//

function strlen(s) {
  len := 0;
  while (s[len] != '\000')
    len++;
  return len;
}

//
// substring(str, f, len)
//

function substring(str, f, len) {
  s := "";
  n := 0;
  max := str[!] - f;
  while (n < len && n < max) {
    s += string(str[n+f]);
    n++;
  }

  return s;
}

//
// forone(l, fpred, data): returns true if and only if the function 'fpred'
// returns true for at least one element 'x' in list 'l'
//

function forone(l, fpred, data) {
  for (x in l)
    if (fpred(x, data)) return true;
  return false;
}
        
//
// forone(l, fpred, data): returns true if and only if the function 'fpred'
// returns true for all elements 'x' in list 'l'
//

function forall(l, fpred, data) {
  for (x in l)
    if (!fpred(x, data)) return false;
  return true;
}
        
//
// delete_from(cls): delete all instances of class 'cls'
//

function delete_from(|cls) {
  for (x in (eval "select " + cls))
    delete x;
}

//
// delete_(coll): delete contents of collection coll
//

function delete_(coll) {
  for (x in coll)
    delete x;
}

//
// get_from(cls): returns all instances of class 'cls'
//

function get_from(|cls) {
  eval "select " + cls;
}

//
// generates an unused global symbol
//

function gensym() {
  prefix := "::oql#_#_#";
  for (i := 0; ; i++) {
    varname := prefix + string(i);
    if (!(eval "isset " + varname)) {
      eval varname + " := 0";
      return ident(varname);
    }                        
  }                
}

//
// expression-like for-each function
//

function foreach_expr(|x, |coll, |expr, colltyp ? "list") {
  varname := "_#_#_R_#_#_";

  statement := "push " + varname + " := " + colltyp + "(); " +
    "for (" + x + " in " + coll + ") " +
    "{" + varname + " += " + expr + ";}" +
    "pop " + varname;

  return eval statement;
}

//
// expression-like for-C function
//

function for_expr(|start, |cond, |end, |expr, colltyp ? "list") {
  varname := "_#_#_R_#_#_";

  statement := "push " + varname + " := " + colltyp + "(); " +
    "for (" + start + "; " + cond + "; " + end + ")" +
    "{" + varname + " += " + expr + ";}" +
    "pop " + varname;
   
   return eval statement;
}

//
// expression-like while-C function
//

function while_expr(|cond, |expr, colltyp ? "list") {
  varname := "_#_#_R_#_#_";

  statement := "push " + varname + " := " + colltyp + "(); " +
    "while (" + cond + ")" +
    "{" + varname + " += " + expr + ";}" +
    "pop " + varname;
   
   return eval statement;
}

//
// expression-like do/while-C function
//

function do_while_expr(|expr, |cond, colltyp ? "list") {
  varname := "_#_#_R_#_#_";

  statement := "push " + varname + " := " + colltyp + "(); " +
    "do {" + varname + " += " + expr + ";}" +
    "while (" + cond + ");" +
    "pop " + varname;
  
   return eval statement;
}

function extentof(|classname) {
  return (select one class.name = classname).extent;
}

function countof(|classname) {
  return (select one class.name = classname).extent.count;
}

function objectcount(db := oql$db) {
     objcnt := 0;
     db->transactionBegin();
     for (cl in (select <db> x from class x where
                 x.type != "system" and x.name !~ "<"))
        objcnt += cl.extent.count;
     db->transactionCommit();
     return objcnt;
}

function ifempty(x, y) {
  if (is_empty(x)) 
    return y;
  return x;
}

function null_ifempty(x) {
  return ifempty(x, null);
}

function getone(x) {
  if (is_empty(x)) 
    return null;
  return first(flatten(x));
}

//
// database and transaction management
//

function open_db(db_name_or_id, strmode, user := null, passwd := null) {

  if (strmode == "r")
    mode := DBREAD;
  else if (strmode == "rw")
    mode := DBRW;
  else if (strmode == "rlocal")
    mode := DBREAD|DBOPENLOCAL;
  else if (strmode == "rwlocal")
    mode := DBRW|DBOPENLOCAL;
  else
    throw "invalid open mode: r, rw, rlocal or rwlocal expected, got " +
      strmode;

  if (is_int(db_name_or_id))
    db := new<> database(dbid : db_name_or_id);
  else
    db := new<> database(dbname : db_name_or_id);

  if (user == null)
    db.open(oql$db.getConnection(), mode);
  else
    db.open(oql$db.getConnection(), mode, user, passwd);

  return db;
}

function set_default(db) {
  db->setDefaultDatabase();
}

function begin(db := oql$db) {
  db->transactionBegin();
}

function begin_params(trsmode, lockmode, recovmode, magorder, ratioalrt, wait_timeout, db := oql$db) {
  db->transactionBegin(trsmode, lockmode, recovmode, magorder, ratioalrt, wait_timeout);
}

function commit(db := oql$db) {
  db->transactionCommit();
}

function abort(db := oql$db) {
  db->transactionAbort();
}

//
// miscellaneous
//

function print_function(f) {
  print "function " + (bodyof f) + "\n";
}

function print_functions() {
  cnt := 0;
  for (f in oql$functions) {
    if (cnt > 0) print "\n";
    print_function(f);
    cnt++;
  }
}

function print_variable(v) {
   print string(v) + " = " + string(eval string(v)) + ";\n";
}

function print_variables() {
  for (v in oql$variables) {
    print_variable(v);
    cnt++;
  }
}

function print_classes(system := false) {
  if (system)
    l := (select list(x, x.name) from class x order by x.name);
  else
    l :=  (select list(x, x.name) from class x where x.type = "user" and x.name !~ "<" order by x.name);

  for (c in l) {
    cls := c[0];
    clsname := c[1];
    print "class " + clsname;
    if (cls.parent != NULL && (system || cls.parent.type != "system"))
       print " extends " + cls.parent.name;
    print "\n";
  }
}

function print_obj(o, flags := 0) {
   print o->toString(flags);
}

function print_objs(l, flags := 0) {
   for (o in l)
     print_obj(o, flags);
}

//
// contents_ expression
//

function contents_(coll) {
  r := list();
  for (x in coll) {
   for (s in contents(x)) 
     r += s;
  }

  return r;
};

function println(s) {
  print(s+"\n");
}

function bench(|cmd) {
  t0 := time_stamp::local_time_stamp();
  r := eval cmd;
  t1 := time_stamp::local_time_stamp();
  us := t1->substract(t0).usecs;
  println("Elapsed time: " + string(us/1000.) + " ms");
  return r;
}

;
\end{verbatim}


\newpage
\subsect{OQL Quick Reference Card}
The following table presents all the OQL statements, expression types and the operators.
For the operators common to C++ and OQL, the precedence and associativity
is the same.
\newcommand{\optab}{\btab[l]{|p{4.5cm}|p{3cm}|p{6cm}|}}
\optab
\hline 
\multicolumn{3}{|c|}{}\\
\multicolumn{3}{|c|}{\bf Quick Reference Card} \\
\multicolumn{3}{|c|}{}\\
\hline \multicolumn{3}{|c|}{Statements} \\
\hline expression statement & \multicolumn{2}{|l|}{\ex \texttt{;}}\\
\hline selection statement & \multicolumn{2}{|l|}{\texttt{if} \texttt{(} \emph{cond\_expr} \texttt{)} \emph{statement} [\texttt{else} \emph{statement}]}\\
\hline jump statements
 & \multicolumn{2}{|l|}{\texttt{break} [\emph{expr}] \texttt{;}}\\
 & \multicolumn{2}{|l|}{\texttt{return} [\emph{expr}] \texttt{;}}\\
\hline iteration statements 
& \multicolumn{2}{|l|}{\texttt{while} \texttt{(} \emph{cond\_expr} \texttt{)} \emph{statement}}\\
& \multicolumn{2}{|l|}{\texttt{do} \emph{statement} \texttt{while} \texttt{(} \emph{cond\_expr} \texttt{)}}\\
& \multicolumn{2}{|l|}{\texttt{for} \texttt{(} [\emph{expr}] \texttt{;} [\emph{cond\_expr}] \texttt{;} [\emph{expr}] \texttt{)} \emph{statement}}\\
& \multicolumn{2}{|l|}{\texttt{for} \texttt{(} \emph{var} \texttt{in} \emph{expr} \texttt{)} \emph{statement}}\\
\hline compound statement & \multicolumn{2}{|l|}{\texttt{\{} \emph{statement} \texttt{\}}}\\
\hline function definition statement & \multicolumn{2}{|l|}{
\texttt{function} \emph{identifier} \texttt{(}[\emph{arglist}]\texttt{)}
\emph{compound\_statement}}\\
\hline empty statement & \multicolumn{2}{|l|}{\texttt{;}}\\
\hline \multicolumn{3}{|c|}{Arithmetic Expressions} \\
\hline add & \texttt{+} & \bin{+} \\
substract                              & \texttt{-} & \bin{-} \\
multiply                              & \texttt{*} & \bin{*} \\
divide                              & \texttt{/} & \bin{/} \\
shift left                              & \texttt{<<} & \bin{<<} \\
shift right                              & \texttt{>>} & \bin{>>} \\
modular                              & \texttt{\%} & \bin{\%} \\
bitwise and                              & \texttt{\&} & \bin{\&} \\
bitwise inclusive or                              & \texttt{|} & \bin{|} \\
bitwise xor                              & \texttt{\^{}} & \bin{\^{}} \\
complement                              & \texttt{\~{}} & \una{\~{}} \\
\hline \multicolumn{3}{|c|}{Assignment Expressions}\\
\hline simple assignment  & \texttt{:=} & \ass{:=} \\
add and assign                           & \texttt{+=} & \ass{+=} \\
substract and assign             & \texttt{-=} & \ass{-=} \\
multiply and assign                 & \texttt{*=} & \ass{*=} \\
divide and assign               & \texttt{/=} & \ass{/=} \\
shift left and assign           & \texttt{<<} & \ass{<<=} \\
shift right and assign          & \texttt{>>} & \ass{>>=} \\
inclusive OR and assign         & \texttt{|=} & \ass{|=} \\
exclusive OR and assign         & \texttt{\&} & \ass{\&=} \\
modulo and assign                & \texttt{\%} & \ass{\%=} \\
exclusive OR and assign         & \texttt{\^{}} & \ass{\^{}=} \\
\hline \multicolumn{3}{|c|}{Auto Increment \& Decrement Expressions}\\
\hline {post increment} & \texttt{++} & \emph{lvalue}\texttt{++} \\
 {post decrement}        & \texttt{--} & \emph{lvalue}\texttt{--} \\
 {pre increment}        & \texttt{++} & \texttt{++}\emph{lvalue} \\
{pre increment}        & \texttt{--} & \texttt{--}\emph{lvalue} \\
\hline \multicolumn{3}{|c|}{Logical Expressions}\\
\hline
logical and & \texttt{\&\&} & \bin{\&\&} \\
logical and & \texttt{and} & \bin{and} \\
logical or & \texttt{||} & \bin{||} \\
logical or & \texttt{or} & \bin{or} \\
\hline \multicolumn{3}{|c|}{Comparison Expressions}\\
\hline
not & \texttt{!} & \una{!} \\
not & \texttt{not} & \una{not} \\
equal & \texttt{=} & \bin{=} \\
equal & \texttt{==} & \bin{==} \\
not equal & \texttt{!=} & \bin{!=} \\
less than & \texttt{<} & \bin{<} \\
less & \texttt{<=} & \bin{<=} \\
greater & \texttt{>} & \bin{>} \\
greater than & \texttt{>=} & \bin{>=} \\
match regular expression & \texttt{\~{}} & \bin{\~{}} \\
match regular expression case insensitive & \texttt{\~{}\~{}} & \bin{\~{}\~{}}\\
not match regular expression  & \texttt{!\~{}} & \bin{!\~{}}\\
not match regular expression case insensitive  & \texttt{!\~{}\~{}} & \bin{!\~{}\~{}} \\
match regular expression & \texttt{like} & \bin{like}\\
\hline \multicolumn{3}{|c|}{Conditionnal Expressions}\\
\hline
conditionnal expression & \texttt{? :} & \ex \texttt{?} \ex \texttt{:} \ex \\
\hline \multicolumn{3}{|c|}{Expression Lists}\\
\hline
comma sequencing & \texttt{,} & \bin{,} \\
\hline \multicolumn{3}{|c|}{Array Expressions}\\
\hline
subscripting & \texttt{[]} & \ex\texttt{[}\ex\texttt{]}\\
interval subscriptiong & \texttt{[:]} & \ex\texttt{[}\ex\texttt{:}\ex\texttt{]}\\
\hline \multicolumn{3}{|c|}{Path Expressions}\\
\hline member selection & \texttt{.} & \bin{.} \\
member selection & \texttt{->} & \bin{->}\\
\hline \multicolumn{3}{|c|}{Function Call}\\
\hline
function call & \texttt{()} & \ex \texttt{(}\emph{expr\_list}\texttt{)}\\
\hline \multicolumn{3}{|c|}{Method Invocation}\\
member selection & \texttt{()} & \ex\texttt{->}\ex \texttt{(}\emph{arglist}\texttt{)}\\
\hline \multicolumn{3}{|c|}{Eval/Unval Operators}\\
\hline
eval & \texttt{eval} & \una{eval} \\
no eval & \texttt{unval} & \una{unval}\\
\hline \multicolumn{3}{|c|}{Identifier Expressions}\\
\hline scope & \texttt{::} & \texttt{::} \ide \\
is set& \texttt{isset} & \unide{isset} \\
unset & \texttt{unset} & \unide{unset} \\
reference of & \texttt{\&} & \unide{\&} \\&
  \texttt{refof} & \unide{refof} \\
value of & \texttt{*} & \unide{*} \\
value of & \texttt{valof} & \unide{valof} \\
scope of & \texttt{scopeof} & \unide{scopeof} \\
push onto symbol table & \texttt{push} & \unide{push} \\
push onto symbol table and assign & \texttt{push} & \una{push} \\
pop from symbol table & \texttt{pop} & \unide{pop} \\
\hline \multicolumn{3}{|c|}{Set Expressions}\\
\hline
union  & \texttt{union} & \bin{union} \\
intersection & \texttt{intersect} & \bin{intersect} \\
except & \texttt{except} & \bin{except} \\
include & \texttt{<} & \bin{<} \\
include or equal  & \texttt{<=} & \bin{<=} \\
contain & \texttt{>} & \bin{>} \\
contain or equal & \texttt{>=} & \bin{>=} \\
\hline \multicolumn{3}{|c|}{Object Creation}\\
\hline
new & \texttt{new} & [\texttt{new}] \emph{new\_construct} \\
new & \texttt{new} & \texttt{new<} \emph{opt\_expr} \texttt{>} \emph{new\_construct} \\
\hline \multicolumn{3}{|c|}{Object Deletion}\\
\hline delete  & \texttt{delete} & \una{delete} \\
\hline \multicolumn{3}{|c|}{Collection Expressions}\\
\hline contents & \texttt{contents} & \una{contents} \\
is in & \texttt{in} & \bin{in} \\
add to collection & \texttt{add to}& \texttt{add} \ex \texttt{to} \ex \\
suppress from collection & \texttt{suppress from}& \texttt{suppress} \ex \texttt{from} \ex \\
set element in or get element from an indexed collection & \texttt{[]}& \ex \texttt{[} \ex \texttt{]}\\
append to an indexed collection & \texttt{append/to}& \texttt{append} \ex \texttt{to} \ex\\
empty collection & \texttt{empty} & \una{empty} \\
exists in collection & \texttt{in} & \texttt{exists} \ide \texttt{in} \ex \texttt{:} \ex \\
for all in collection & \texttt{for all} & \texttt{for} \texttt{all} \ide  \texttt{in} \ex \texttt{:} \ex \\
for some in collection & \texttt{for} & \texttt{for} \texttt{<} \ex \texttt{,} \ex \texttt{>}
  \texttt{in} \ex \texttt{:} \ex \\
\hline \multicolumn{3}{|c|}{Exception Expressions}\\
\hline
throw exception & \texttt{throw} & \una{throw}\\
\hline \multicolumn{3}{|c|}{Function Definition}\\
\hline define function & \texttt{define as} & \texttt{define} \ide[\emph{arglist} \texttt{as} \ex\\
\hline \multicolumn{3}{|c|}{Conversion}\\
\hline
string conversion & \texttt{string} & \texttt{string(} \ex \texttt{)} \\
integer conversion & \texttt{int} & \texttt{int(} \ex \texttt{)} \\
character conversion & \texttt{char} & \texttt{char(} \ex \texttt{)} \\
float conversion & \texttt{float} & \texttt{float(} \ex \texttt{)} \\
identifier conversion & \texttt{ident} & \texttt{ident(} \ex \texttt{)} \\
oid conversion & \texttt{oid} & \texttt{oid(} \ex \texttt{)} \\
\hline \multicolumn{3}{|c|}{Query Expressions}\\
\hline database query & \texttt{select} & \texttt{select} \ex [\texttt{from} \{\ex [\texttt{as}] \emph{identifier}\} [\texttt{where} \emph{expr}]] [\texttt{order} \texttt{by} \{\emph{expr}\}] \\
 & & \texttt{select} \ex [\texttt{from} \{\emph{identifier} \texttt{in} \emph{expr}\} [\texttt{where} \emph{expr}]] [\texttt{order} \texttt{by} \{\emph{expr}\}]\\
\hline \multicolumn{3}{|c|}{Type Information Expressions}\\
\hline
class of & \texttt{classof} & \una{classof} \\
typeof of & \texttt{typeof} & \una{typeof} \\
\hline \multicolumn{3}{|c|}{Miscellenaous Expressions}\\
\hline structure of & \texttt{structof} & \una{structof} \\
body of & \texttt{bodyof} & \una{bodyof} \\
\hline length pf & \texttt{[!]} & \unar{[!]} \\
import package & \texttt{import} & \una{import} \\
\hline
\etab


\end{document}
