
/*
 * EyeDB Version 2.8.8 Copyright (c) 1995-2006 SYSRA
 *
 * File 'syscls.h'
 *
 * Package Name 'syscls'
 *
 * Generated by eyedbodl at Thu Sep 10 15:17:01 2009
 *
 * ---------------------------------------------------
 * -------------- DO NOT EDIT THIS CODE --------------
 * ---------------------------------------------------
 *
 */

#include <eyedb/eyedb.h>

#ifndef _eyedb_syscls_
#define _eyedb_syscls_

namespace eyedb {

class AttributeComponent;
class AttributeComponentSet;
class ClassComponent;
class AgregatClassComponent;
class ClassVariable;
class Index;
class HashIndex;
class BTreeIndex;
class CollAttrImpl;
class ArgType;
class Signature;
class Executable;
class AgregatClassExecutable;
class Method;
class FEMethod;
class FEMethod_C;
class BEMethod;
class BEMethod_C;
class BEMethod_OQL;
class Trigger;
class UniqueConstraint;
class NotNullConstraint;
class CardinalityDescription;
class CardinalityConstraint;
class CardinalityConstraint_Test;
class ProtectionUser;
class Protection;
class UnreadableObject;
class ClassConversion;


class syscls {

 public:
  syscls(int &argc, char *argv[]) {
    eyedb::init(argc, argv);
    init();
  }

  ~syscls() {
    release();
    eyedb::release();
  }

  static void init();
  static void release();
  static eyedb::Status updateSchema(eyedb::Database *db);
  static eyedb::Status updateSchema(eyedb::Schema *m);
};

class sysclsDatabase : public eyedb::Database {

 public:
  sysclsDatabase(const char *dbname, const char *_dbmdb_str = 0) : eyedb::Database(dbname, _dbmdb_str) {}
  sysclsDatabase(eyedb::Connection *conn, const char *dbname, const char *_dbmdb_str, eyedb::Database::OpenFlag, const char *user = 0, const char *passwd = 0);
  sysclsDatabase(eyedb::Connection *conn, const char *dbname, eyedb::Database::OpenFlag, const char *user = 0, const char *passwd = 0);
  sysclsDatabase(const char *dbname, int _dbid, const char *_dbmdb_str = 0) : eyedb::Database(dbname, _dbid, _dbmdb_str) {}
  sysclsDatabase(int _dbid, const char *_dbmdb_str = 0) : eyedb::Database(_dbid, _dbmdb_str) {}
  eyedb::Status open(eyedb::Connection *, eyedb::Database::OpenFlag, const char *user = 0, const char *passwd = 0);
  eyedb::Status open(eyedb::Connection *, eyedb::Database::OpenFlag, const eyedb::OpenHints *hints, const char *user = 0, const char *passwd = 0);
  static void setConsApp(eyedb::Database *);
  static eyedb::Status checkSchema(eyedb::Schema *);
  static eyedb::Bool getDynamicGetErrorPolicy();
  static eyedb::Bool getDynamicSetErrorPolicy();
  static void setDynamicGetErrorPolicy(eyedb::Bool policy);
  static void setDynamicSetErrorPolicy(eyedb::Bool policy);
};

enum IndexType {
  HashIndexType = 32,
  BTreeIndexType = 64
};

enum ExecutableLang {
  C_LANG = 1,
  OQL_LANG = 2,
  SYSTEM_EXEC = 256
};

enum ArgType_Type {
  ANY_TYPE = 0,
  VOID_TYPE = 1,
  INT16_TYPE = 2,
  INT32_TYPE = 3,
  INT64_TYPE = 4,
  STRING_TYPE = 5,
  CHAR_TYPE = 6,
  FLOAT_TYPE = 7,
  OID_TYPE = 8,
  OBJ_TYPE = 9,
  RAW_TYPE = 10,
  BYTE_TYPE = 11,
  ARRAY_TYPE = 256,
  IN_ARG_TYPE = 4096,
  OUT_ARG_TYPE = 8192,
  INOUT_ARG_TYPE = 12288
};

enum ExecutableLocalisation {
  BACKEND = 1,
  FRONTEND = 2,
  STATIC_EXEC = 256
};

enum ExecutableType {
  METHOD_C_TYPE = 2,
  METHOD_OQL_TYPE = 18,
  TRIGGER_C_TYPE = 8,
  TRIGGER_OQL_TYPE = 24
};

enum TriggerType {
  TriggerCREATE_BEFORE = 17,
  TriggerCREATE_AFTER = 18,
  TriggerUPDATE_BEFORE = 33,
  TriggerUPDATE_AFTER = 34,
  TriggerLOAD_BEFORE = 65,
  TriggerLOAD_AFTER = 66,
  TriggerREMOVE_BEFORE = 129,
  TriggerREMOVE_AFTER = 130
};

enum ProtectionMode {
  ProtRead = 256,
  ProtRW = 257
};

enum ClassUpdateType {
  ADD_ATTR = 0,
  RMV_ATTR = 1,
  CNV_ATTR = 2,
  MIG_ATTR = 3,
  RMV_CLASS = 4
};

enum AttributeConvertType {
  INT16_TO_INT16 = 0,
  INT16_TO_INT32 = 1,
  INT16_TO_INT64 = 2,
  INT16_TO_FLOAT = 3,
  INT16_TO_BYTE = 4,
  INT16_TO_CHAR = 5,
  INT16_TO_ENUM = 6,
  INT32_TO_INT32 = 7,
  INT32_TO_INT16 = 8,
  INT32_TO_INT64 = 9,
  INT32_TO_FLOAT = 10,
  INT32_TO_BYTE = 11,
  INT32_TO_CHAR = 12,
  INT32_TO_ENUM = 13,
  INT64_TO_INT64 = 14,
  INT64_TO_INT16 = 15,
  INT64_TO_INT32 = 16,
  INT64_TO_FLOAT = 17,
  INT64_TO_BYTE = 18,
  INT64_TO_CHAR = 19,
  INT64_TO_ENUM = 20,
  FLOAT_TO_FLOAT = 21,
  FLOAT_TO_INT16 = 22,
  FLOAT_TO_INT32 = 23,
  FLOAT_TO_INT64 = 24,
  FLOAT_TO_BYTE = 25,
  FLOAT_TO_CHAR = 26,
  FLOAT_TO_ENUM = 27,
  CHAR_TO_CHAR = 28,
  CHAR_TO_INT16 = 29,
  CHAR_TO_INT32 = 30,
  CHAR_TO_INT64 = 31,
  CHAR_TO_FLOAT = 32,
  CHAR_TO_BYTE = 33,
  CHAR_TO_ENUM = 34,
  BYTE_TO_BYTE = 35,
  BYTE_TO_INT16 = 36,
  BYTE_TO_INT32 = 37,
  BYTE_TO_INT64 = 38,
  BYTE_TO_FLOAT = 39,
  BYTE_TO_CHAR = 40,
  BYTE_TO_ENUM = 41,
  ENUM_TO_ENUM = 42,
  ENUM_TO_INT16 = 43,
  ENUM_TO_INT32 = 44,
  ENUM_TO_INT64 = 45,
  ENUM_TO_FLOAT = 46,
  ENUM_TO_CHAR = 47,
  ENUM_TO_BYTE = 48,
  CHAR_TO_STRING = 49,
  STRING_TO_CHAR = 50,
  INT16_TO_STRING = 51,
  STRING_TO_INT16 = 52,
  INT32_TO_STRING = 53,
  STRING_TO_INT32 = 54,
  INT64_TO_STRING = 55,
  STRING_TO_INT64 = 56,
  FLOAT_TO_STRING = 57,
  STRING_TO_FLOAT = 58,
  BYTE_TO_STRING = 59,
  STRING_TO_BYTE = 60,
  SET_TO_BAG = 61,
  SET_TO_ARRAY = 62,
  SET_TO_LIST = 63,
  BAG_TO_SET = 64,
  BAG_TO_ARRAY = 65,
  BAG_TO_LIST = 66,
  ARRAY_TO_BAG = 67,
  ARRAY_TO_SET = 68,
  ARRAY_TO_LIST = 69,
  LIST_TO_BAG = 70,
  LIST_TO_ARRAY = 71,
  LIST_TO_SET = 72,
  CLASS_TO_CLASS = 73,
  USER_CNV = 74,
  NIL_CNV = 75
};

class AttributeComponent : public eyedb::Struct {

 public:
  AttributeComponent(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  AttributeComponent(const AttributeComponent& x);

  virtual eyedb::Object *clone() const {return new AttributeComponent(*this);};

  AttributeComponent& operator=(const AttributeComponent& x);

  virtual AttributeComponent *asAttributeComponent() {return this;}
  virtual const AttributeComponent *asAttributeComponent() const {return this;}
  virtual Index *asIndex() {return (Index *)0;}
  virtual const Index *asIndex() const {return (const Index *)0;}
  virtual HashIndex *asHashIndex() {return (HashIndex *)0;}
  virtual const HashIndex *asHashIndex() const {return (const HashIndex *)0;}
  virtual BTreeIndex *asBTreeIndex() {return (BTreeIndex *)0;}
  virtual const BTreeIndex *asBTreeIndex() const {return (const BTreeIndex *)0;}
  virtual CollAttrImpl *asCollAttrImpl() {return (CollAttrImpl *)0;}
  virtual const CollAttrImpl *asCollAttrImpl() const {return (const CollAttrImpl *)0;}
  virtual UniqueConstraint *asUniqueConstraint() {return (UniqueConstraint *)0;}
  virtual const UniqueConstraint *asUniqueConstraint() const {return (const UniqueConstraint *)0;}
  virtual NotNullConstraint *asNotNullConstraint() {return (NotNullConstraint *)0;}
  virtual const NotNullConstraint *asNotNullConstraint() const {return (const NotNullConstraint *)0;}
  virtual CardinalityConstraint_Test *asCardinalityConstraint_Test() {return (CardinalityConstraint_Test *)0;}
  virtual const CardinalityConstraint_Test *asCardinalityConstraint_Test() const {return (const CardinalityConstraint_Test *)0;}

  eyedb::Status setName(const std::string &);
  eyedb::Status setName(unsigned int a0, char );
  std::string getName(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getName(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setAttrpath(const std::string &);
  eyedb::Status setAttrpath(unsigned int a0, char );
  std::string getAttrpath(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getAttrpath(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setClassOwner(eyedb::Class*);
  eyedb::Class*getClassOwner(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const eyedb::Class*getClassOwner(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid getClassOwnerOid(eyedb::Status * = 0) const;
  eyedb::Status setClassOwnerOid(const eyedb::Oid &);

  eyedb::Status setPropagate(eyedb::Bool , eyedb::Bool _check_value = eyedb::True);
  eyedb::Bool getPropagate(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~AttributeComponent() {garbageRealize();}
  // AttributeComponent User Part

    virtual Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    Status checkUnique(const char *, const char *);
    Status find(Database *db, const Class *cls,
  AttributeComponent *&);
    virtual AttributeComponent *xclone(Database *, const Class *);
    std::string makeAttrpath(const Class *cls);
    void userInitialize();
    void userCopy(const Object &);
    void userGarbage();
    virtual int getInd() const;
    

 protected:
  AttributeComponent(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : eyedb::Struct(_db, _dataspace) {}
  AttributeComponent(const eyedb::Struct *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}
  AttributeComponent(const AttributeComponent *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  AttributeComponent(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  AttributeComponent(const AttributeComponent *, eyedb::Bool = eyedb::False);
  AttributeComponent(const eyedb::Class *, eyedb::Data);
};

class AttributeComponentSet : public eyedb::Struct {

 public:
  AttributeComponentSet(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  AttributeComponentSet(const AttributeComponentSet& x);

  virtual eyedb::Object *clone() const {return new AttributeComponentSet(*this);};

  AttributeComponentSet& operator=(const AttributeComponentSet& x);

  virtual AttributeComponentSet *asAttributeComponentSet() {return this;}
  virtual const AttributeComponentSet *asAttributeComponentSet() const {return this;}

  eyedb::Status setAttrname(const std::string &);
  eyedb::Status setAttrname(unsigned int a0, char );
  std::string getAttrname(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getAttrname(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setCompsColl(eyedb::CollSet*);
  eyedb::CollSet*getCompsColl(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  unsigned int getCompsCount(eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const {const eyedb::Collection* _coll = getCompsColl(isnull, rs); return (!!_coll ? _coll->getCount() : 0);}
  const eyedb::CollSet*getCompsColl(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Status addToCompsColl(AttributeComponent*, eyedb::Bool noDup = eyedb::False, const eyedb::CollImpl * = 0);
  eyedb::Status rmvFromCompsColl(AttributeComponent*, eyedb::Bool checkFirst = eyedb::False);
  eyedb::Status addToCompsColl(const eyedb::Oid &, const eyedb::CollImpl * = 0);
  eyedb::Status rmvFromCompsColl(const eyedb::Oid &);

  eyedb::Status setClassOwner(eyedb::Class*);
  eyedb::Class*getClassOwner(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const eyedb::Class*getClassOwner(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid getClassOwnerOid(eyedb::Status * = 0) const;
  eyedb::Status setClassOwnerOid(const eyedb::Oid &);
  virtual ~AttributeComponentSet() {garbageRealize();}
  // AttributeComponentSet User Part

    void userInitialize();
    void userCopy(const Object &);
    void userGarbage();

    Status find(const char *, Index *&);
    Status find(const char *, NotNullConstraint *&);
    Status find(const char *, UniqueConstraint *&);
    Status find(const char *, CollAttrImpl *&);
    Status find(const char *, CardinalityConstraint_Test *&);
    Status getAttrComponents(const Class *, LinkedList &);
    Status hasIndex(bool &has_index, std::string &idx_str);

  private:
    struct Cache {
      unsigned int comp_count;
      unsigned int comp_alloc;
      struct Comp {
 char *attrpath;
 AttributeComponent *comp;
 Comp();
 ~Comp();
      } *comps;
      Cache();
      void add(AttributeComponent *);
      void getComponents(const char *, int, LinkedList &);
      AttributeComponent *find(const char *attrpath);
      ~Cache();
    };

    Status makeCache();
    void invalidateCache();

    Cache *index_cache, *notnull_cache, *unique_cache, *card_cache, *collimpl_cache;
    friend class Attribute;
    

 protected:
  AttributeComponentSet(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : eyedb::Struct(_db, _dataspace) {}
  AttributeComponentSet(const eyedb::Struct *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}
  AttributeComponentSet(const AttributeComponentSet *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  AttributeComponentSet(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  AttributeComponentSet(const AttributeComponentSet *, eyedb::Bool = eyedb::False);
  AttributeComponentSet(const eyedb::Class *, eyedb::Data);
};

class ClassComponent : public eyedb::Struct {

 public:
  ClassComponent(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  ClassComponent(const ClassComponent& x);

  virtual eyedb::Object *clone() const {return new ClassComponent(*this);};

  ClassComponent& operator=(const ClassComponent& x);

  virtual ClassComponent *asClassComponent() {return this;}
  virtual const ClassComponent *asClassComponent() const {return this;}
  virtual AgregatClassComponent *asAgregatClassComponent() {return (AgregatClassComponent *)0;}
  virtual const AgregatClassComponent *asAgregatClassComponent() const {return (const AgregatClassComponent *)0;}
  virtual ClassVariable *asClassVariable() {return (ClassVariable *)0;}
  virtual const ClassVariable *asClassVariable() const {return (const ClassVariable *)0;}
  virtual AgregatClassExecutable *asAgregatClassExecutable() {return (AgregatClassExecutable *)0;}
  virtual const AgregatClassExecutable *asAgregatClassExecutable() const {return (const AgregatClassExecutable *)0;}
  virtual Method *asMethod() {return (Method *)0;}
  virtual const Method *asMethod() const {return (const Method *)0;}
  virtual FEMethod *asFEMethod() {return (FEMethod *)0;}
  virtual const FEMethod *asFEMethod() const {return (const FEMethod *)0;}
  virtual FEMethod_C *asFEMethod_C() {return (FEMethod_C *)0;}
  virtual const FEMethod_C *asFEMethod_C() const {return (const FEMethod_C *)0;}
  virtual BEMethod *asBEMethod() {return (BEMethod *)0;}
  virtual const BEMethod *asBEMethod() const {return (const BEMethod *)0;}
  virtual BEMethod_C *asBEMethod_C() {return (BEMethod_C *)0;}
  virtual const BEMethod_C *asBEMethod_C() const {return (const BEMethod_C *)0;}
  virtual BEMethod_OQL *asBEMethod_OQL() {return (BEMethod_OQL *)0;}
  virtual const BEMethod_OQL *asBEMethod_OQL() const {return (const BEMethod_OQL *)0;}
  virtual Trigger *asTrigger() {return (Trigger *)0;}
  virtual const Trigger *asTrigger() const {return (const Trigger *)0;}
  virtual CardinalityConstraint *asCardinalityConstraint() {return (CardinalityConstraint *)0;}
  virtual const CardinalityConstraint *asCardinalityConstraint() const {return (const CardinalityConstraint *)0;}

  eyedb::Status setClassOwner(eyedb::Class*);
  eyedb::Class*getClassOwner(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const eyedb::Class*getClassOwner(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid getClassOwnerOid(eyedb::Status * = 0) const;
  eyedb::Status setClassOwnerOid(const eyedb::Oid &);

  eyedb::Status setName(const std::string &);
  eyedb::Status setName(unsigned int a0, char );
  std::string getName(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getName(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~ClassComponent() {garbageRealize();}
  // ClassComponent User Part

    virtual Status check(Class *) const;
    virtual Bool isInherit() const;
    virtual Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    virtual int getInd() const;
    virtual Status make(Class *);
    virtual Status realize(const RecMode* = NoRecurs);
    virtual Status remove(const RecMode* = NoRecurs);
    virtual Status realize_for_update();
    virtual Status remove_for_update();
    

 protected:
  ClassComponent(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : eyedb::Struct(_db, _dataspace) {}
  ClassComponent(const eyedb::Struct *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}
  ClassComponent(const ClassComponent *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  ClassComponent(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  ClassComponent(const ClassComponent *, eyedb::Bool = eyedb::False);
  ClassComponent(const eyedb::Class *, eyedb::Data);
};

class AgregatClassComponent : public ClassComponent {

 public:
  AgregatClassComponent(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  AgregatClassComponent(const AgregatClassComponent& x);

  virtual eyedb::Object *clone() const {return new AgregatClassComponent(*this);};

  AgregatClassComponent& operator=(const AgregatClassComponent& x);

  virtual AgregatClassComponent *asAgregatClassComponent() {return this;}
  virtual const AgregatClassComponent *asAgregatClassComponent() const {return this;}
  virtual AgregatClassExecutable *asAgregatClassExecutable() {return (AgregatClassExecutable *)0;}
  virtual const AgregatClassExecutable *asAgregatClassExecutable() const {return (const AgregatClassExecutable *)0;}
  virtual Method *asMethod() {return (Method *)0;}
  virtual const Method *asMethod() const {return (const Method *)0;}
  virtual FEMethod *asFEMethod() {return (FEMethod *)0;}
  virtual const FEMethod *asFEMethod() const {return (const FEMethod *)0;}
  virtual FEMethod_C *asFEMethod_C() {return (FEMethod_C *)0;}
  virtual const FEMethod_C *asFEMethod_C() const {return (const FEMethod_C *)0;}
  virtual BEMethod *asBEMethod() {return (BEMethod *)0;}
  virtual const BEMethod *asBEMethod() const {return (const BEMethod *)0;}
  virtual BEMethod_C *asBEMethod_C() {return (BEMethod_C *)0;}
  virtual const BEMethod_C *asBEMethod_C() const {return (const BEMethod_C *)0;}
  virtual BEMethod_OQL *asBEMethod_OQL() {return (BEMethod_OQL *)0;}
  virtual const BEMethod_OQL *asBEMethod_OQL() const {return (const BEMethod_OQL *)0;}
  virtual Trigger *asTrigger() {return (Trigger *)0;}
  virtual const Trigger *asTrigger() const {return (const Trigger *)0;}
  virtual CardinalityConstraint *asCardinalityConstraint() {return (CardinalityConstraint *)0;}
  virtual const CardinalityConstraint *asCardinalityConstraint() const {return (const CardinalityConstraint *)0;}
  virtual ~AgregatClassComponent() {garbageRealize();}

 protected:
  AgregatClassComponent(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : ClassComponent(_db, _dataspace, 1) {}
  AgregatClassComponent(const eyedb::Struct *x, eyedb::Bool share, int) : ClassComponent(x, share, 1) {}
  AgregatClassComponent(const AgregatClassComponent *x, eyedb::Bool share, int) : ClassComponent(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  AgregatClassComponent(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  AgregatClassComponent(const AgregatClassComponent *, eyedb::Bool = eyedb::False);
  AgregatClassComponent(const eyedb::Class *, eyedb::Data);
};

class ClassVariable : public ClassComponent {

 public:
  ClassVariable(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  ClassVariable(const ClassVariable& x);

  virtual eyedb::Object *clone() const {return new ClassVariable(*this);};

  ClassVariable& operator=(const ClassVariable& x);

  virtual ClassVariable *asClassVariable() {return this;}
  virtual const ClassVariable *asClassVariable() const {return this;}

  eyedb::Status setVname(const std::string &);
  eyedb::Status setVname(unsigned int a0, char );
  std::string getVname(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getVname(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setVal(eyedb::Object*);
  eyedb::Object*getVal(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const eyedb::Object*getVal(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid getValOid(eyedb::Status * = 0) const;
  eyedb::Status setValOid(const eyedb::Oid &);
  virtual ~ClassVariable() {garbageRealize();}
  // ClassVariable User Part

    Status check(Class *) const;
    Bool isInherit() const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    int getInd() const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *);
    

 protected:
  ClassVariable(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : ClassComponent(_db, _dataspace, 1) {}
  ClassVariable(const eyedb::Struct *x, eyedb::Bool share, int) : ClassComponent(x, share, 1) {}
  ClassVariable(const ClassVariable *x, eyedb::Bool share, int) : ClassComponent(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  ClassVariable(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  ClassVariable(const ClassVariable *, eyedb::Bool = eyedb::False);
  ClassVariable(const eyedb::Class *, eyedb::Data);
};

class Index : public AttributeComponent {

 public:
  Index(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Index(const Index& x);

  virtual eyedb::Object *clone() const {return new Index(*this);};

  Index& operator=(const Index& x);

  virtual Index *asIndex() {return this;}
  virtual const Index *asIndex() const {return this;}
  virtual HashIndex *asHashIndex() {return (HashIndex *)0;}
  virtual const HashIndex *asHashIndex() const {return (const HashIndex *)0;}
  virtual BTreeIndex *asBTreeIndex() {return (BTreeIndex *)0;}
  virtual const BTreeIndex *asBTreeIndex() const {return (const BTreeIndex *)0;}

  eyedb::Status setIdxOid(eyedb::Oid );
  eyedb::Oid getIdxOid(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setDspid(eyedblib::int16 );
  eyedblib::int16 getDspid(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setIsString(eyedb::Bool , eyedb::Bool _check_value = eyedb::True);
  eyedb::Bool getIsString(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setImplHints(unsigned int a0, eyedblib::int32 );
  eyedb::Status setImplHintsCount(unsigned int a0);
  eyedblib::int32 getImplHints(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  unsigned int getImplHintsCount(eyedb::Status * = 0) const;
  virtual ~Index() {garbageRealize();}
  // Index User Part

    Index(Database *, const char *, const char *);
    virtual Status realize(const RecMode* = NoRecurs);
    virtual Status remove(const RecMode* = NoRecurs);
    virtual Status s_trace(FILE *, Bool, unsigned int flags = 0) const;
    Idx *idx;
    Status makeDataspace(Database *db, const Dataspace *&) const;

    void userInitialize();
    void userCopy(const Object &);
    void userGarbage();
    Status move(const Dataspace *) const;
    short get_dspid() const;
    Bool compareHints(Index *idx);
    int getInd() const;


    Status getCount(unsigned int &count);
    Status getStats(std::string &, Bool dspImpl = True,
      Bool full = False, const char *indent = "");
    Status getStats(IndexStats *&stats);
    Status simulate(const IndexImpl &, std::string &,
      Bool dspImpl = True, Bool full = False,
      const char *indent = "");
    Status simulate(const IndexImpl &, IndexStats *&stats);

    Status reimplement(const IndexImpl &, Index *&);
    virtual Status setImplementation(const IndexImpl *) {return Success;}
    virtual Status getImplementation(IndexImpl *&, Bool remote = False) const {return 0;}
    Status getDefaultDataspace(const Dataspace *&) const;
    Status setDefaultDataspace(const Dataspace *);
    Status getObjectLocations(ObjectLocationArray &);
    virtual Status report(eyedbsm::DbHandle *sedbh, const Oid &idxoid);
    

 protected:
  Index(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : AttributeComponent(_db, _dataspace, 1) {}
  Index(const eyedb::Struct *x, eyedb::Bool share, int) : AttributeComponent(x, share, 1) {}
  Index(const Index *x, eyedb::Bool share, int) : AttributeComponent(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Index(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Index(const Index *, eyedb::Bool = eyedb::False);
  Index(const eyedb::Class *, eyedb::Data);
};

class HashIndex : public Index {

 public:
  HashIndex(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  HashIndex(const HashIndex& x);

  virtual eyedb::Object *clone() const {return new HashIndex(*this);};

  HashIndex& operator=(const HashIndex& x);

  virtual HashIndex *asHashIndex() {return this;}
  virtual const HashIndex *asHashIndex() const {return this;}

  eyedb::Status setHashMethod(BEMethod_C*);
  BEMethod_C*getHashMethod(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const BEMethod_C*getHashMethod(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid getHashMethodOid(eyedb::Status * = 0) const;
  eyedb::Status setHashMethodOid(const eyedb::Oid &);

  eyedb::Status setKeyCount(eyedblib::int32 );
  eyedblib::int32 getKeyCount(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~HashIndex() {garbageRealize();}
  // HashIndex User Part

    HashIndex(Database *, Class *, const char *attrpath,
       Bool propagate, Bool is_string,
       const Dataspace * = 0, int key_count = 0,
       BEMethod_C * = 0,
       const int *impl_hints = 0, int impl_hints_cnt = 0);
    HashIndex(Database *, Class *, const char *attrpath,
       Bool propagate, Bool is_string,
       const IndexImpl *idximpl);
    static Status make(Database *, Class *, const char *attrpath,
         Bool propagate, Bool is_string,
         const char *hints, HashIndex *&);
    Status setImplementation(const IndexImpl *);
    Status getImplementation(IndexImpl *&, Bool remote = False) const;
    virtual AttributeComponent *xclone(Database *, const Class *);
    Status check(Class *) const;
    Status make(Class *);
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    Status s_trace(FILE *, Bool, unsigned int flags = 0) const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    Bool compareHashMethod(HashIndex *idx);
    const char *genName() const;
    virtual Status report(eyedbsm::DbHandle *sedbh, const Oid &idxoid);
    

 protected:
  HashIndex(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Index(_db, _dataspace, 1) {}
  HashIndex(const eyedb::Struct *x, eyedb::Bool share, int) : Index(x, share, 1) {}
  HashIndex(const HashIndex *x, eyedb::Bool share, int) : Index(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  HashIndex(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  HashIndex(const HashIndex *, eyedb::Bool = eyedb::False);
  HashIndex(const eyedb::Class *, eyedb::Data);
};

class BTreeIndex : public Index {

 public:
  BTreeIndex(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  BTreeIndex(const BTreeIndex& x);

  virtual eyedb::Object *clone() const {return new BTreeIndex(*this);};

  BTreeIndex& operator=(const BTreeIndex& x);

  virtual BTreeIndex *asBTreeIndex() {return this;}
  virtual const BTreeIndex *asBTreeIndex() const {return this;}

  eyedb::Status setDegree(eyedblib::int32 );
  eyedblib::int32 getDegree(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~BTreeIndex() {garbageRealize();}
  // BTreeIndex User Part

    BTreeIndex(Database *, Class *,
        const char *attrpath, Bool propagate, Bool is_string,
        const Dataspace * = 0, int degree = 0,
        const int *impl_hints = 0, int impl_hints_cnt = 0);
    BTreeIndex(Database *, Class *, const char *pathattr,
        Bool propagate, Bool is_string,
        const IndexImpl *idximpl);
    static Status make(Database *, Class *, const char *attrpath,
         Bool propagate, Bool is_string,
         const char *hints, BTreeIndex *&);
    Status setImplementation(const IndexImpl *);
    Status getImplementation(IndexImpl *&, Bool remote = False) const;
    virtual AttributeComponent *xclone(Database *, const Class *);
    Status check(Class *) const;
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    Status s_trace(FILE *, Bool, unsigned int flags = 0) const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    const char *genName() const;
    virtual Status report(eyedbsm::DbHandle *sedbh, const Oid &idxoid);
    

 protected:
  BTreeIndex(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Index(_db, _dataspace, 1) {}
  BTreeIndex(const eyedb::Struct *x, eyedb::Bool share, int) : Index(x, share, 1) {}
  BTreeIndex(const BTreeIndex *x, eyedb::Bool share, int) : Index(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  BTreeIndex(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  BTreeIndex(const BTreeIndex *, eyedb::Bool = eyedb::False);
  BTreeIndex(const eyedb::Class *, eyedb::Data);
};

class CollAttrImpl : public AttributeComponent {

 public:
  CollAttrImpl(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  CollAttrImpl(const CollAttrImpl& x);

  virtual eyedb::Object *clone() const {return new CollAttrImpl(*this);};

  CollAttrImpl& operator=(const CollAttrImpl& x);

  virtual CollAttrImpl *asCollAttrImpl() {return this;}
  virtual const CollAttrImpl *asCollAttrImpl() const {return this;}

  eyedb::Status setImplType(eyedblib::int32 );
  eyedblib::int32 getImplType(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setDspid(eyedblib::int16 );
  eyedblib::int16 getDspid(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setKeyCountOrDegree(eyedblib::int32 );
  eyedblib::int32 getKeyCountOrDegree(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setHashMethod(BEMethod_C*);
  BEMethod_C*getHashMethod(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const BEMethod_C*getHashMethod(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid getHashMethodOid(eyedb::Status * = 0) const;
  eyedb::Status setHashMethodOid(const eyedb::Oid &);

  eyedb::Status setImplHints(unsigned int a0, eyedblib::int32 );
  eyedb::Status setImplHintsCount(unsigned int a0);
  eyedblib::int32 getImplHints(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  unsigned int getImplHintsCount(eyedb::Status * = 0) const;
  virtual ~CollAttrImpl() {garbageRealize();}
  // CollAttrImpl User Part


    CollAttrImpl(Database *, Class *, const char *attrpath,
   Bool propagate, const Dataspace * = 0,
   CollImpl::Type impl_type = CollImpl::HashIndex,
   int key_count_or_degree = 0,
   BEMethod_C * = 0,
   const int *impl_hints = 0, int impl_hints_cnt = 0);
    CollAttrImpl(Database *, Class *, const char *attrpath,
   Bool propagate, const IndexImpl *idximpl);

    Status makeDataspace(Database *db, const Dataspace *&) const;
    static Status make(Database *, Class *, const char *attrpath,
         Bool propagate,
         CollImpl::Type impl_type, const char *hints,
         CollAttrImpl *&);
    Status getImplementation(Database *, const CollImpl *&);
    virtual AttributeComponent *xclone(Database *, const Class *);
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    Status s_trace(FILE *, Bool, unsigned int flags = 0) const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    const char *genName() const;
    int getInd() const;

    void userInitialize();
    void userCopy(const Object &);
    void userGarbage();

    const Dataspace *dsp;
    CollImpl *collimpl;
    

 protected:
  CollAttrImpl(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : AttributeComponent(_db, _dataspace, 1) {}
  CollAttrImpl(const eyedb::Struct *x, eyedb::Bool share, int) : AttributeComponent(x, share, 1) {}
  CollAttrImpl(const CollAttrImpl *x, eyedb::Bool share, int) : AttributeComponent(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  CollAttrImpl(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  CollAttrImpl(const CollAttrImpl *, eyedb::Bool = eyedb::False);
  CollAttrImpl(const eyedb::Class *, eyedb::Data);
};

class ArgType : public eyedb::Struct {

 public:
  ArgType(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  ArgType(const ArgType& x);

  virtual eyedb::Object *clone() const {return new ArgType(*this);};

  ArgType& operator=(const ArgType& x);

  virtual ArgType *asArgType() {return this;}
  virtual const ArgType *asArgType() const {return this;}

  eyedb::Status setType(ArgType_Type , eyedb::Bool _check_value = eyedb::True);
  ArgType_Type getType(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setClname(const std::string &);
  eyedb::Status setClname(unsigned int a0, char );
  std::string getClname(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getClname(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~ArgType() {garbageRealize();}
  // ArgType User Part

    Bool operator==(const ArgType &) const;

    Bool operator!=(const ArgType &) const;
    static ArgType *make(Schema *m, const char *s);
    static int getBasicType(const char *s);
    void declare(FILE *, Schema *, const char *name);
    void init(FILE *, Schema *, const char *prefix, const char *name,
       const char *indent);
    void ret(FILE *, Schema *, const char *prefix, const char *name);
    const char *getCType(Schema *) const;
    void getCPrefix(FILE *fd, Schema *, const char *prefix,
      const char *name, Bool fullcast) const;
    

 protected:
  ArgType(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : eyedb::Struct(_db, _dataspace) {}
  ArgType(const eyedb::Struct *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}
  ArgType(const ArgType *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  ArgType(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  ArgType(const ArgType *, eyedb::Bool = eyedb::False);
  ArgType(const eyedb::Class *, eyedb::Data);
};

class Signature : public eyedb::Struct {

 public:
  Signature(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Signature(const Signature& x);

  virtual eyedb::Object *clone() const {return new Signature(*this);};

  Signature& operator=(const Signature& x);

  virtual Signature *asSignature() {return this;}
  virtual const Signature *asSignature() const {return this;}

  eyedb::Status setRettype(ArgType*);
  ArgType*getRettype(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const ArgType*getRettype(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;

  eyedb::Status setNargs(eyedblib::int32 );
  eyedblib::int32 getNargs(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setTypes(unsigned int a0, ArgType*);
  eyedb::Status setTypesCount(unsigned int a0);
  ArgType*getTypes(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const ArgType*getTypes(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  unsigned int getTypesCount(eyedb::Status * = 0) const;
  virtual ~Signature() {garbageRealize();}
  // Signature User Part

    Bool operator ==(const Signature &) const;
    Bool operator !=(const Signature &) const;
    const char *getArg(int i);
    static const char *getPrefix(const char *prefix, int i);
    static Bool isVoid(const ArgType *type);
    void listArgs(FILE *, Schema *);
    void declArgs(FILE *, Schema *);
    void initArgs(FILE *, Schema *, const char *prefix, const char *preret,
    const char *indent);
    void setArgs(FILE *, Schema *, int type, const char *prefix,
   const char *preret, const char *indent);
    void retArgs(FILE *, Schema *, const char *prefix, const char *preret,
   const char *indent);
    

 protected:
  Signature(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : eyedb::Struct(_db, _dataspace) {}
  Signature(const eyedb::Struct *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}
  Signature(const Signature *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Signature(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Signature(const Signature *, eyedb::Bool = eyedb::False);
  Signature(const eyedb::Class *, eyedb::Data);
};

class Executable : public eyedb::Struct {

 public:
  Executable(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Executable(const Executable& x);

  virtual eyedb::Object *clone() const {return new Executable(*this);};

  Executable& operator=(const Executable& x);

  virtual Executable *asExecutable() {return this;}
  virtual const Executable *asExecutable() const {return this;}

  eyedb::Status setExname(const std::string &);
  eyedb::Status setExname(unsigned int a0, char );
  std::string getExname(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getExname(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setLang(ExecutableLang , eyedb::Bool _check_value = eyedb::True);
  ExecutableLang getLang(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setLoc(ExecutableLocalisation , eyedb::Bool _check_value = eyedb::True);
  ExecutableLocalisation getLoc(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setSign(Signature*);
  Signature*getSign(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Signature*getSign(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;

  eyedb::Status setIntname(const std::string &);
  eyedb::Status setIntname(unsigned int a0, char );
  std::string getIntname(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getIntname(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setExtrefBody(const std::string &);
  eyedb::Status setExtrefBody(unsigned int a0, char );
  std::string getExtrefBody(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getExtrefBody(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~Executable() {garbageRealize();}
  // Executable User Part

    void initExec(const char *exname,
    ExecutableLang lang,
    Bool isSystem,
    ExecutableLocalisation loc,
    Signature *sign, Class * = 0);
    static const char *makeInternalName(const char *exname,
     const Signature *sign,
     Bool isClassMethod,
     const char *clname = 0);
    const char *_getPrototype(const Class *, Bool scope) const;
    static const char *makeExtRef(const char *extref);
    static const char *getSOTag();
    static const char *getSOFile(const char *extref);
    static void *_dlopen(const char *extref);
    int isStaticExec() const;
    void *dl;
    void userInitialize();
    void userCopy(const Object &);
    virtual Status execCheck();
    Status checkRealize(const char *, const char *, void **);
    static Status checkRealize(const char *extref, const char *intname,
          void **pdl, void **pcsym);
    

 protected:
  Executable(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : eyedb::Struct(_db, _dataspace) {}
  Executable(const eyedb::Struct *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}
  Executable(const Executable *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Executable(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Executable(const Executable *, eyedb::Bool = eyedb::False);
  Executable(const eyedb::Class *, eyedb::Data);
};

class AgregatClassExecutable : public AgregatClassComponent {

 public:
  AgregatClassExecutable(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  AgregatClassExecutable(const AgregatClassExecutable& x);

  virtual eyedb::Object *clone() const {return new AgregatClassExecutable(*this);};

  AgregatClassExecutable& operator=(const AgregatClassExecutable& x);

  virtual AgregatClassExecutable *asAgregatClassExecutable() {return this;}
  virtual const AgregatClassExecutable *asAgregatClassExecutable() const {return this;}
  virtual Method *asMethod() {return (Method *)0;}
  virtual const Method *asMethod() const {return (const Method *)0;}
  virtual FEMethod *asFEMethod() {return (FEMethod *)0;}
  virtual const FEMethod *asFEMethod() const {return (const FEMethod *)0;}
  virtual FEMethod_C *asFEMethod_C() {return (FEMethod_C *)0;}
  virtual const FEMethod_C *asFEMethod_C() const {return (const FEMethod_C *)0;}
  virtual BEMethod *asBEMethod() {return (BEMethod *)0;}
  virtual const BEMethod *asBEMethod() const {return (const BEMethod *)0;}
  virtual BEMethod_C *asBEMethod_C() {return (BEMethod_C *)0;}
  virtual const BEMethod_C *asBEMethod_C() const {return (const BEMethod_C *)0;}
  virtual BEMethod_OQL *asBEMethod_OQL() {return (BEMethod_OQL *)0;}
  virtual const BEMethod_OQL *asBEMethod_OQL() const {return (const BEMethod_OQL *)0;}
  virtual Trigger *asTrigger() {return (Trigger *)0;}
  virtual const Trigger *asTrigger() const {return (const Trigger *)0;}

  eyedb::Status setEx(Executable*);
  Executable*getEx(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Executable*getEx(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  virtual ~AgregatClassExecutable() {garbageRealize();}

 protected:
  AgregatClassExecutable(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : AgregatClassComponent(_db, _dataspace, 1) {}
  AgregatClassExecutable(const eyedb::Struct *x, eyedb::Bool share, int) : AgregatClassComponent(x, share, 1) {}
  AgregatClassExecutable(const AgregatClassExecutable *x, eyedb::Bool share, int) : AgregatClassComponent(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  AgregatClassExecutable(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  AgregatClassExecutable(const AgregatClassExecutable *, eyedb::Bool = eyedb::False);
  AgregatClassExecutable(const eyedb::Class *, eyedb::Data);
};

class Method : public AgregatClassExecutable {

 public:
  Method(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Method(const Method& x);

  virtual eyedb::Object *clone() const {return new Method(*this);};

  Method& operator=(const Method& x);

  virtual Method *asMethod() {return this;}
  virtual const Method *asMethod() const {return this;}
  virtual FEMethod *asFEMethod() {return (FEMethod *)0;}
  virtual const FEMethod *asFEMethod() const {return (const FEMethod *)0;}
  virtual FEMethod_C *asFEMethod_C() {return (FEMethod_C *)0;}
  virtual const FEMethod_C *asFEMethod_C() const {return (const FEMethod_C *)0;}
  virtual BEMethod *asBEMethod() {return (BEMethod *)0;}
  virtual const BEMethod *asBEMethod() const {return (const BEMethod *)0;}
  virtual BEMethod_C *asBEMethod_C() {return (BEMethod_C *)0;}
  virtual const BEMethod_C *asBEMethod_C() const {return (const BEMethod_C *)0;}
  virtual BEMethod_OQL *asBEMethod_OQL() {return (BEMethod_OQL *)0;}
  virtual const BEMethod_OQL *asBEMethod_OQL() const {return (const BEMethod_OQL *)0;}
  virtual ~Method() {garbageRealize();}
  // Method User Part

    virtual Status applyTo(Database *, Object *, ArgArray &,
      Argument &retarg, Bool checkArgs);
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);

    static Status get(Database *, Class *, const char *name,
        const Signature *, Bool isClassMethod,
        Method * &);

    static Status getSignature(Database *, Class *,
          const char *sign_str, Signature *&,
          char *&fname);

    static Status get(Database *, Class *,
        const char *sign_str, Bool isClassMethod,
        Method * &);

    const char *getPrototype(Bool scope = True) const;

    Status check(Class *) const;
    Bool isInherit() const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    int getInd() const;
    virtual Status execCheck();
    

 protected:
  Method(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : AgregatClassExecutable(_db, _dataspace, 1) {}
  Method(const eyedb::Struct *x, eyedb::Bool share, int) : AgregatClassExecutable(x, share, 1) {}
  Method(const Method *x, eyedb::Bool share, int) : AgregatClassExecutable(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Method(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Method(const Method *, eyedb::Bool = eyedb::False);
  Method(const eyedb::Class *, eyedb::Data);
};

class FEMethod : public Method {

 public:
  FEMethod(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  FEMethod(const FEMethod& x);

  virtual eyedb::Object *clone() const {return new FEMethod(*this);};

  FEMethod& operator=(const FEMethod& x);

  virtual FEMethod *asFEMethod() {return this;}
  virtual const FEMethod *asFEMethod() const {return this;}
  virtual FEMethod_C *asFEMethod_C() {return (FEMethod_C *)0;}
  virtual const FEMethod_C *asFEMethod_C() const {return (const FEMethod_C *)0;}
  virtual ~FEMethod() {garbageRealize();}

 protected:
  FEMethod(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Method(_db, _dataspace, 1) {}
  FEMethod(const eyedb::Struct *x, eyedb::Bool share, int) : Method(x, share, 1) {}
  FEMethod(const FEMethod *x, eyedb::Bool share, int) : Method(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  FEMethod(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  FEMethod(const FEMethod *, eyedb::Bool = eyedb::False);
  FEMethod(const eyedb::Class *, eyedb::Data);
};

class FEMethod_C : public FEMethod {

 public:
  FEMethod_C(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  FEMethod_C(const FEMethod_C& x);

  virtual eyedb::Object *clone() const {return new FEMethod_C(*this);};

  FEMethod_C& operator=(const FEMethod_C& x);

  virtual FEMethod_C *asFEMethod_C() {return this;}
  virtual const FEMethod_C *asFEMethod_C() const {return this;}
  virtual ~FEMethod_C() {garbageRealize();}
  // FEMethod_C User Part

    Status (*csym)(Database *, FEMethod_C *, Object *,
     ArgArray &array, Argument &retarg);
    FEMethod_C(Database *, Class *, const char *name,
        Signature *, Bool isClassMethod,
        Bool isSystem, const char *extref);
    Status execCheck();
    Status applyTo(Database *, Object *, ArgArray &, Argument &retarg, Bool checkArgs);
    void userInitialize();
    void userCopy(const Object &);
    

 protected:
  FEMethod_C(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : FEMethod(_db, _dataspace, 1) {}
  FEMethod_C(const eyedb::Struct *x, eyedb::Bool share, int) : FEMethod(x, share, 1) {}
  FEMethod_C(const FEMethod_C *x, eyedb::Bool share, int) : FEMethod(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  FEMethod_C(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  FEMethod_C(const FEMethod_C *, eyedb::Bool = eyedb::False);
  FEMethod_C(const eyedb::Class *, eyedb::Data);
};

class BEMethod : public Method {

 public:
  BEMethod(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  BEMethod(const BEMethod& x);

  virtual eyedb::Object *clone() const {return new BEMethod(*this);};

  BEMethod& operator=(const BEMethod& x);

  virtual BEMethod *asBEMethod() {return this;}
  virtual const BEMethod *asBEMethod() const {return this;}
  virtual BEMethod_C *asBEMethod_C() {return (BEMethod_C *)0;}
  virtual const BEMethod_C *asBEMethod_C() const {return (const BEMethod_C *)0;}
  virtual BEMethod_OQL *asBEMethod_OQL() {return (BEMethod_OQL *)0;}
  virtual const BEMethod_OQL *asBEMethod_OQL() const {return (const BEMethod_OQL *)0;}
  virtual ~BEMethod() {garbageRealize();}

 protected:
  BEMethod(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Method(_db, _dataspace, 1) {}
  BEMethod(const eyedb::Struct *x, eyedb::Bool share, int) : Method(x, share, 1) {}
  BEMethod(const BEMethod *x, eyedb::Bool share, int) : Method(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  BEMethod(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  BEMethod(const BEMethod *, eyedb::Bool = eyedb::False);
  BEMethod(const eyedb::Class *, eyedb::Data);
};

class BEMethod_C : public BEMethod {

 public:
  BEMethod_C(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  BEMethod_C(const BEMethod_C& x);

  virtual eyedb::Object *clone() const {return new BEMethod_C(*this);};

  BEMethod_C& operator=(const BEMethod_C& x);

  virtual BEMethod_C *asBEMethod_C() {return this;}
  virtual const BEMethod_C *asBEMethod_C() const {return this;}
  virtual ~BEMethod_C() {garbageRealize();}
  // BEMethod_C User Part

    Status (*csym)(Database *, BEMethod *, Object *,
     ArgArray &array, Argument &retarg);
    BEMethod_C(Database *, Class *, const char *name,
        Signature *, Bool isClassMethod,
        Bool isSystem, const char *extref);
    Status execCheck();
    Status applyTo(Database *, Object *, ArgArray &, Argument &retarg, Bool checkArgs);
    

 protected:
  BEMethod_C(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : BEMethod(_db, _dataspace, 1) {}
  BEMethod_C(const eyedb::Struct *x, eyedb::Bool share, int) : BEMethod(x, share, 1) {}
  BEMethod_C(const BEMethod_C *x, eyedb::Bool share, int) : BEMethod(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  BEMethod_C(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  BEMethod_C(const BEMethod_C *, eyedb::Bool = eyedb::False);
  BEMethod_C(const eyedb::Class *, eyedb::Data);
};

class BEMethod_OQL : public BEMethod {

 public:
  BEMethod_OQL(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  BEMethod_OQL(const BEMethod_OQL& x);

  virtual eyedb::Object *clone() const {return new BEMethod_OQL(*this);};

  BEMethod_OQL& operator=(const BEMethod_OQL& x);

  virtual BEMethod_OQL *asBEMethod_OQL() {return this;}
  virtual const BEMethod_OQL *asBEMethod_OQL() const {return this;}
  virtual ~BEMethod_OQL() {garbageRealize();}
  // BEMethod_OQL User Part

    BEMethod_OQL(Database *, Class *, const char *name,
   Signature *, Bool isClassMethod,
   Bool isSystem, const char *body);

    Status execCheck();
    Status setBody(const char *);
    Status applyTo(Database *, Object *, ArgArray &,
     Argument &retarg, Bool checkArgs);

    static std::string makeExtrefBody(const Class *cls, const char *oql,
          const char *fname,
          char *typnames[],
          char *varnames[],
          unsigned int param_cnt,
          std::string &oqlConstruct);
    Status runtimeInit();

    Bool isRTInitialized;
    char **varnames;
    int param_cnt;
    char *funcname;
    char *body;
    char *fullBody;
    char *tmpbuf;
    void *entry;

    void userInitialize();
    void userGarbage();
    void userCopy(const Object &);
    

 protected:
  BEMethod_OQL(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : BEMethod(_db, _dataspace, 1) {}
  BEMethod_OQL(const eyedb::Struct *x, eyedb::Bool share, int) : BEMethod(x, share, 1) {}
  BEMethod_OQL(const BEMethod_OQL *x, eyedb::Bool share, int) : BEMethod(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  BEMethod_OQL(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  BEMethod_OQL(const BEMethod_OQL *, eyedb::Bool = eyedb::False);
  BEMethod_OQL(const eyedb::Class *, eyedb::Data);
};

class Trigger : public AgregatClassExecutable {

 public:
  Trigger(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Trigger(const Trigger& x);

  virtual eyedb::Object *clone() const {return new Trigger(*this);};

  Trigger& operator=(const Trigger& x);

  virtual Trigger *asTrigger() {return this;}
  virtual const Trigger *asTrigger() const {return this;}

  eyedb::Status setType(TriggerType , eyedb::Bool _check_value = eyedb::True);
  TriggerType getType(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setLight(eyedblib::int32 );
  eyedblib::int32 getLight(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setSuffix(const std::string &);
  eyedb::Status setSuffix(unsigned int a0, char );
  std::string getSuffix(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getSuffix(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~Trigger() {garbageRealize();}
  // Trigger User Part

    Trigger(Database *, Class *, TriggerType,
     ExecutableLang, Bool isSystem, const char *suffix,
     Bool light, const char *extref);
    Status (*csym)(TriggerType, Database *, const Oid &,
     Object *);
    Status apply(const Oid &, Object *);
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    const char *getPrototype(Bool scope = True) const;
    const char *getCSym() const;
    static const char *getStrTriggerType(TriggerType);
    Bool isInherit() const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    int getInd() const;

    static std::string makeExtrefBody(const Class *cls, const char *oql,
          const char *fname,
          std::string &oqlConstruct);
    Status runtimeInit();

    Bool isRTInitialized;
    char *funcname;
    char *body;
    char *fullBody;
    char *tmpbuf;
    void *entry;

    void userInitialize();
    void userGarbage();
    void userCopy(const Object &);
    

 protected:
  Trigger(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : AgregatClassExecutable(_db, _dataspace, 1) {}
  Trigger(const eyedb::Struct *x, eyedb::Bool share, int) : AgregatClassExecutable(x, share, 1) {}
  Trigger(const Trigger *x, eyedb::Bool share, int) : AgregatClassExecutable(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Trigger(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Trigger(const Trigger *, eyedb::Bool = eyedb::False);
  Trigger(const eyedb::Class *, eyedb::Data);
};

class UniqueConstraint : public AttributeComponent {

 public:
  UniqueConstraint(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  UniqueConstraint(const UniqueConstraint& x);

  virtual eyedb::Object *clone() const {return new UniqueConstraint(*this);};

  UniqueConstraint& operator=(const UniqueConstraint& x);

  virtual UniqueConstraint *asUniqueConstraint() {return this;}
  virtual const UniqueConstraint *asUniqueConstraint() const {return this;}
  virtual ~UniqueConstraint() {garbageRealize();}
  // UniqueConstraint User Part

    UniqueConstraint(Database *, Class *, const char *attrpath,
       Bool propagate);
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    virtual AttributeComponent *xclone(Database *, const Class *);
    const char *genName() const;
    int getInd() const;
    

 protected:
  UniqueConstraint(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : AttributeComponent(_db, _dataspace, 1) {}
  UniqueConstraint(const eyedb::Struct *x, eyedb::Bool share, int) : AttributeComponent(x, share, 1) {}
  UniqueConstraint(const UniqueConstraint *x, eyedb::Bool share, int) : AttributeComponent(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  UniqueConstraint(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  UniqueConstraint(const UniqueConstraint *, eyedb::Bool = eyedb::False);
  UniqueConstraint(const eyedb::Class *, eyedb::Data);
};

class NotNullConstraint : public AttributeComponent {

 public:
  NotNullConstraint(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  NotNullConstraint(const NotNullConstraint& x);

  virtual eyedb::Object *clone() const {return new NotNullConstraint(*this);};

  NotNullConstraint& operator=(const NotNullConstraint& x);

  virtual NotNullConstraint *asNotNullConstraint() {return this;}
  virtual const NotNullConstraint *asNotNullConstraint() const {return this;}
  virtual ~NotNullConstraint() {garbageRealize();}
  // NotNullConstraint User Part

    NotNullConstraint(Database *, Class *, const char *attrpath,
        Bool propagate);
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    virtual AttributeComponent *xclone(Database *, const Class *);
    const char *genName() const;
    int getInd() const;
    

 protected:
  NotNullConstraint(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : AttributeComponent(_db, _dataspace, 1) {}
  NotNullConstraint(const eyedb::Struct *x, eyedb::Bool share, int) : AttributeComponent(x, share, 1) {}
  NotNullConstraint(const NotNullConstraint *x, eyedb::Bool share, int) : AttributeComponent(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  NotNullConstraint(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  NotNullConstraint(const NotNullConstraint *, eyedb::Bool = eyedb::False);
  NotNullConstraint(const eyedb::Class *, eyedb::Data);
};

class CardinalityDescription : public eyedb::Struct {

 public:
  CardinalityDescription(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  CardinalityDescription(const CardinalityDescription& x);

  virtual eyedb::Object *clone() const {return new CardinalityDescription(*this);};

  CardinalityDescription& operator=(const CardinalityDescription& x);

  virtual CardinalityDescription *asCardinalityDescription() {return this;}
  virtual const CardinalityDescription *asCardinalityDescription() const {return this;}

  eyedb::Status setBottom(eyedblib::int32 );
  eyedblib::int32 getBottom(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setBottomExcl(eyedblib::int32 );
  eyedblib::int32 getBottomExcl(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setTop(eyedblib::int32 );
  eyedblib::int32 getTop(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setTopExcl(eyedblib::int32 );
  eyedblib::int32 getTopExcl(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~CardinalityDescription() {garbageRealize();}
  // CardinalityDescription User Part

    const char *getString(Bool = True) const;
    Bool compare(CardinalityDescription *);
    

 protected:
  CardinalityDescription(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : eyedb::Struct(_db, _dataspace) {}
  CardinalityDescription(const eyedb::Struct *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}
  CardinalityDescription(const CardinalityDescription *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  CardinalityDescription(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  CardinalityDescription(const CardinalityDescription *, eyedb::Bool = eyedb::False);
  CardinalityDescription(const eyedb::Class *, eyedb::Data);
};

class CardinalityConstraint : public AgregatClassComponent {

 public:
  CardinalityConstraint(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  CardinalityConstraint(const CardinalityConstraint& x);

  virtual eyedb::Object *clone() const {return new CardinalityConstraint(*this);};

  CardinalityConstraint& operator=(const CardinalityConstraint& x);

  virtual CardinalityConstraint *asCardinalityConstraint() {return this;}
  virtual const CardinalityConstraint *asCardinalityConstraint() const {return this;}

  eyedb::Status setAttrname(const std::string &);
  eyedb::Status setAttrname(unsigned int a0, char );
  std::string getAttrname(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getAttrname(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setCardDesc(CardinalityDescription*);
  CardinalityDescription*getCardDesc(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const CardinalityDescription*getCardDesc(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  virtual ~CardinalityConstraint() {garbageRealize();}
  // CardinalityConstraint User Part

    CardinalityConstraint(Database *, Class *,
     const char *attrname, int, int, int, int);
    Status check(Class *) const;
    const char *genName() const;
    Bool isInherit() const;
    Status make(Class *);
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    int getInd() const;
    static int maxint;
    

 protected:
  CardinalityConstraint(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : AgregatClassComponent(_db, _dataspace, 1) {}
  CardinalityConstraint(const eyedb::Struct *x, eyedb::Bool share, int) : AgregatClassComponent(x, share, 1) {}
  CardinalityConstraint(const CardinalityConstraint *x, eyedb::Bool share, int) : AgregatClassComponent(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  CardinalityConstraint(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  CardinalityConstraint(const CardinalityConstraint *, eyedb::Bool = eyedb::False);
  CardinalityConstraint(const eyedb::Class *, eyedb::Data);
};

class CardinalityConstraint_Test : public AttributeComponent {

 public:
  CardinalityConstraint_Test(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  CardinalityConstraint_Test(const CardinalityConstraint_Test& x);

  virtual eyedb::Object *clone() const {return new CardinalityConstraint_Test(*this);};

  CardinalityConstraint_Test& operator=(const CardinalityConstraint_Test& x);

  virtual CardinalityConstraint_Test *asCardinalityConstraint_Test() {return this;}
  virtual const CardinalityConstraint_Test *asCardinalityConstraint_Test() const {return this;}

  eyedb::Status setCardDesc(CardinalityDescription*);
  CardinalityDescription*getCardDesc(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const CardinalityDescription*getCardDesc(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  virtual ~CardinalityConstraint_Test() {garbageRealize();}
  // CardinalityConstraint_Test User Part

    CardinalityConstraint_Test(Database *, Class *,
          const char *attrpath,
          int, int, int, int);
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    const char *genName() const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    static int maxint;
    int getInd() const;
    

 protected:
  CardinalityConstraint_Test(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : AttributeComponent(_db, _dataspace, 1) {}
  CardinalityConstraint_Test(const eyedb::Struct *x, eyedb::Bool share, int) : AttributeComponent(x, share, 1) {}
  CardinalityConstraint_Test(const CardinalityConstraint_Test *x, eyedb::Bool share, int) : AttributeComponent(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  CardinalityConstraint_Test(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  CardinalityConstraint_Test(const CardinalityConstraint_Test *, eyedb::Bool = eyedb::False);
  CardinalityConstraint_Test(const eyedb::Class *, eyedb::Data);
};

class ProtectionUser : public eyedb::Struct {

 public:
  ProtectionUser(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  ProtectionUser(const ProtectionUser& x);

  virtual eyedb::Object *clone() const {return new ProtectionUser(*this);};

  ProtectionUser& operator=(const ProtectionUser& x);

  virtual ProtectionUser *asProtectionUser() {return this;}
  virtual const ProtectionUser *asProtectionUser() const {return this;}

  eyedb::Status setUser(eyedb::Object*);
  eyedb::Object*getUser(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const eyedb::Object*getUser(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid getUserOid(eyedb::Status * = 0) const;
  eyedb::Status setUserOid(const eyedb::Oid &);

  eyedb::Status setMode(ProtectionMode , eyedb::Bool _check_value = eyedb::True);
  ProtectionMode getMode(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~ProtectionUser() {garbageRealize();}

 protected:
  ProtectionUser(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : eyedb::Struct(_db, _dataspace) {}
  ProtectionUser(const eyedb::Struct *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}
  ProtectionUser(const ProtectionUser *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  ProtectionUser(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  ProtectionUser(const ProtectionUser *, eyedb::Bool = eyedb::False);
  ProtectionUser(const eyedb::Class *, eyedb::Data);
};

class Protection : public eyedb::Struct {

 public:
  Protection(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Protection(const Protection& x);

  virtual eyedb::Object *clone() const {return new Protection(*this);};

  Protection& operator=(const Protection& x);

  virtual Protection *asProtection() {return this;}
  virtual const Protection *asProtection() const {return this;}

  eyedb::Status setName(const std::string &);
  eyedb::Status setName(unsigned int a0, char );
  std::string getName(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getName(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setPusers(unsigned int a0, ProtectionUser*);
  eyedb::Status setPusersCount(unsigned int a0);
  ProtectionUser*getPusers(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const ProtectionUser*getPusers(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  unsigned int getPusersCount(eyedb::Status * = 0) const;

  eyedb::Status setPoid(eyedb::Oid );
  eyedb::Oid getPoid(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~Protection() {garbageRealize();}
  // Protection User Part

    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    

 protected:
  Protection(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : eyedb::Struct(_db, _dataspace) {}
  Protection(const eyedb::Struct *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}
  Protection(const Protection *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Protection(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Protection(const Protection *, eyedb::Bool = eyedb::False);
  Protection(const eyedb::Class *, eyedb::Data);
};

class UnreadableObject : public eyedb::Struct {

 public:
  UnreadableObject(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  UnreadableObject(const UnreadableObject& x);

  virtual eyedb::Object *clone() const {return new UnreadableObject(*this);};

  UnreadableObject& operator=(const UnreadableObject& x);

  virtual UnreadableObject *asUnreadableObject() {return this;}
  virtual const UnreadableObject *asUnreadableObject() const {return this;}
  virtual ~UnreadableObject() {garbageRealize();}
  // UnreadableObject User Part

    Status trace_realize(FILE*, int, unsigned int, const RecMode *) const;
    static Bool isUnreadableObject(const Object *);
    static Bool isUnreadableObject(const Class *);
    

 protected:
  UnreadableObject(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : eyedb::Struct(_db, _dataspace) {}
  UnreadableObject(const eyedb::Struct *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}
  UnreadableObject(const UnreadableObject *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  UnreadableObject(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  UnreadableObject(const UnreadableObject *, eyedb::Bool = eyedb::False);
  UnreadableObject(const eyedb::Class *, eyedb::Data);
};

class ClassConversion : public eyedb::Struct {

 public:
  ClassConversion(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  ClassConversion(const ClassConversion& x);

  virtual eyedb::Object *clone() const {return new ClassConversion(*this);};

  ClassConversion& operator=(const ClassConversion& x);

  virtual ClassConversion *asClassConversion() {return this;}
  virtual const ClassConversion *asClassConversion() const {return this;}

  eyedb::Status setUpdtype(ClassUpdateType , eyedb::Bool _check_value = eyedb::True);
  ClassUpdateType getUpdtype(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setCnvtype(AttributeConvertType , eyedb::Bool _check_value = eyedb::True);
  AttributeConvertType getCnvtype(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setClsname(const std::string &);
  eyedb::Status setClsname(unsigned int a0, char );
  std::string getClsname(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getClsname(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setAttrname(const std::string &);
  eyedb::Status setAttrname(unsigned int a0, char );
  std::string getAttrname(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char getAttrname(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setAttrnum(eyedblib::int32 );
  eyedblib::int32 getAttrnum(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setOidO(eyedb::Oid );
  eyedb::Oid getOidO(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setOidN(eyedb::Oid );
  eyedb::Oid getOidN(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setRoidO(eyedb::Oid );
  eyedb::Oid getRoidO(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setSync(eyedblib::int32 );
  eyedblib::int32 getSync(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setWithCheck(eyedblib::int32 );
  eyedblib::int32 getWithCheck(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setSrcDim(eyedblib::int32 );
  eyedblib::int32 getSrcDim(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setDestDim(eyedblib::int32 );
  eyedblib::int32 getDestDim(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setOffsetO(eyedblib::int32 );
  eyedblib::int32 getOffsetO(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setOffsetN(eyedblib::int32 );
  eyedblib::int32 getOffsetN(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setSizeO(eyedblib::int32 );
  eyedblib::int32 getSizeO(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setSizeN(eyedblib::int32 );
  eyedblib::int32 getSizeN(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status setCnvMth(BEMethod_C*);
  BEMethod_C*getCnvMth(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const BEMethod_C*getCnvMth(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid getCnvMthOid(eyedb::Status * = 0) const;
  eyedb::Status setCnvMthOid(const eyedb::Oid &);
  virtual ~ClassConversion() {garbageRealize();}
  // ClassConversion User Part

    struct Context {
      const Class *cls;
      ObjectArray obj_arr;
      Context *next;
      Context();
      ~Context();
    };

    const Class *cls_;
    const Attribute *attr_;
    static Status getClass_(Database *, const Oid &ocloid,
       const Class *&,
       ClassConversion::Context *&,
       Bool class_to_class = False);
    static Status convert(Database *, const ClassConversion::Context *,
     Data in_idr, Size in_size);
    Status convert(Database *db, Data in_idr, Size &in_size);
    static Size computeSize(ClassConversion::Context *conv_ctx,
       Size start_size);
    void computeSize(Size &cur_size);

    static void init();
    static void _release();

    void userInitialize();
    void userCopy(const Object &);
    void userGarbage();
    

 protected:
  ClassConversion(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : eyedb::Struct(_db, _dataspace) {}
  ClassConversion(const eyedb::Struct *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}
  ClassConversion(const ClassConversion *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  ClassConversion(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  ClassConversion(const ClassConversion *, eyedb::Bool = eyedb::False);
  ClassConversion(const eyedb::Class *, eyedb::Data);
};


extern eyedb::Object *sysclsMakeObject(eyedb::Object *, eyedb::Bool=eyedb::True);
extern eyedb::Bool syscls_set_oid_check(eyedb::Bool);
extern eyedb::Bool syscls_get_oid_check();

extern eyedb::EnumClass *IndexType_Class;
extern eyedb::EnumClass *ExecutableLang_Class;
extern eyedb::EnumClass *ArgType_Type_Class;
extern eyedb::EnumClass *ExecutableLocalisation_Class;
extern eyedb::EnumClass *ExecutableType_Class;
extern eyedb::EnumClass *TriggerType_Class;
extern eyedb::EnumClass *ProtectionMode_Class;
extern eyedb::EnumClass *ClassUpdateType_Class;
extern eyedb::EnumClass *AttributeConvertType_Class;
extern eyedb::StructClass *AttributeComponent_Class;
extern eyedb::StructClass *AttributeComponentSet_Class;
extern eyedb::StructClass *ClassComponent_Class;
extern eyedb::StructClass *AgregatClassComponent_Class;
extern eyedb::StructClass *ClassVariable_Class;
extern eyedb::StructClass *Index_Class;
extern eyedb::StructClass *HashIndex_Class;
extern eyedb::StructClass *BTreeIndex_Class;
extern eyedb::StructClass *CollAttrImpl_Class;
extern eyedb::StructClass *ArgType_Class;
extern eyedb::StructClass *Signature_Class;
extern eyedb::StructClass *Executable_Class;
extern eyedb::StructClass *AgregatClassExecutable_Class;
extern eyedb::StructClass *Method_Class;
extern eyedb::StructClass *FEMethod_Class;
extern eyedb::StructClass *FEMethod_C_Class;
extern eyedb::StructClass *BEMethod_Class;
extern eyedb::StructClass *BEMethod_C_Class;
extern eyedb::StructClass *BEMethod_OQL_Class;
extern eyedb::StructClass *Trigger_Class;
extern eyedb::StructClass *UniqueConstraint_Class;
extern eyedb::StructClass *NotNullConstraint_Class;
extern eyedb::StructClass *CardinalityDescription_Class;
extern eyedb::StructClass *CardinalityConstraint_Class;
extern eyedb::StructClass *CardinalityConstraint_Test_Class;
extern eyedb::StructClass *ProtectionUser_Class;
extern eyedb::StructClass *Protection_Class;
extern eyedb::StructClass *UnreadableObject_Class;
extern eyedb::StructClass *ClassConversion_Class;


}

#endif
